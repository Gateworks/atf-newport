
/*
 * Copyright (C) 2018 Marvell International Ltd.
 *
 * SPDX-License-Identifier:     BSD-3-Clause
 * https://spdx.org/licenses
 */

#include <arch.h>
#include <stdio.h>
#include <debug.h>
#include <string.h>
#include <platform_def.h>
#include <timers.h>
#include <delay_timer.h>
#include <platform_def.h>
#include <octeontx_common.h>
#include <plat_board_cfg.h>
#include <cgx.h>
#include <phy_mgmt.h>
#include <smi.h>

/* define DEBUG_ATF_VITESSE_PHY_DRIVER to enable debug logs */
#undef DEBUG_ATF_VITESSE_PHY_DRIVER	/* Generic PHY Driver logs */

#ifdef DEBUG_ATF_VITESSE_PHY_DRIVER
#define debug_phy_driver printf
#else
#define debug_phy_driver(...) ((void) (0))
#endif

static const uint8_t vitesse_vsc8574_program[] = {
	0x44, 0x83, 0x02, 0x42, 0x12, 0x02, 0x44, 0x93, 0x02, 0x44,
	0xca, 0x02, 0x44, 0x4d, 0x02, 0x43, 0xef, 0xed, 0xff, 0xe5,
	0xfc, 0x54, 0x38, 0x64, 0x20, 0x70, 0x08, 0x65, 0xff, 0x70,
	0x04, 0xed, 0x44, 0x80, 0xff, 0x22, 0x8f, 0x19, 0x7b, 0xbb,
	0x7d, 0x0e, 0x7f, 0x04, 0x12, 0x3d, 0xd7, 0xef, 0x4e, 0x60,
	0x03, 0x02, 0x41, 0xf9, 0xe4, 0xf5, 0x1a, 0x74, 0x01, 0x7e,
	0x00, 0xa8, 0x1a, 0x08, 0x80, 0x05, 0xc3, 0x33, 0xce, 0x33,
	0xce, 0xd8, 0xf9, 0xff, 0xef, 0x55, 0x19, 0x70, 0x03, 0x02,
	0x41, 0xed, 0x85, 0x1a, 0xfb, 0x7b, 0xbb, 0xe4, 0xfd, 0xff,
	0x12, 0x3d, 0xd7, 0xef, 0x4e, 0x60, 0x03, 0x02, 0x41, 0xed,
	0xe5, 0x1a, 0x54, 0x02, 0x75, 0x1d, 0x00, 0x25, 0xe0, 0x25,
	0xe0, 0xf5, 0x1c, 0xe4, 0x78, 0xc5, 0xf6, 0xd2, 0x02, 0x12,
	0x41, 0xfa, 0x7b, 0xff, 0x7d, 0x12, 0x7f, 0x07, 0x12, 0x3d,
	0xd7, 0xef, 0x4e, 0x60, 0x03, 0x02, 0x41, 0xe7, 0xc2, 0x02,
	0x74, 0xc7, 0x25, 0x1a, 0xf9, 0x74, 0xe7, 0x25, 0x1a, 0xf8,
	0xe6, 0x27, 0xf5, 0x1b, 0xe5, 0x1d, 0x24, 0x5b, 0x12, 0x44,
	0x2a, 0x12, 0x3e, 0xda, 0x7b, 0xfc, 0x7d, 0x11, 0x7f, 0x07,
	0x12, 0x3d, 0xd7, 0x78, 0xcc, 0xef, 0xf6, 0x78, 0xc1, 0xe6,
	0xfe, 0xef, 0xd3, 0x9e, 0x40, 0x06, 0x78, 0xcc, 0xe6, 0x78,
	0xc1, 0xf6, 0x12, 0x41, 0xfa, 0x7b, 0xec, 0x7d, 0x12, 0x7f,
	0x07, 0x12, 0x3d, 0xd7, 0x78, 0xcb, 0xef, 0xf6, 0xbf, 0x07,
	0x06, 0x78, 0xc3, 0x76, 0x1a, 0x80, 0x1f, 0x78, 0xc5, 0xe6,
	0xff, 0x60, 0x0f, 0xc3, 0xe5, 0x1b, 0x9f, 0xff, 0x78, 0xcb,
	0xe6, 0x85, 0x1b, 0xf0, 0xa4, 0x2f, 0x80, 0x07, 0x78, 0xcb,
	0xe6, 0x85, 0x1b, 0xf0, 0xa4, 0x78, 0xc3, 0xf6, 0xe4, 0x78,
	0xc2, 0xf6, 0x78, 0xc2, 0xe6, 0xff, 0xc3, 0x08, 0x96, 0x40,
	0x03, 0x02, 0x41, 0xd1, 0xef, 0x54, 0x03, 0x60, 0x33, 0x14,
	0x60, 0x46, 0x24, 0xfe, 0x60, 0x42, 0x04, 0x70, 0x4b, 0xef,
	0x24, 0x02, 0xff, 0xe4, 0x33, 0xfe, 0xef, 0x78, 0x02, 0xce,
	0xa2, 0xe7, 0x13, 0xce, 0x13, 0xd8, 0xf8, 0xff, 0xe5, 0x1d,
	0x24, 0x5c, 0xcd, 0xe5, 0x1c, 0x34, 0xf0, 0xcd, 0x2f, 0xff,
	0xed, 0x3e, 0xfe, 0x12, 0x44, 0x6a, 0x7d, 0x11, 0x80, 0x0b,
	0x78, 0xc2, 0xe6, 0x70, 0x04, 0x7d, 0x11, 0x80, 0x02, 0x7d,
	0x12, 0x7f, 0x07, 0x12, 0x3e, 0x9a, 0x8e, 0x1e, 0x8f, 0x1f,
	0x80, 0x03, 0xe5, 0x1e, 0xff, 0x78, 0xc5, 0xe6, 0x06, 0x24,
	0xcd, 0xf8, 0xa6, 0x07, 0x78, 0xc2, 0x06, 0xe6, 0xb4, 0x1a,
	0x0a, 0xe5, 0x1d, 0x24, 0x5c, 0x12, 0x44, 0x2a, 0x12, 0x3e,
	0xda, 0x78, 0xc5, 0xe6, 0x65, 0x1b, 0x70, 0x82, 0x75, 0xdb,
	0x20, 0x75, 0xdb, 0x28, 0x12, 0x44, 0x42, 0x12, 0x44, 0x42,
	0xe5, 0x1a, 0x12, 0x44, 0x35, 0xe5, 0x1a, 0xc3, 0x13, 0x12,
	0x44, 0x35, 0x78, 0xc5, 0x16, 0xe6, 0x24, 0xcd, 0xf8, 0xe6,
	0xff, 0x7e, 0x08, 0x1e, 0xef, 0xa8, 0x06, 0x08, 0x80, 0x02,
	0xc3, 0x13, 0xd8, 0xfc, 0xfd, 0xc4, 0x33, 0x54, 0xe0, 0xf5,
	0xdb, 0xef, 0xa8, 0x06, 0x08, 0x80, 0x02, 0xc3, 0x13, 0xd8,
	0xfc, 0xfd, 0xc4, 0x33, 0x54, 0xe0, 0x44, 0x08, 0xf5, 0xdb,
	0xee, 0x70, 0xd8, 0x78, 0xc5, 0xe6, 0x70, 0xc8, 0x75, 0xdb,
	0x10, 0x02, 0x40, 0xfd, 0x78, 0xc2, 0xe6, 0xc3, 0x94, 0x17,
	0x50, 0x0e, 0xe5, 0x1d, 0x24, 0x62, 0x12, 0x42, 0x08, 0xe5,
	0x1d, 0x24, 0x5c, 0x12, 0x42, 0x08, 0x20, 0x02, 0x03, 0x02,
	0x40, 0x76, 0x05, 0x1a, 0xe5, 0x1a, 0xc3, 0x94, 0x04, 0x50,
	0x03, 0x02, 0x40, 0x3a, 0x22, 0xe5, 0x1d, 0x24, 0x5c, 0xff,
	0xe5, 0x1c, 0x34, 0xf0, 0xfe, 0x12, 0x44, 0x6a, 0x22, 0xff,
	0xe5, 0x1c, 0x34, 0xf0, 0xfe, 0x12, 0x44, 0x6a, 0x22, 0xd2,
	0x00, 0x75, 0xfb, 0x03, 0xab, 0x7e, 0xaa, 0x7d, 0x7d, 0x19,
	0x7f, 0x03, 0x12, 0x3e, 0xda, 0xe5, 0x7e, 0x54, 0x0f, 0x24,
	0xf3, 0x60, 0x03, 0x02, 0x42, 0xb9, 0x12, 0x44, 0xa3, 0x12,
	0x44, 0xaa, 0xd8, 0xfb, 0xff, 0x20, 0xe2, 0x2a, 0x13, 0x92,
	0x04, 0xef, 0xa2, 0xe1, 0x92, 0x03, 0x30, 0x04, 0x1f, 0xe4,
	0xf5, 0x10, 0xe5, 0x10, 0x24, 0x17, 0xfd, 0x7b, 0x54, 0x7f,
	0x04, 0x12, 0x3d, 0xd7, 0x74, 0x25, 0x25, 0x10, 0xf8, 0xa6,
	0x07, 0x05, 0x10, 0xe5, 0x10, 0xc3, 0x94, 0x02, 0x40, 0xe4,
	0x12, 0x44, 0xa3, 0x12, 0x44, 0xaa, 0xd8, 0xfb, 0x54, 0x05,
	0x64, 0x04, 0x70, 0x27, 0x78, 0xc4, 0xe6, 0x78, 0xc6, 0xf6,
	0xe5, 0x7d, 0xff, 0x33, 0x95, 0xe0, 0xef, 0x54, 0x0f, 0x78,
	0xc4, 0xf6, 0x12, 0x42, 0xcf, 0x20, 0x04, 0x0c, 0x12, 0x44,
	0xa3, 0x12, 0x44, 0xaa, 0xd8, 0xfb, 0x13, 0x92, 0x05, 0x22,
	0xc2, 0x05, 0x22, 0x12, 0x44, 0xa3, 0x12, 0x44, 0xaa, 0xd8,
	0xfb, 0x54, 0x05, 0x64, 0x05, 0x70, 0x1e, 0x78, 0xc4, 0x7d,
	0xb8, 0x12, 0x42, 0xc5, 0x78, 0xc1, 0x7d, 0x74, 0x12, 0x42,
	0xc5, 0xe4, 0x78, 0xc1, 0xf6, 0x22, 0x7b, 0x01, 0x7a, 0x00,
	0x7d, 0xee, 0x7f, 0x92, 0x12, 0x38, 0xbd, 0x22, 0xe6, 0xfb,
	0x7a, 0x00, 0x7f, 0x92, 0x12, 0x38, 0xbd, 0x22, 0x78, 0xc1,
	0xe6, 0xfb, 0x7a, 0x00, 0x7d, 0x74, 0x7f, 0x92, 0x12, 0x38,
	0xbd, 0xe4, 0x78, 0xc1, 0xf6, 0xf5, 0x11, 0x74, 0x01, 0x7e,
	0x00, 0xa8, 0x11, 0x08, 0x80, 0x05, 0xc3, 0x33, 0xce, 0x33,
	0xce, 0xd8, 0xf9, 0xff, 0x78, 0xc4, 0xe6, 0xfd, 0xef, 0x5d,
	0x60, 0x44, 0x85, 0x11, 0xfb, 0xe5, 0x11, 0x54, 0x02, 0x25,
	0xe0, 0x25, 0xe0, 0xfe, 0xe4, 0x24, 0x5b, 0xfb, 0xee, 0x12,
	0x44, 0x2d, 0x12, 0x3e, 0xda, 0x7b, 0x40, 0x7d, 0x11, 0x7f,
	0x07, 0x12, 0x3d, 0xd7, 0x74, 0xc7, 0x25, 0x11, 0xf8, 0xa6,
	0x07, 0x7b, 0x11, 0x7d, 0x12, 0x7f, 0x07, 0x12, 0x3d, 0xd7,
	0xef, 0x4e, 0x60, 0x09, 0x74, 0xe7, 0x25, 0x11, 0xf8, 0x76,
	0x04, 0x80, 0x07, 0x74, 0xe7, 0x25, 0x11, 0xf8, 0x76, 0x0a,
	0x05, 0x11, 0xe5, 0x11, 0xc3, 0x94, 0x04, 0x40, 0x9a, 0x78,
	0xc6, 0xe6, 0x70, 0x15, 0x78, 0xc4, 0xe6, 0x60, 0x10, 0x75,
	0xd9, 0x38, 0x75, 0xdb, 0x10, 0x7d, 0xfe, 0x12, 0x43, 0x7d,
	0x7d, 0x76, 0x12, 0x43, 0x7d, 0x79, 0xc6, 0xe7, 0x78, 0xc4,
	0x66, 0xff, 0x60, 0x03, 0x12, 0x40, 0x25, 0x78, 0xc4, 0xe6,
	0x70, 0x09, 0xfb, 0xfa, 0x7d, 0xfe, 0x7f, 0x8e, 0x12, 0x38,
	0xbd, 0x22, 0x7b, 0x01, 0x7a, 0x00, 0x7f, 0x8e, 0x12, 0x38,
	0xbd, 0x22, 0xe4, 0xf5, 0x19, 0x74, 0x25, 0x25, 0x19, 0xf8,
	0xe6, 0x64, 0x03, 0x60, 0x51, 0xe5, 0x19, 0x24, 0x17, 0xfd,
	0x7b, 0xeb, 0x7f, 0x04, 0x12, 0x3d, 0xd7, 0x8f, 0xfb, 0x7b,
	0x22, 0x7d, 0x18, 0x7f, 0x06, 0x12, 0x3d, 0xd7, 0xef, 0x64,
	0x01, 0x4e, 0x60, 0x1c, 0x7d, 0x1c, 0xe4, 0xff, 0x12, 0x3e,
	0x9a, 0xef, 0x54, 0x1b, 0x64, 0x0a, 0x70, 0x15, 0x7b, 0xcc,
	0x7d, 0x10, 0xff, 0x12, 0x3d, 0xd7, 0xef, 0x64, 0x01, 0x4e,
	0x70, 0x07, 0x12, 0x44, 0xb1, 0x7b, 0x03, 0x80, 0x0a, 0x12,
	0x44, 0xb1, 0x74, 0x25, 0x25, 0x19, 0xf8, 0xe6, 0xfb, 0x7a,
	0x00, 0x7d, 0x54, 0x12, 0x38, 0xbd, 0x05, 0x19, 0xe5, 0x19,
	0xc3, 0x94, 0x02, 0x40, 0x9c, 0x22, 0xe5, 0x7e, 0x30, 0xe5,
	0x35, 0x30, 0xe4, 0x0b, 0x7b, 0x02, 0x7d, 0x33, 0x7f, 0x35,
	0x12, 0x36, 0x29, 0x80, 0x10, 0x7b, 0x01, 0x7d, 0x33, 0x7f,
	0x35, 0x12, 0x36, 0x29, 0x90, 0x47, 0xd2, 0xe0, 0x44, 0x04,
	0xf0, 0x90, 0x47, 0xd2, 0xe0, 0x54, 0xf7, 0xf0, 0x90, 0x47,
	0xd1, 0xe0, 0x44, 0x10, 0xf0, 0x7b, 0x05, 0x7d, 0x84, 0x7f,
	0x86, 0x12, 0x36, 0x29, 0x22, 0xfb, 0xe5, 0x1c, 0x34, 0xf0,
	0xfa, 0x7d, 0x10, 0x7f, 0x07, 0x22, 0x54, 0x01, 0xc4, 0x33,
	0x54, 0xe0, 0xf5, 0xdb, 0x44, 0x08, 0xf5, 0xdb, 0x22, 0xf5,
	0xdb, 0x75, 0xdb, 0x08, 0xf5, 0xdb, 0x75, 0xdb, 0x08, 0x22,
	0xe5, 0x7e, 0x54, 0x0f, 0x64, 0x01, 0x70, 0x0d, 0xe5, 0x7e,
	0x30, 0xe4, 0x08, 0x90, 0x47, 0xd0, 0xe0, 0x44, 0x02, 0xf0,
	0x22, 0x90, 0x47, 0xd0, 0xe0, 0x54, 0xfd, 0xf0, 0x22, 0xab,
	0x07, 0xaa, 0x06, 0x7d, 0x10, 0x7f, 0x07, 0x12, 0x3e, 0xda,
	0x7b, 0xff, 0x7d, 0x10, 0x7f, 0x07, 0x12, 0x3d, 0xd7, 0xef,
	0x4e, 0x60, 0xf3, 0x22, 0x12, 0x44, 0xc5, 0x12, 0x44, 0xbb,
	0x90, 0x47, 0xfa, 0xe0, 0x54, 0xf8, 0x44, 0x02, 0xf0, 0x22,
	0x30, 0x04, 0x03, 0x12, 0x43, 0x87, 0x78, 0xc4, 0xe6, 0xff,
	0x60, 0x03, 0x12, 0x40, 0x25, 0x22, 0xe5, 0x7e, 0xae, 0x7d,
	0x78, 0x04, 0x22, 0xce, 0xa2, 0xe7, 0x13, 0xce, 0x13, 0x22,
	0xe5, 0x19, 0x24, 0x17, 0x54, 0x1f, 0x44, 0x80, 0xff, 0x22,
	0xe4, 0x78, 0xc4, 0xf6, 0xc2, 0x05, 0x78, 0xc1, 0xf6, 0x22,
	0xc2, 0x04, 0xc2, 0x03, 0x22, 0x22
};

static const uint16_t vsc8574_program_crc = 0xB7C2;

/* Ref PHY_API Patch : Octeon SDK code base */
static void phy_vitesse_vsc8574_program(phy_config_t *phy)
{
	int val;
	int timeout = 10;

	smi_write(phy->mdio_bus, phy->addr, -1, CLAUSE22, 31, 0x0010);
	smi_write(phy->mdio_bus, phy->addr, -1, CLAUSE22, 18, 0x800F);
	smi_write(phy->mdio_bus, phy->addr, -1, CLAUSE22, 31, 0x0010);

	do {
		val = smi_read(phy->mdio_bus, CLAUSE22, phy->addr, -1, 18);
		if (!(val & (1 << 15)))
			break;
		mdelay(10);
	} while (timeout--);

	if (!timeout)
		WARN("%s: Operation 1 not complete, timeout\n", __func__);

	smi_write(phy->mdio_bus, phy->addr, -1, CLAUSE22, 31, 0x0);
	smi_write(phy->mdio_bus, phy->addr, -1, CLAUSE22, 31, 0x0010);

	val = smi_read(phy->mdio_bus, CLAUSE22, phy->addr, -1, 12);
	val &= 0x0800;
	smi_write(phy->mdio_bus, phy->addr, -1, CLAUSE22, 12, val);

	smi_write(phy->mdio_bus, phy->addr, -1, CLAUSE22, 9, 0x005B);
	smi_write(phy->mdio_bus, phy->addr, -1, CLAUSE22, 10, 0x005B);

	val = smi_read(phy->mdio_bus, CLAUSE22, phy->addr, -1, 12);
	val &= 0x0800;
	smi_write(phy->mdio_bus, phy->addr, -1, CLAUSE22, 12, val);
	smi_write(phy->mdio_bus, phy->addr, -1, CLAUSE22, 18, 0x800F);

	val = smi_read(phy->mdio_bus, CLAUSE22, phy->addr, -1, 0);
	val &= 0x0800;
	smi_write(phy->mdio_bus, phy->addr, -1, CLAUSE22, 0, val);
	smi_write(phy->mdio_bus, phy->addr, -1, CLAUSE22, 18, 0);

	val = smi_read(phy->mdio_bus, CLAUSE22, phy->addr, -1, 12);
	val &= 0x0800;
	smi_write(phy->mdio_bus, phy->addr, -1, CLAUSE22, 12, val);

	smi_write(phy->mdio_bus, phy->addr, -1, CLAUSE22, 31, 0x0010);
	smi_write(phy->mdio_bus, phy->addr, -1, CLAUSE22, 0, 0x7009);
	smi_write(phy->mdio_bus, phy->addr, -1, CLAUSE22, 12, 0x5002);
	smi_write(phy->mdio_bus, phy->addr, -1, CLAUSE22, 11, 0x0000);

	for (int i = 0; i < sizeof(vitesse_vsc8574_program); i++) {
		val = (0x5000 | vitesse_vsc8574_program[i]);
		smi_write(phy->mdio_bus, phy->addr, -1, CLAUSE22, 12, val);
	}

	smi_write(phy->mdio_bus, phy->addr, -1, CLAUSE22, 12, 0x0);
	smi_write(phy->mdio_bus, phy->addr, -1, CLAUSE22, 3, 0x3EB7);
	smi_write(phy->mdio_bus, phy->addr, -1, CLAUSE22, 4, 0x4012);
	smi_write(phy->mdio_bus, phy->addr, -1, CLAUSE22, 12, 0x0100);
	smi_write(phy->mdio_bus, phy->addr, -1, CLAUSE22, 0, 0x4018);
	smi_write(phy->mdio_bus, phy->addr, -1, CLAUSE22, 0, 0xC018);

	smi_write(phy->mdio_bus, phy->addr, -1, CLAUSE22, 31, 0x0001);
	smi_write(phy->mdio_bus, phy->addr, -1, CLAUSE22, 25, 0x4000);
	smi_write(phy->mdio_bus, phy->addr, -1, CLAUSE22, 26,
			(sizeof(vitesse_vsc8574_program) + 1));
	smi_write(phy->mdio_bus, phy->addr, -1, CLAUSE22, 31, 0x0010);
	smi_write(phy->mdio_bus, phy->addr, -1, CLAUSE22, 18, 0x8008);

	do {
		val = smi_read(phy->mdio_bus, CLAUSE22, phy->addr, -1, 18);
		if (!(val & (1 << 15)))
			break;
		mdelay(10);
	} while (timeout--);

	if (!timeout)
		WARN("%s: Operation 2 not complete, timeout\n", __func__);

	smi_write(phy->mdio_bus, phy->addr, -1, CLAUSE22, 31, 0x0001);

	/* CRC check */
	val = smi_read(phy->mdio_bus, CLAUSE22, phy->addr, -1, 25);
	if (val != vsc8574_program_crc) {
		WARN("%s: Expected CRC 0x%x, Calculated CRC 0x%x\n",
			__func__, vsc8574_program_crc, val);
	}
	smi_write(phy->mdio_bus, phy->addr, -1, CLAUSE22, 31, 0x0000);
}

/* One time initialization for the PHY if required */
void phy_vitesse_probe(int cgx_id, int lmac_id)
{
	int val;
	int mdio_addr;
	int timeout = 10;
	phy_config_t *phy;
	cgx_lmac_config_t *lmac;

	debug_phy_driver("%s: %d:%d\n", __func__, cgx_id, lmac_id);

	lmac = &plat_octeontx_bcfg->cgx_cfg[cgx_id].lmac_cfg[lmac_id];
	phy = &lmac->phy_config;

	/* Read the PHY ID */
	debug_phy_driver("%s: %d:%d\n", __func__, phy->mdio_bus, phy->addr);
	val = smi_read(phy->mdio_bus, CLAUSE22, phy->addr, -1, MII_PHY_ID1_REG);
	if (val != PHY_VSC8574_ID1) {
		ERROR("%s: Incorrect PHY ID1 read for VSC8574 0x%x\n", __func__, val);
		return;
	}
	debug_phy_driver("%s: REG 2 val 0x%x\n", __func__, val);

	val = smi_read(phy->mdio_bus, CLAUSE22, phy->addr, -1, MII_PHY_ID2_REG);
	if (val != PHY_VSC8574_ID2) {
		ERROR("%s: Incorrect PHY ID2 read for VSC8574 0x%x\n", __func__, val);
		return;
	}
	debug_phy_driver("%s: REG 3 val 0x%x\n", __func__, val);

	/* Ref : Section 2.21 Configuration section from VSC8574 DS Rev 4.0
	 * To configure the device, perform the following steps:
	 */

	/* 1. COMA_MODE active, driven low to ground (no SW interventions)
	 * 2. Apply Power
	 * 3. Apply RefClk
	 * 4. Release reset, drive high. Power and clock must be stable before
	 * releasing reset.
	 * 5. Wait 120ms minimum.
	 * 6. Apply patch from PHY_API (required for production released)
	 */
	/* Start with Step 6. Assume, steps 1 - 5 are done during reset */
	phy_vitesse_vsc8574_program(phy);

	/* This PHY needs to be initialized once but all the 4 ports need
	 * to be programmed to correct MAC mode
	 */
	for (int port = 0; port < 4; port++) {
		mdio_addr = phy->addr +  port;

		debug_phy_driver("%s: port %d phy->addr 0x%x mdio_addr 0x%x\n",
					__func__, port,
					phy->addr, mdio_addr);
		/* 7. Configure register 19G for MAC mode (to access register
		 * 19G, register 31 must be 0x10).  Read register 19G.  Set
		 * bits 15:14, MAC configuration as follows:
		 *	00: SGMII
		 *	01: QSGMII
		 *	10: Reserved
		 *	11: Reserved
		 * Write new register 19G.
		 */
		smi_write(phy->mdio_bus, mdio_addr, -1, CLAUSE22, 31, 0x0010);
		val = smi_read(phy->mdio_bus, CLAUSE22, mdio_addr, -1, 19);
		val = val & 0x3fff;
		if (lmac->mode == CAVM_CGX_LMAC_TYPES_E_QSGMII)
			val |= 0x4000;

		smi_write(phy->mdio_bus, mdio_addr, -1, CLAUSE22, 19, val);

		/* 8. Configure register 18G for MAC on all 4 PHYs write:
		 * SGMII: 0x80F0
		 * QSGMII: 0x80e0
		 * Read register 18G until bit 15 equals 0
		 */
		val = (lmac->mode == CAVM_CGX_LMAC_TYPES_E_QSGMII) ? 0x80E0 : 0x80F0;
		debug_phy_driver("%s: Configuring the VSC8574 PHY for %d mode\n",
				__func__, lmac->mode);
		smi_write(phy->mdio_bus, mdio_addr, -1, CLAUSE22, 18, val);

		do {
			val = smi_read(phy->mdio_bus, CLAUSE22, mdio_addr, -1, 18);
			if (!(val & (1 << 15)))
				break;
			mdelay(100);
		} while (timeout--);

		if (!timeout)
			WARN("%s: MAC mode configuration not complete, timeout\n", __func__);

		smi_write(phy->mdio_bus, mdio_addr, -1, CLAUSE22, 31, 0);
		/* 9. If Fiber Media on all 4 PHYs configure register 18G by writing:
		 *    Media 1000BX: 0x8FC1
		 *    Media 100FX: 0x8FD1
		 */
		if (phy->media_type) {
			debug_phy_driver("%s: media type is not copper\n", __func__);
			if (phy->media_type == PHY_MEDIA_1000BX)
				val = 0x8FC1;
			else if (phy->media_type == PHY_MEDIA_100FX)
				val = 0x8FD1;
			else
				val = 0;
			smi_write(phy->mdio_bus, mdio_addr, -1, CLAUSE22, 18, val);

			/* 10. If Fiber Media read register 18G till (SIC) bit 15
			 * equals 0.
			 */
			do {
				val = smi_read(phy->mdio_bus, CLAUSE22, mdio_addr, -1, 18);
				if (!(val & (1 << 15)))
					break;
				mdelay(10);
			} while (timeout--);
			if (!timeout)
				WARN("%s: PHY optical configuration not complete, timeout\n", __func__);
		}

		/* 11. Configure register 23 for MAC and Media mode (to access
		 * register 23, register 31 must be 0). Read register 23.
		 *	Set bits 10:8 as follows:
		 *	000: Copper
		 *	010: 1000BX
		 *	011: 100FX
		 * Write new register 23.
		 */
		val = smi_read(phy->mdio_bus, CLAUSE22, mdio_addr, -1, 23);

		val &= 0xF8FF; /* Copper Medium */

		if (phy->media_type == PHY_MEDIA_1000BX)
			val |= 0x0200;
		else if (phy->media_type == PHY_MEDIA_100FX)
			val |= 0x0300;
		smi_write(phy->mdio_bus, mdio_addr, -1, CLAUSE22, 23, val);

		/* 12. Software reset. Read register 0 (to access register 0,
		 *     register 31 must be 0). Set bit 15 to 1.
		 *     Write new register 0.
		 */
		smi_write(phy->mdio_bus, mdio_addr, -1, CLAUSE22, 31, 0);
		val = smi_read(phy->mdio_bus, CLAUSE22, mdio_addr, -1, 0);
		val |= 0x8000;
		smi_write(phy->mdio_bus, mdio_addr, -1, CLAUSE22, 0, val);

		/* 13. Read register 0 until bit 15 equals 0 */
		do {
			val = smi_read(phy->mdio_bus, CLAUSE22, mdio_addr, -1, 18);
			if (!(val & (1 << 15)))
				break;
			mdelay(10);
		} while (timeout--);

		if (!timeout)
			WARN("%s: PHY I/O error, timeout\n", __func__);

		smi_write(phy->mdio_bus, mdio_addr, -1, CLAUSE22, 31, 3);
		smi_write(phy->mdio_bus, mdio_addr, -1, CLAUSE22, 16, 0x80);
		smi_write(phy->mdio_bus, mdio_addr, -1, CLAUSE22, 31, 0);

		/* If PHY programming is successful, make the PHY initialized
		 * on other LMACs as well. FIXME: in a proper way
		 */
		for (int i = 0; i < MAX_LMAC_PER_CGX; i++) {
			lmac = &plat_octeontx_bcfg->cgx_cfg[cgx_id].lmac_cfg[i];
			lmac->phy_config.init = 1;
		}
	}
}

/* To set the operating mode of the PHY if required */
void phy_vitesse_config(int cgx_id, int lmac_id)
{
	debug_phy_driver("%s: %d:%d\n", __func__, cgx_id, lmac_id);
}


/* Table of Vitesse PHY driver list */
phy_drv_t vitesse_drv[] = {
	{
		.drv_name		= "VITESSE-VSC8574",
		.drv_type 		= PHY_VITESSE_8574,
		.flags 			= 0,
		.probe			= phy_vitesse_probe,
		.config 		= phy_vitesse_config,
		.set_an			= phy_generic_set_an,
		.reset			= phy_generic_reset,
		.get_link_status	= phy_generic_c22_get_link_status,
		.shutdown		= phy_generic_shutdown,
	},
};

phy_drv_t *phy_vitesse_drv_lookup(int type)
{
	for (int i = 0; i < ARRAY_SIZE(vitesse_drv); i++) {
		if (type == vitesse_drv[i].drv_type) {
			debug_phy_driver("%s: found matching VITESSE PHY driver for type %d\n",
				__func__, type);
			return &vitesse_drv[i];
		}
	}
	return NULL;
}


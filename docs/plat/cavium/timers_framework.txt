CAVIUM
======

ARM Trusted Firmware timers framework
=====================================

Purpose of this document is to describe timers framework in ATF, porting guide
for this and example of usage. Main part is description of API exposed by timers
library.


Timers framework
-----------------
Timers framework purpose is to provide layer of abstraction when using hardware
timers. Simple API makes developing of time-related tasks easier. Timers
framework consist of two main parts:
 - Timers library - frontend of framework, which makes use of hardware exposed
   by lower level drivers and provides API for developers.
 - Platform timers driver - backend of framework, which consist of hardware
   drivers, directly operating on real devices. In the same time, this layer
   exposes all functions required by timers library to work correctly.


Timers library API
------------------
Frontend API of library consist of following:

-> int timers_init(void)
/*
 * Performs basic initialisation of timers framework, must be called before
 * attempting to run any other function from API.
 * Params_in: N/A
 * Return value:  0 on success
 *               -1 when there are no HW timers available on platform
 */

-> int timer_set_period(int hd, uint32_t period)
/*
 * Allows to set new period for created timer entity. Can modify interval only
 * for previously stopped one-shot timer.
 * Params_in: hd - timer's handler returned by timer_create() function
 *            period - timer interval in ms
 * Return value:  0 on success
 *               -1 when
 *                  -> timer with provided hd wasn't created
 *                  -> timer is still running (not stopped with timer_stop)
 *                  -> timer isn't of type TM_ONE_SHOT
 */

-> int timer_stop(int hd)
/*
 * Allows to stop previously started timer entity.
 * Params_in: hd - timer's handler returned by timer_create() function
 * Return value:  0 on success
 *               -1 when timer wasn't started
 */

-> int timer_start(int hd)
/*
 * Allows to start previously created timer. It firstly program timer with
 * registered period and then start it.
 * Param_in: hd - timer's handler returned by timer_create() function
 * Return value:  0 on success
 *               -1 when timer wasn't created
 */

-> int timer_create(timer_kind_t type, uint32_t period, timer_callback_t cb)
/*
 * Allows to create timer entity with specified timer_type, period and callback
 * function, which will be executed during timers interrupts. This function
 * doesn't start timer, it's necessary to do this explicitly via call to
 * timer_start().
 * Params_in: type - one of timer entity type, TM_PERIODIC for timer which
 *                   should execute callback function periodically or
 *                   TM_ONE_SHOT for timers, which callback should be executed once
 *                   after registered period
 *            period - timers interval in ms
 *            cb - callback function which will be executed on timer's events
 * Return value: timer_handler - timer ID, which is used to identify specific
 *                               timer entity when using other functions from API
 */


Example of usage
----------------

#include <timers.h>

/* Interrupt service routine, executed on every timer event */
int example_isr(int id)
{
       printf("We got this!\n");
       return 0;
}

int timers(void)
{
	int rc;
	int timers_handler;

	/* Initialize timers framework */
	if (timers_init()) {
		printf("Error during timers initialization!\n")
		return -1;
	}

	/* Create periodic timer with period 1000ms */
	timer_handler = timer_create(TM_PERIODIC, 1000, example_isr);
	if (timer_handler < 0) {
		printf("No timers available!\n")
		return -1;
	}

	/* Start timer */
	timer_start(timer_handler);
}


Platform timers driver API
--------------------------
API exposed for _timers library_ consist of following:

-> int plat_timers_init(void)
/*
 * Performs configuration of all HW timers and returns number of available
 * timers on platform.
 * Params_in: N/A
 * Return value: timers_count - number of available HW timers on platform
 */

-> void plat_timer_set_period(int timer_id, uint64_t period)
/*
 * Set interval for timer with timer_id to specified number of ticks.
 * Params_in: timer_id - ID of HW timer common for timers framework
 *            period   - Number of timer's ticks to be programmed for next
 *                       interval
 * Return value: N/A
 */

-> uint64_t plat_timer_ms_to_ticks(int timer_id, uint32_t time)
/*
 * Method for transforming number of ms to specified timers' ticks count.
 * Params_in: timer_id - ID of HW timer common for timers framework
 *            time     - Number of miliseconds to be transformed
 * Return value: tick_count - number of timers' ticks corresponding to provided
 *                            time in ms
 *               -1 on failure
 */

-> void plat_timer_enable(int timer_id, int enable)
/*
 * Enable or disable HW timer with timer_id.
 * Params_in: timer_id - ID of HW timer common for timers framework
 *            enable   - Boolean value which indicate 1 - enable timer or
 *                       0 - disable timer
 * Return value: N/A
 */

-> int plat_timer_register_irq(int timer_id, hw_timer_isr_t isr)
/*
 * Allows to register interrupt service routine for timer with timer_id. It must
 * perform configuration of interrupts controller. In most cases, driver will
 * register internal service routine, not isr provided from timers library,
 * because it must perform proper HW_TIMER_ID to TIMER_ENTITY_ID mapping.
 * Params_in: timer_id - ID of HW timer common for timers framework
 *            isr      - Pointer to interrupt service routine which should be
 *                       invoked when interrupt from timer is signalled
 * Return value: 0  on success
 *               -1 on failure
 */


Porting guide
-------------
When adding support for new HW timer, one has to implement every method
described in paragraph "Platform timers driver API" and remember about following
issues:
 - TIMER_ID used by _timers library_ is int number starting from 0 and lineary
   added for next timers' entities and equal one should be used inside platform
   timers driver
 - Correct mapping between GIC_IRQ_ID and TIMER_ID is platform driver layer
   responsibility
 - Interrupt service routine registered by _timers library_ should be invoked on
   every ivent, and TIMER_ID should be fed as first argument

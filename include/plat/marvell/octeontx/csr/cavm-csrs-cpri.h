#ifndef __CAVM_CSRS_CPRI_H__
#define __CAVM_CSRS_CPRI_H__
/* This file is auto-generated. Do not edit */

/***********************license start***********************************
* Copyright (C) 2019 Marvell International Ltd.
* SPDX-License-Identifier: BSD-3-Clause
* https://spdx.org/licenses
***********************license end**************************************/


/**
 * @file
 *
 * Configuration and status register (CSR) address and type definitions for
 * OcteonTX CPRI.
 *
 * This file is auto generated. Do not edit.
 *
 */

/**
 * Register (NCB) cpri#_axi_control
 *
 * INTERNAL: CPRI AXI_CONTROL Register
 *
 * Contains config bits to configure AXI transactions
 */
union cavm_cprix_axi_control
{
    uint64_t u;
    struct cavm_cprix_axi_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t axi_gmii_bad_crc_drop_disable : 1;/**< [  1:  1](R/W) Disables dropping of UL GMII frames on Bad CRC */
        uint64_t axi_wr_wait_on_resp_en : 1; /**< [  0:  0](R/W) Enables AXI slave to wait for Write Response before making the next request */
#else /* Word 0 - Little Endian */
        uint64_t axi_wr_wait_on_resp_en : 1; /**< [  0:  0](R/W) Enables AXI slave to wait for Write Response before making the next request */
        uint64_t axi_gmii_bad_crc_drop_disable : 1;/**< [  1:  1](R/W) Disables dropping of UL GMII frames on Bad CRC */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_axi_control_s cn; */
};
typedef union cavm_cprix_axi_control cavm_cprix_axi_control_t;

static inline uint64_t CAVM_CPRIX_AXI_CONTROL(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_AXI_CONTROL(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x8640000001f0ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_AXI_CONTROL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_AXI_CONTROL(a) cavm_cprix_axi_control_t
#define bustype_CAVM_CPRIX_AXI_CONTROL(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_AXI_CONTROL(a) "CPRIX_AXI_CONTROL"
#define busnum_CAVM_CPRIX_AXI_CONTROL(a) (a)
#define arguments_CAVM_CPRIX_AXI_CONTROL(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_axi_int_psm_msg_w0
 *
 * INTERNAL: CPRI AXI Interrupt Message w0  Register
 *
 * JCA word 0 message to send on enabled AXI interrupt
 */
union cavm_cprix_axi_int_psm_msg_w0
{
    uint64_t u;
    struct cavm_cprix_axi_int_psm_msg_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t w0                    : 64; /**< [ 63:  0](R/W) Word 0 of JCA message. */
#else /* Word 0 - Little Endian */
        uint64_t w0                    : 64; /**< [ 63:  0](R/W) Word 0 of JCA message. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_axi_int_psm_msg_w0_s cn; */
};
typedef union cavm_cprix_axi_int_psm_msg_w0 cavm_cprix_axi_int_psm_msg_w0_t;

static inline uint64_t CAVM_CPRIX_AXI_INT_PSM_MSG_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_AXI_INT_PSM_MSG_W0(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x864000000180ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_AXI_INT_PSM_MSG_W0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_AXI_INT_PSM_MSG_W0(a) cavm_cprix_axi_int_psm_msg_w0_t
#define bustype_CAVM_CPRIX_AXI_INT_PSM_MSG_W0(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_AXI_INT_PSM_MSG_W0(a) "CPRIX_AXI_INT_PSM_MSG_W0"
#define busnum_CAVM_CPRIX_AXI_INT_PSM_MSG_W0(a) (a)
#define arguments_CAVM_CPRIX_AXI_INT_PSM_MSG_W0(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_axi_int_psm_msg_w1
 *
 * INTERNAL: CPRI AXI Interrupt Message w1 Register
 *
 * JCA word 1 message to send on enabled AXI interrupt
 */
union cavm_cprix_axi_int_psm_msg_w1
{
    uint64_t u;
    struct cavm_cprix_axi_int_psm_msg_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t w1                    : 64; /**< [ 63:  0](R/W) Word 1 of JCA message. */
#else /* Word 0 - Little Endian */
        uint64_t w1                    : 64; /**< [ 63:  0](R/W) Word 1 of JCA message. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_axi_int_psm_msg_w1_s cn; */
};
typedef union cavm_cprix_axi_int_psm_msg_w1 cavm_cprix_axi_int_psm_msg_w1_t;

static inline uint64_t CAVM_CPRIX_AXI_INT_PSM_MSG_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_AXI_INT_PSM_MSG_W1(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x864000000188ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_AXI_INT_PSM_MSG_W1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_AXI_INT_PSM_MSG_W1(a) cavm_cprix_axi_int_psm_msg_w1_t
#define bustype_CAVM_CPRIX_AXI_INT_PSM_MSG_W1(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_AXI_INT_PSM_MSG_W1(a) "CPRIX_AXI_INT_PSM_MSG_W1"
#define busnum_CAVM_CPRIX_AXI_INT_PSM_MSG_W1(a) (a)
#define arguments_CAVM_CPRIX_AXI_INT_PSM_MSG_W1(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_bp_test0
 *
 * INTERNAL: CPRI Back Pressure Test 0 Register
 *
 * This register is used to stress internal Hardware backpressure points for Testing
 */
union cavm_cprix_bp_test0
{
    uint64_t u;
    struct cavm_cprix_bp_test0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t enable                : 4;  /**< [ 63: 60](R/W) Enable test mode. For diagnostic use only.
                                                                 Internal:
                                                                 Once this bit is set, random backpressure is generate to
                                                                 and internal FIFO path to the allow more frequent backpressure.
                                                                 \<63\> = LDMP_IN_BUF_STALL.
                                                                 \<62\> = DESP_IN_STALL.
                                                                 \<61\> = GAIN_IN_STALL.
                                                                 \<60\> = CPRI_RDDMA_STALL. */
        uint64_t reserved_24_59        : 36;
        uint64_t bp_cfg                : 8;  /**< [ 23: 16](R/W) Enable backpressure. For diagnostic use only.
                                                                 Internal:
                                                                 There are 2 backpressure configuration bits per enable, with the two bits
                                                                 defined as 0x0=100% of the time, 0x1=75% of the time, 0x2=50% of the time,
                                                                 0x3=25% of the time.
                                                                   \<23:22\> = BP_CFG3.
                                                                   \<21:20\> = BP_CFG2.
                                                                   \<19:18\> = BP_CFG1.
                                                                   \<17:16\> = BP_CFG0. */
        uint64_t reserved_12_15        : 4;
        uint64_t lfsr_freq             : 12; /**< [ 11:  0](R/W) Test LFSR update frequency in coprocessor-clocks minus one. */
#else /* Word 0 - Little Endian */
        uint64_t lfsr_freq             : 12; /**< [ 11:  0](R/W) Test LFSR update frequency in coprocessor-clocks minus one. */
        uint64_t reserved_12_15        : 4;
        uint64_t bp_cfg                : 8;  /**< [ 23: 16](R/W) Enable backpressure. For diagnostic use only.
                                                                 Internal:
                                                                 There are 2 backpressure configuration bits per enable, with the two bits
                                                                 defined as 0x0=100% of the time, 0x1=75% of the time, 0x2=50% of the time,
                                                                 0x3=25% of the time.
                                                                   \<23:22\> = BP_CFG3.
                                                                   \<21:20\> = BP_CFG2.
                                                                   \<19:18\> = BP_CFG1.
                                                                   \<17:16\> = BP_CFG0. */
        uint64_t reserved_24_59        : 36;
        uint64_t enable                : 4;  /**< [ 63: 60](R/W) Enable test mode. For diagnostic use only.
                                                                 Internal:
                                                                 Once this bit is set, random backpressure is generate to
                                                                 and internal FIFO path to the allow more frequent backpressure.
                                                                 \<63\> = LDMP_IN_BUF_STALL.
                                                                 \<62\> = DESP_IN_STALL.
                                                                 \<61\> = GAIN_IN_STALL.
                                                                 \<60\> = CPRI_RDDMA_STALL. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_bp_test0_s cn; */
};
typedef union cavm_cprix_bp_test0 cavm_cprix_bp_test0_t;

static inline uint64_t CAVM_CPRIX_BP_TEST0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_BP_TEST0(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x864000000010ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_BP_TEST0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_BP_TEST0(a) cavm_cprix_bp_test0_t
#define bustype_CAVM_CPRIX_BP_TEST0(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_BP_TEST0(a) "CPRIX_BP_TEST0"
#define busnum_CAVM_CPRIX_BP_TEST0(a) (a)
#define arguments_CAVM_CPRIX_BP_TEST0(a) (a),-1,-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_axi_ctrl
 *
 * CPRI CONN4 IP AXI Control Register
 */
union cavm_cprix_cn4ipx_axi_ctrl
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_axi_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t stx_closereq_1        : 1;  /**< [  1:  1](R/W) Request closing of AXI clock bridge of CPRI link 1.
                                                                 Request is acknowledged by AXI_STATUS:STX_CLOSEACK_1.
                                                                 When closed, the AXI clock bridge does not accept any further accesses.
                                                                   0 = Normal Operation.
                                                                   1 = Close Bridge. */
        uint32_t stx_closereq_0        : 1;  /**< [  0:  0](R/W) Request closing of AXI clock bridge of CPRI link 0.
                                                                 Request is acknowledged by AXI_STATUS:STX_CLOSEACK_0.
                                                                 When closed, the AXI clock bridge does not accept any further accesses.
                                                                   0 = Normal operation.
                                                                   1 = Close bridge. */
#else /* Word 0 - Little Endian */
        uint32_t stx_closereq_0        : 1;  /**< [  0:  0](R/W) Request closing of AXI clock bridge of CPRI link 0.
                                                                 Request is acknowledged by AXI_STATUS:STX_CLOSEACK_0.
                                                                 When closed, the AXI clock bridge does not accept any further accesses.
                                                                   0 = Normal operation.
                                                                   1 = Close bridge. */
        uint32_t stx_closereq_1        : 1;  /**< [  1:  1](R/W) Request closing of AXI clock bridge of CPRI link 1.
                                                                 Request is acknowledged by AXI_STATUS:STX_CLOSEACK_1.
                                                                 When closed, the AXI clock bridge does not accept any further accesses.
                                                                   0 = Normal Operation.
                                                                   1 = Close Bridge. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_axi_ctrl_s cn; */
};
typedef union cavm_cprix_cn4ipx_axi_ctrl cavm_cprix_cn4ipx_axi_ctrl_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_AXI_CTRL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_AXI_CTRL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000800008ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_AXI_CTRL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_AXI_CTRL(a,b) cavm_cprix_cn4ipx_axi_ctrl_t
#define bustype_CAVM_CPRIX_CN4IPX_AXI_CTRL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_AXI_CTRL(a,b) "CPRIX_CN4IPX_AXI_CTRL"
#define busnum_CAVM_CPRIX_CN4IPX_AXI_CTRL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_AXI_CTRL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_axi_status
 *
 * CPRI CONN4 IP AXI STATUS Register
 */
union cavm_cprix_cn4ipx_axi_status
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_axi_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t stx_closeack_1        : 1;  /**< [  1:  1](RO/H) Response of close request. Request is acknowledged when state matches STX_CLOSEREQ_1. */
        uint32_t stx_closeack_0        : 1;  /**< [  0:  0](RO/H) Response of close request. Request is acknowledged when state matches STX_CLOSEREQ_0. */
#else /* Word 0 - Little Endian */
        uint32_t stx_closeack_0        : 1;  /**< [  0:  0](RO/H) Response of close request. Request is acknowledged when state matches STX_CLOSEREQ_0. */
        uint32_t stx_closeack_1        : 1;  /**< [  1:  1](RO/H) Response of close request. Request is acknowledged when state matches STX_CLOSEREQ_1. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_axi_status_s cn; */
};
typedef union cavm_cprix_cn4ipx_axi_status cavm_cprix_cn4ipx_axi_status_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_AXI_STATUS(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_AXI_STATUS(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080000cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_AXI_STATUS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_AXI_STATUS(a,b) cavm_cprix_cn4ipx_axi_status_t
#define bustype_CAVM_CPRIX_CN4IPX_AXI_STATUS(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_AXI_STATUS(a,b) "CPRIX_CN4IPX_AXI_STATUS"
#define busnum_CAVM_CPRIX_CN4IPX_AXI_STATUS(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_AXI_STATUS(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_bcn_fri_per
 *
 * CPRI CONN4 IP BCN Timer Frame Interrupt Period Register
 */
union cavm_cprix_cn4ipx_bcn_fri_per
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_bcn_fri_per_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t int_period            : 5;  /**< [  4:  0](R/W) Frame interrupt period:
                                                                   0 = No interrupt generated.
                                                                   1 = Interrupt is generated for every master frame.
                                                                   2 = Interrupt is generated for every 2nd master frame
                                                                   ...
                                                                   0x1F = Interrupt is generated for every 31st master frame */
#else /* Word 0 - Little Endian */
        uint32_t int_period            : 5;  /**< [  4:  0](R/W) Frame interrupt period:
                                                                   0 = No interrupt generated.
                                                                   1 = Interrupt is generated for every master frame.
                                                                   2 = Interrupt is generated for every 2nd master frame
                                                                   ...
                                                                   0x1F = Interrupt is generated for every 31st master frame */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_bcn_fri_per_s cn; */
};
typedef union cavm_cprix_cn4ipx_bcn_fri_per cavm_cprix_cn4ipx_bcn_fri_per_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_BCN_FRI_PER(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_BCN_FRI_PER(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f014ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_BCN_FRI_PER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_BCN_FRI_PER(a,b) cavm_cprix_cn4ipx_bcn_fri_per_t
#define bustype_CAVM_CPRIX_CN4IPX_BCN_FRI_PER(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_BCN_FRI_PER(a,b) "CPRIX_CN4IPX_BCN_FRI_PER"
#define busnum_CAVM_CPRIX_CN4IPX_BCN_FRI_PER(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_BCN_FRI_PER(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_bcn_modern
 *
 * CPRI CONN4 IP BCN Master BCN Slave Time Source Enable Register
 */
union cavm_cprix_cn4ipx_bcn_modern
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_bcn_modern_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_26_31        : 6;
        uint32_t resync                : 1;  /**< [ 25: 25](R/W/H) Resynchronize BCN Slave.
                                                                   0 = no resynchronization.
                                                                   1 = resynchronize. */
        uint32_t enable                : 1;  /**< [ 24: 24](R/W) Enable local BCN Slave as source of BCN time.
                                                                   0 = disable, use legacy source.
                                                                   1 = enable, use modern source. */
        uint32_t reserved_16_23        : 8;
        uint32_t delta                 : 16; /**< [ 15:  0](R/W) Delta value for adjusting BCN Slave time. Value is signed. Unit is UTU. */
#else /* Word 0 - Little Endian */
        uint32_t delta                 : 16; /**< [ 15:  0](R/W) Delta value for adjusting BCN Slave time. Value is signed. Unit is UTU. */
        uint32_t reserved_16_23        : 8;
        uint32_t enable                : 1;  /**< [ 24: 24](R/W) Enable local BCN Slave as source of BCN time.
                                                                   0 = disable, use legacy source.
                                                                   1 = enable, use modern source. */
        uint32_t resync                : 1;  /**< [ 25: 25](R/W/H) Resynchronize BCN Slave.
                                                                   0 = no resynchronization.
                                                                   1 = resynchronize. */
        uint32_t reserved_26_31        : 6;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_bcn_modern_s cn; */
};
typedef union cavm_cprix_cn4ipx_bcn_modern cavm_cprix_cn4ipx_bcn_modern_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_BCN_MODERN(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_BCN_MODERN(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f00cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_BCN_MODERN", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_BCN_MODERN(a,b) cavm_cprix_cn4ipx_bcn_modern_t
#define bustype_CAVM_CPRIX_CN4IPX_BCN_MODERN(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_BCN_MODERN(a,b) "CPRIX_CN4IPX_BCN_MODERN"
#define busnum_CAVM_CPRIX_CN4IPX_BCN_MODERN(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_BCN_MODERN(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_bcn_n1_0
 *
 * CPRI CONN4 IP BCN N1 Frame Number control 0 Register
 */
union cavm_cprix_cn4ipx_bcn_n1_0
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_bcn_n1_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_12_31        : 20;
        uint32_t bcn_n1_0              : 12; /**< [ 11:  0](R/W) BCN N1 LSB bits 11:0. Can be set when free running mode is selected. In
                                                                 synchronized mode bits don't have effect. */
#else /* Word 0 - Little Endian */
        uint32_t bcn_n1_0              : 12; /**< [ 11:  0](R/W) BCN N1 LSB bits 11:0. Can be set when free running mode is selected. In
                                                                 synchronized mode bits don't have effect. */
        uint32_t reserved_12_31        : 20;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_bcn_n1_0_s cn; */
};
typedef union cavm_cprix_cn4ipx_bcn_n1_0 cavm_cprix_cn4ipx_bcn_n1_0_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_BCN_N1_0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_BCN_N1_0(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f01cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_BCN_N1_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_BCN_N1_0(a,b) cavm_cprix_cn4ipx_bcn_n1_0_t
#define bustype_CAVM_CPRIX_CN4IPX_BCN_N1_0(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_BCN_N1_0(a,b) "CPRIX_CN4IPX_BCN_N1_0"
#define busnum_CAVM_CPRIX_CN4IPX_BCN_N1_0(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_BCN_N1_0(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_bcn_n1_0_r
 *
 * CPRI CONN4 IP BCN Timer N1 Frame Number 0 Register
 */
union cavm_cprix_cn4ipx_bcn_n1_0_r
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_bcn_n1_0_r_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_12_31        : 20;
        uint32_t bcn_n1_0_r            : 12; /**< [ 11:  0](RO/H) BCN N1 LSB bits 11:0. */
#else /* Word 0 - Little Endian */
        uint32_t bcn_n1_0_r            : 12; /**< [ 11:  0](RO/H) BCN N1 LSB bits 11:0. */
        uint32_t reserved_12_31        : 20;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_bcn_n1_0_r_s cn; */
};
typedef union cavm_cprix_cn4ipx_bcn_n1_0_r cavm_cprix_cn4ipx_bcn_n1_0_r_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_BCN_N1_0_R(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_BCN_N1_0_R(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f028ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_BCN_N1_0_R", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_BCN_N1_0_R(a,b) cavm_cprix_cn4ipx_bcn_n1_0_r_t
#define bustype_CAVM_CPRIX_CN4IPX_BCN_N1_0_R(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_BCN_N1_0_R(a,b) "CPRIX_CN4IPX_BCN_N1_0_R"
#define busnum_CAVM_CPRIX_CN4IPX_BCN_N1_0_R(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_BCN_N1_0_R(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_bcn_n1_1
 *
 * CPRI CONN4 IP BCN N1 Frame Number control 1 Register
 */
union cavm_cprix_cn4ipx_bcn_n1_1
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_bcn_n1_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t bcn_n1_1              : 28; /**< [ 27:  0](R/W) BCN N1 MSB bits 39:12. */
#else /* Word 0 - Little Endian */
        uint32_t bcn_n1_1              : 28; /**< [ 27:  0](R/W) BCN N1 MSB bits 39:12. */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_bcn_n1_1_s cn; */
};
typedef union cavm_cprix_cn4ipx_bcn_n1_1 cavm_cprix_cn4ipx_bcn_n1_1_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_BCN_N1_1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_BCN_N1_1(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f020ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_BCN_N1_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_BCN_N1_1(a,b) cavm_cprix_cn4ipx_bcn_n1_1_t
#define bustype_CAVM_CPRIX_CN4IPX_BCN_N1_1(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_BCN_N1_1(a,b) "CPRIX_CN4IPX_BCN_N1_1"
#define busnum_CAVM_CPRIX_CN4IPX_BCN_N1_1(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_BCN_N1_1(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_bcn_n1_1_r
 *
 * CPRI CONN4 IP BCN Timer N1 Frame Number 1 Register
 */
union cavm_cprix_cn4ipx_bcn_n1_1_r
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_bcn_n1_1_r_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t bcn_n1_1_r            : 28; /**< [ 27:  0](RO/H) BCN N1 MSB bits 39:12. */
#else /* Word 0 - Little Endian */
        uint32_t bcn_n1_1_r            : 28; /**< [ 27:  0](RO/H) BCN N1 MSB bits 39:12. */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_bcn_n1_1_r_s cn; */
};
typedef union cavm_cprix_cn4ipx_bcn_n1_1_r cavm_cprix_cn4ipx_bcn_n1_1_r_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_BCN_N1_1_R(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_BCN_N1_1_R(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f02cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_BCN_N1_1_R", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_BCN_N1_1_R(a,b) cavm_cprix_cn4ipx_bcn_n1_1_r_t
#define bustype_CAVM_CPRIX_CN4IPX_BCN_N1_1_R(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_BCN_N1_1_R(a,b) "CPRIX_CN4IPX_BCN_N1_1_R"
#define busnum_CAVM_CPRIX_CN4IPX_BCN_N1_1_R(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_BCN_N1_1_R(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_bcn_n1_length
 *
 * CPRI CONN4 IP Received System Frame Number Length Register
 */
union cavm_cprix_cn4ipx_bcn_n1_length
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_bcn_n1_length_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t fcb_n1_length         : 1;  /**< [  1:  1](R/W) Length of System Frame Number for received FCB messages.
                                                                   0 = 40 bits.
                                                                   1 = 12 bits. */
        uint32_t rp1_n1_length         : 1;  /**< [  0:  0](R/W) Length of System Frame Number for received RP1 burst.
                                                                   0 = 40 bits.
                                                                   1 = 12 bits. */
#else /* Word 0 - Little Endian */
        uint32_t rp1_n1_length         : 1;  /**< [  0:  0](R/W) Length of System Frame Number for received RP1 burst.
                                                                   0 = 40 bits.
                                                                   1 = 12 bits. */
        uint32_t fcb_n1_length         : 1;  /**< [  1:  1](R/W) Length of System Frame Number for received FCB messages.
                                                                   0 = 40 bits.
                                                                   1 = 12 bits. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_bcn_n1_length_s cn; */
};
typedef union cavm_cprix_cn4ipx_bcn_n1_length cavm_cprix_cn4ipx_bcn_n1_length_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_BCN_N1_LENGTH(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_BCN_N1_LENGTH(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f018ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_BCN_N1_LENGTH", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_BCN_N1_LENGTH(a,b) cavm_cprix_cn4ipx_bcn_n1_length_t
#define bustype_CAVM_CPRIX_CN4IPX_BCN_N1_LENGTH(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_BCN_N1_LENGTH(a,b) "CPRIX_CN4IPX_BCN_N1_LENGTH"
#define busnum_CAVM_CPRIX_CN4IPX_BCN_N1_LENGTH(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_BCN_N1_LENGTH(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_bcn_n2_r
 *
 * CPRI CONN4 IP BCN Timer N2 Frame Number Register
 */
union cavm_cprix_cn4ipx_bcn_n2_r
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_bcn_n2_r_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t bcn_n2_r              : 24; /**< [ 23:  0](RO/H) BCN timer N2 value. */
#else /* Word 0 - Little Endian */
        uint32_t bcn_n2_r              : 24; /**< [ 23:  0](RO/H) BCN timer N2 value. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_bcn_n2_r_s cn; */
};
typedef union cavm_cprix_cn4ipx_bcn_n2_r cavm_cprix_cn4ipx_bcn_n2_r_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_BCN_N2_R(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_BCN_N2_R(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f024ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_BCN_N2_R", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_BCN_N2_R(a,b) cavm_cprix_cn4ipx_bcn_n2_r_t
#define bustype_CAVM_CPRIX_CN4IPX_BCN_N2_R(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_BCN_N2_R(a,b) "CPRIX_CN4IPX_BCN_N2_R"
#define busnum_CAVM_CPRIX_CN4IPX_BCN_N2_R(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_BCN_N2_R(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_bcn_sync
 *
 * CPRI CONN4 IP BCN Timer Synchronization Register
 */
union cavm_cprix_cn4ipx_bcn_sync
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_bcn_sync_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t resync                : 1;  /**< [  1:  1](R/W/H) Resynchronize to next sync event.
                                                                 In free running mode the sync is immediate.
                                                                   0 = No action.
                                                                   1 = Resynchronize. */
        uint32_t status                : 1;  /**< [  0:  0](RO/H) Status of the BCN timer:
                                                                   0 = Not synchronized.
                                                                   1 = Synchronized. */
#else /* Word 0 - Little Endian */
        uint32_t status                : 1;  /**< [  0:  0](RO/H) Status of the BCN timer:
                                                                   0 = Not synchronized.
                                                                   1 = Synchronized. */
        uint32_t resync                : 1;  /**< [  1:  1](R/W/H) Resynchronize to next sync event.
                                                                 In free running mode the sync is immediate.
                                                                   0 = No action.
                                                                   1 = Resynchronize. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_bcn_sync_s cn; */
};
typedef union cavm_cprix_cn4ipx_bcn_sync cavm_cprix_cn4ipx_bcn_sync_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_BCN_SYNC(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_BCN_SYNC(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f010ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_BCN_SYNC", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_BCN_SYNC(a,b) cavm_cprix_cn4ipx_bcn_sync_t
#define bustype_CAVM_CPRIX_CN4IPX_BCN_SYNC(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_BCN_SYNC(a,b) "CPRIX_CN4IPX_BCN_SYNC"
#define busnum_CAVM_CPRIX_CN4IPX_BCN_SYNC(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_BCN_SYNC(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_bufint_src
 *
 * CPRI CONN4 IP Stream Routing Interrupt Source Register
 */
union cavm_cprix_cn4ipx_bufint_src
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_bufint_src_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t stream_id             : 8;  /**< [  7:  0](RO/H) Register returns stream id which has active stream routing buffer interrupt.
                                                                 After clearing interrupt another stream which has active interrupt is returned. */
#else /* Word 0 - Little Endian */
        uint32_t stream_id             : 8;  /**< [  7:  0](RO/H) Register returns stream id which has active stream routing buffer interrupt.
                                                                 After clearing interrupt another stream which has active interrupt is returned. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_bufint_src_s cn; */
};
typedef union cavm_cprix_cn4ipx_bufint_src cavm_cprix_cn4ipx_bufint_src_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_BUFINT_SRC(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_BUFINT_SRC(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000812080ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_BUFINT_SRC", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_BUFINT_SRC(a,b) cavm_cprix_cn4ipx_bufint_src_t
#define bustype_CAVM_CPRIX_CN4IPX_BUFINT_SRC(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_BUFINT_SRC(a,b) "CPRIX_CN4IPX_BUFINT_SRC"
#define busnum_CAVM_CPRIX_CN4IPX_BUFINT_SRC(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_BUFINT_SRC(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_connection_id
 *
 * CPRI CONN4 IP CONNECTION ID Register
 */
union cavm_cprix_cn4ipx_connection_id
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_connection_id_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t conn_id               : 32; /**< [ 31:  0](RO/H) ID:       Identification value. Actual content is pointed by internally
                                                                 maintained ID_POINTER. Reset value of ID_POINTER is zero. ID_POINTER is
                                                                 incremented by one following each read of this register. ID_POINTER wraps back
                                                                 to zero after its maximum value. ID_POINTER is set to the value written to this
                                                                 register. Default is  0x55555555.

                                                                 SYNCH0:   Value when internal ID_POINTER is equal to 0.  Synchronization word 0.
                                                                 Default is 0x55555555.

                                                                 SYNCH1:   Value when internal ID_POINTER is equal to 1.  Synchronization word 1.
                                                                 Default is  0xAAAAAAAA.
                                                                 COMPCODE: Value when internal ID_POINTER is equal to 2.  Component code.   Default is  0x0002F300.

                                                                 VERSION:  Value when internal ID_POINTER is equal to 3.  Module hardware version
                                                                 in MAJOR.MINOR format. MAJOR is in the upper half of the module register
                                                                 interface word.  MINOR is in the lower half of the word.   Default is  TBD.
                                                                 BUILD:    Value when internal ID_POINTER is equal to 4.  Module build number
                                                                 (SVN revision number). Default is    TBD.
                                                                 INSTANCE: Value when internal ID_POINTER is equal to 5. The value bounds to the
                                                                 corresponding generic feature. Defines module instance number.   Default is
                                                                 0x00000000.
                                                                 ADDRSIZE: Value when internal ID_POINTER is equal to 6.  The value bounds to the
                                                                 corresponding generic feature. (ADDRSIZE defines the slave port address width.)
                                                                 Default is 0x00000012.
                                                                 DATASIZE: Value when internal ID_POINTER is equal to 7.  The value bounds to the
                                                                 corresponding generic feature. (DATASIZE defines the slave port address width.)
                                                                 Default is 0x00000020. */
#else /* Word 0 - Little Endian */
        uint32_t conn_id               : 32; /**< [ 31:  0](RO/H) ID:       Identification value. Actual content is pointed by internally
                                                                 maintained ID_POINTER. Reset value of ID_POINTER is zero. ID_POINTER is
                                                                 incremented by one following each read of this register. ID_POINTER wraps back
                                                                 to zero after its maximum value. ID_POINTER is set to the value written to this
                                                                 register. Default is  0x55555555.

                                                                 SYNCH0:   Value when internal ID_POINTER is equal to 0.  Synchronization word 0.
                                                                 Default is 0x55555555.

                                                                 SYNCH1:   Value when internal ID_POINTER is equal to 1.  Synchronization word 1.
                                                                 Default is  0xAAAAAAAA.
                                                                 COMPCODE: Value when internal ID_POINTER is equal to 2.  Component code.   Default is  0x0002F300.

                                                                 VERSION:  Value when internal ID_POINTER is equal to 3.  Module hardware version
                                                                 in MAJOR.MINOR format. MAJOR is in the upper half of the module register
                                                                 interface word.  MINOR is in the lower half of the word.   Default is  TBD.
                                                                 BUILD:    Value when internal ID_POINTER is equal to 4.  Module build number
                                                                 (SVN revision number). Default is    TBD.
                                                                 INSTANCE: Value when internal ID_POINTER is equal to 5. The value bounds to the
                                                                 corresponding generic feature. Defines module instance number.   Default is
                                                                 0x00000000.
                                                                 ADDRSIZE: Value when internal ID_POINTER is equal to 6.  The value bounds to the
                                                                 corresponding generic feature. (ADDRSIZE defines the slave port address width.)
                                                                 Default is 0x00000012.
                                                                 DATASIZE: Value when internal ID_POINTER is equal to 7.  The value bounds to the
                                                                 corresponding generic feature. (DATASIZE defines the slave port address width.)
                                                                 Default is 0x00000020. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_connection_id_s cn; */
};
typedef union cavm_cprix_cn4ipx_connection_id cavm_cprix_cn4ipx_connection_id_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CONNECTION_ID(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CONNECTION_ID(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000800000ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CONNECTION_ID", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CONNECTION_ID(a,b) cavm_cprix_cn4ipx_connection_id_t
#define bustype_CAVM_CPRIX_CN4IPX_CONNECTION_ID(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CONNECTION_ID(a,b) "CPRIX_CN4IPX_CONNECTION_ID"
#define busnum_CAVM_CPRIX_CN4IPX_CONNECTION_ID(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CONNECTION_ID(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_crx_ard_ln#
 *
 * CPRI CONN4 IP CPRI RX ARD Support Configuration Register
 */
union cavm_cprix_cn4ipx_crx_ard_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crx_ard_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t enable                : 1;  /**< [  0:  0](R/W) Enable of ARD CPRI support mode. When enabled, each special ARD IDLE sample
                                                                 received by CRX AxC is replaced with IQ sample with value (0, 0).
                                                                   0 = disabled.
                                                                   1 = enabled. */
#else /* Word 0 - Little Endian */
        uint32_t enable                : 1;  /**< [  0:  0](R/W) Enable of ARD CPRI support mode. When enabled, each special ARD IDLE sample
                                                                 received by CRX AxC is replaced with IQ sample with value (0, 0).
                                                                   0 = disabled.
                                                                   1 = enabled. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crx_ard_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crx_ard_lnx cavm_cprix_cn4ipx_crx_ard_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_ARD_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_ARD_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000820030ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRX_ARD_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRX_ARD_LNX(a,b,c) cavm_cprix_cn4ipx_crx_ard_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRX_ARD_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRX_ARD_LNX(a,b,c) "CPRIX_CN4IPX_CRX_ARD_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRX_ARD_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRX_ARD_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_crx_axc#_airfrm_ln#
 *
 * CPRI CONN4 IP CPRI RX AXC Air Interface Frame Synchronization Configuration Register
 */
union cavm_cprix_cn4ipx_crx_axcx_airfrm_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crx_axcx_airfrm_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t airframe_x            : 8;  /**< [ 15:  8](R/W) Basic frame number X at start of air interface frame.
                                                                     0 .. 0xFF = valid. */
        uint32_t airframe_z            : 8;  /**< [  7:  0](R/W) Hyperframe number Z at start of air interface frame.
                                                                        0 .. 0x95 = valid.
                                                                     0x96 .. 0xFF = not valid. */
#else /* Word 0 - Little Endian */
        uint32_t airframe_z            : 8;  /**< [  7:  0](R/W) Hyperframe number Z at start of air interface frame.
                                                                        0 .. 0x95 = valid.
                                                                     0x96 .. 0xFF = not valid. */
        uint32_t airframe_x            : 8;  /**< [ 15:  8](R/W) Basic frame number X at start of air interface frame.
                                                                     0 .. 0xFF = valid. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crx_axcx_airfrm_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crx_axcx_airfrm_lnx cavm_cprix_cn4ipx_crx_axcx_airfrm_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_AXCX_AIRFRM_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_AXCX_AIRFRM_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=63) && (d<=1)))
        return 0x864000820404ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10ll * ((c) & 0x3f) + 0x10000ll * ((d) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRX_AXCX_AIRFRM_LNX", 4, a, b, c, d, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRX_AXCX_AIRFRM_LNX(a,b,c,d) cavm_cprix_cn4ipx_crx_axcx_airfrm_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRX_AXCX_AIRFRM_LNX(a,b,c,d) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRX_AXCX_AIRFRM_LNX(a,b,c,d) "CPRIX_CN4IPX_CRX_AXCX_AIRFRM_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRX_AXCX_AIRFRM_LNX(a,b,c,d) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRX_AXCX_AIRFRM_LNX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) cpri#_cn4ip#_crx_axc#_contnr_ln#
 *
 * CPRI CONN4 IP CPRI RX AXC Ownership Configuration Register
 */
union cavm_cprix_cn4ipx_crx_axcx_contnr_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crx_axcx_contnr_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_29_31        : 3;
        uint32_t enable_f              : 1;  /**< [ 28: 28](R/W) Enable free format configuration of IQ sample via CONTAINER_F field.
                                                                   0 = disabled, use CONTAINER_M.
                                                                   1 = enabled, use CONTAINER_F. */
        uint32_t container_f           : 4;  /**< [ 27: 24](R/W) Free formatting of an IQ sample. Indicates how a CPRI sample is converted to
                                                                 RP3. Least significant bits redundant in CPRI are enclosed in parenthesis. Those
                                                                 bits are removed in RP3 to CPRI conversion and replaced with a bit having a
                                                                 value of zero in CPRI to RP3 conversion.
                                                                      0x6 = 7+(1)+7+(1)+7+(1)+7+(1).
                                                                      0x7 = 8 + 8 + 8 + 8.
                                                                      0x8 = 9 + (7) + 9 + (7).
                                                                      0x9 = not supported.
                                                                      0xA = not supported.
                                                                      0xB = 12 + (4) + 12 + (4).
                                                                      0xC = not supported.
                                                                      0xD = not supported.
                                                                      0xE = 15 + (1) + 15 + (1).
                                                                      0xF = 16 + 16.
                                                                    others = not used.
                                                                 Note: Content of this field is used only if value of ENABLE_F field is one. */
        uint32_t reserved_23           : 1;
        uint32_t container_n           : 3;  /**< [ 22: 20](R/W) Number IQ samples in one AxC container. For example one 15 bit IQ sample
                                                                 requires a total space of 30 bits.
                                                                    0x0 = one 15/16 bit IQ sample or two 7/8 bit IQ samples.
                                                                              (WCDMA, LTE 1.4 MHz, LTE 3 MHz).
                                                                    0x1 = two 15/16 bit IQ samples or four 7/8 bit IQ samples
                                                                              (LTE 5 MHz).
                                                                    0x2 = three 15/16 bit IQ samples or five 7/8 bit IQ samples.
                                                                              (LTE 7.5 MHz).
                                                                    0x3 = four 15/16 bit IQ samples or eight 7/8 bit IQ samples.
                                                                              (LTE 10 MHz).
                                                                    0x4 = reserved.
                                                                    0x5 = six 15/16 bit IQ samples or twelve 7/8 bit IQ samples.
                                                                              (LTE 15 MHz).
                                                                    0x6 = reserved.
                                                                    0x7 = eight 15/16 bit IQ samples or sixteen 7/8 bit IQ samples.
                                                                              (LTE 20 MHz). */
        uint32_t reserved_18_19        : 2;
        uint32_t container_m           : 2;  /**< [ 17: 16](R/W) Formatting of an IQ sample. Indicates how an RP3 sample data word of 32 bits is
                                                                 converted to CPRI. Least significant bits redundant in CPRI are enclosed in
                                                                 parenthesis. Those bits are replaced with a bit having a value of zero in CPRI
                                                                 to RP3 conversion.
                                                                   0 = 7 + (1) + 7 + (1) + 7 + (1) + 7 + (1).
                                                                   1 = 15 + (1) + 15 + (1).
                                                                   2 = 8 + 8 + 8 + 8.
                                                                   3 = 16 + 16.

                                                                 Total length of a 32-bit RP3 sample word in a CPRI AxC container including bit stuffing.
                                                                   0 = 28 bits.
                                                                   1 = 30 bits.
                                                                   2 = 32 bits.
                                                                   3 = 32 bits. */
        uint32_t reserved_11_15        : 5;
        uint32_t container_b2          : 6;  /**< [ 10:  5](R/W) Basic frame bit coordinate B at start of AxC container divided by 2.
                                                                       0 ..  0x7 = valid for all rates.
                                                                     0x8 ..  0xF = valid for rates \>= 2457.6 Mbps.
                                                                    0x10 .. 0x1F = valid for rates \>= 4915.2 Mbps.
                                                                    0x20 .. 0x27 = valid for rate \>= 6144.0 Mbps.
                                                                    0x28 .. 0x3F = valid for rate = 9830.4 Mbps. */
        uint32_t reserved_4            : 1;
        uint32_t container_w           : 4;  /**< [  3:  0](R/W) Basic frame word coordinate W at start of AxC container.
                                                                           0  = not valid.
                                                                     1 .. 0xF = valid. */
#else /* Word 0 - Little Endian */
        uint32_t container_w           : 4;  /**< [  3:  0](R/W) Basic frame word coordinate W at start of AxC container.
                                                                           0  = not valid.
                                                                     1 .. 0xF = valid. */
        uint32_t reserved_4            : 1;
        uint32_t container_b2          : 6;  /**< [ 10:  5](R/W) Basic frame bit coordinate B at start of AxC container divided by 2.
                                                                       0 ..  0x7 = valid for all rates.
                                                                     0x8 ..  0xF = valid for rates \>= 2457.6 Mbps.
                                                                    0x10 .. 0x1F = valid for rates \>= 4915.2 Mbps.
                                                                    0x20 .. 0x27 = valid for rate \>= 6144.0 Mbps.
                                                                    0x28 .. 0x3F = valid for rate = 9830.4 Mbps. */
        uint32_t reserved_11_15        : 5;
        uint32_t container_m           : 2;  /**< [ 17: 16](R/W) Formatting of an IQ sample. Indicates how an RP3 sample data word of 32 bits is
                                                                 converted to CPRI. Least significant bits redundant in CPRI are enclosed in
                                                                 parenthesis. Those bits are replaced with a bit having a value of zero in CPRI
                                                                 to RP3 conversion.
                                                                   0 = 7 + (1) + 7 + (1) + 7 + (1) + 7 + (1).
                                                                   1 = 15 + (1) + 15 + (1).
                                                                   2 = 8 + 8 + 8 + 8.
                                                                   3 = 16 + 16.

                                                                 Total length of a 32-bit RP3 sample word in a CPRI AxC container including bit stuffing.
                                                                   0 = 28 bits.
                                                                   1 = 30 bits.
                                                                   2 = 32 bits.
                                                                   3 = 32 bits. */
        uint32_t reserved_18_19        : 2;
        uint32_t container_n           : 3;  /**< [ 22: 20](R/W) Number IQ samples in one AxC container. For example one 15 bit IQ sample
                                                                 requires a total space of 30 bits.
                                                                    0x0 = one 15/16 bit IQ sample or two 7/8 bit IQ samples.
                                                                              (WCDMA, LTE 1.4 MHz, LTE 3 MHz).
                                                                    0x1 = two 15/16 bit IQ samples or four 7/8 bit IQ samples
                                                                              (LTE 5 MHz).
                                                                    0x2 = three 15/16 bit IQ samples or five 7/8 bit IQ samples.
                                                                              (LTE 7.5 MHz).
                                                                    0x3 = four 15/16 bit IQ samples or eight 7/8 bit IQ samples.
                                                                              (LTE 10 MHz).
                                                                    0x4 = reserved.
                                                                    0x5 = six 15/16 bit IQ samples or twelve 7/8 bit IQ samples.
                                                                              (LTE 15 MHz).
                                                                    0x6 = reserved.
                                                                    0x7 = eight 15/16 bit IQ samples or sixteen 7/8 bit IQ samples.
                                                                              (LTE 20 MHz). */
        uint32_t reserved_23           : 1;
        uint32_t container_f           : 4;  /**< [ 27: 24](R/W) Free formatting of an IQ sample. Indicates how a CPRI sample is converted to
                                                                 RP3. Least significant bits redundant in CPRI are enclosed in parenthesis. Those
                                                                 bits are removed in RP3 to CPRI conversion and replaced with a bit having a
                                                                 value of zero in CPRI to RP3 conversion.
                                                                      0x6 = 7+(1)+7+(1)+7+(1)+7+(1).
                                                                      0x7 = 8 + 8 + 8 + 8.
                                                                      0x8 = 9 + (7) + 9 + (7).
                                                                      0x9 = not supported.
                                                                      0xA = not supported.
                                                                      0xB = 12 + (4) + 12 + (4).
                                                                      0xC = not supported.
                                                                      0xD = not supported.
                                                                      0xE = 15 + (1) + 15 + (1).
                                                                      0xF = 16 + 16.
                                                                    others = not used.
                                                                 Note: Content of this field is used only if value of ENABLE_F field is one. */
        uint32_t enable_f              : 1;  /**< [ 28: 28](R/W) Enable free format configuration of IQ sample via CONTAINER_F field.
                                                                   0 = disabled, use CONTAINER_M.
                                                                   1 = enabled, use CONTAINER_F. */
        uint32_t reserved_29_31        : 3;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crx_axcx_contnr_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crx_axcx_contnr_lnx cavm_cprix_cn4ipx_crx_axcx_contnr_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_AXCX_CONTNR_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_AXCX_CONTNR_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=63) && (d<=1)))
        return 0x86400082040cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10ll * ((c) & 0x3f) + 0x10000ll * ((d) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRX_AXCX_CONTNR_LNX", 4, a, b, c, d, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRX_AXCX_CONTNR_LNX(a,b,c,d) cavm_cprix_cn4ipx_crx_axcx_contnr_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRX_AXCX_CONTNR_LNX(a,b,c,d) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRX_AXCX_CONTNR_LNX(a,b,c,d) "CPRIX_CN4IPX_CRX_AXCX_CONTNR_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRX_AXCX_CONTNR_LNX(a,b,c,d) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRX_AXCX_CONTNR_LNX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) cpri#_cn4ip#_crx_axc#_ctrl_ln#
 *
 * CPRI CONN4 IP CPRI RX Antenna Carrier Control Register
 */
union cavm_cprix_cn4ipx_crx_axcx_ctrl_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crx_axcx_ctrl_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t crx_axc_addr          : 13; /**< [ 31: 19](R/W) RP3 message address field for AxC.
                                                                   0 .. 0x1FFE = valid.
                                                                        0x1FFF = invalid. */
        uint32_t crx_axc_ts            : 6;  /**< [ 18: 13](R/W) RP3 message timestamp start value for AxC.
                                                                 Timestamp start value should always be configured as zero. */
        uint32_t crx_axc_type          : 5;  /**< [ 12:  8](R/W) RP3 message type field for AxC. */
        uint32_t reserved_7            : 1;
        uint32_t secondary             : 1;  /**< [  6:  6](R/W) Stream Router interface selection when hardware allocation is overridden.
                                                                   0 = primary.
                                                                   1 = secondary.

                                                                 Register field SECONDARY of the current combination of enabled carriers in CRX
                                                                 should be set so, that no more than half of the AxC message bandwidth towards
                                                                 Stream Router is allocated to the secondary interface. Consumed message
                                                                 bandwidth based on CONTAINER_N is as follows:
                                                                               0 =\> 1 msg per four Basic Frames.
                                                                               1 =\> 2 msg per four Basic Frames.
                                                                            2, 3 =\> 4 msg per four Basic Frames.
                                                                      4, 5, 6, 7 =\> 8 msg per four Basic Frames. */
        uint32_t override              : 1;  /**< [  5:  5](R/W) Override automatic Stream Router interface allocation.
                                                                   0 = no override.
                                                                   1 = override. */
        uint32_t interface_s           : 1;  /**< [  4:  4](RO/H) Indicator of the Stream Router interface. Interface is allocated automatically
                                                                 by hardware. The value of this field is informational only.
                                                                   0 = Primary interface.
                                                                   1 = Secondary interface.

                                                                 Note: If CONTAINER_N of any AxC is modified while that AxC is enabled, non-
                                                                 overridden interface allocation of any AxC may fail until CRX has been disabled
                                                                 by writing zero to CRX_CTRL:CRX_EN. */
        uint32_t decompress            : 1;  /**< [  3:  3](R/W) Decompression enable. When enabled, IQ samples are decompressed by CRX Law function.
                                                                   0 = disabled.
                                                                   1 = enabled. */
        uint32_t air_start_sample      : 1;  /**< [  2:  2](R/W) Store the first 16-bit sample after start of airframe to CRX_TEST_STATUS.
                                                                 This bit should be active for only one AxC at a time. If sample storing is
                                                                 enabled for multiple AxC, the sample stored in CRX_TEST_STATUS will be
                                                                 overwritten always when there is start of air interface for any of the AxC
                                                                 having AIR_START_SAMPLE active. */
        uint32_t mode                  : 1;  /**< [  1:  1](R/W) Operation mode of AxC. In normal mode the AxC payload data is forwarded to
                                                                 antenna carrier RAM. In test mode, test pattern checking is done and no data is
                                                                 written to antenna carrier RAM.
                                                                   0 = normal mode.
                                                                   1 = test mode.
                                                                 Antenna carrier must be enabled also for test mode operation. */
        uint32_t enable                : 1;  /**< [  0:  0](R/W) AxC  enable.
                                                                   0 = antenna carrier disabled.
                                                                   1 = antenna carrier enabled.
                                                                 Please note that value of the other fields of this register must not be changed
                                                                 when ENABLE is asserted. */
#else /* Word 0 - Little Endian */
        uint32_t enable                : 1;  /**< [  0:  0](R/W) AxC  enable.
                                                                   0 = antenna carrier disabled.
                                                                   1 = antenna carrier enabled.
                                                                 Please note that value of the other fields of this register must not be changed
                                                                 when ENABLE is asserted. */
        uint32_t mode                  : 1;  /**< [  1:  1](R/W) Operation mode of AxC. In normal mode the AxC payload data is forwarded to
                                                                 antenna carrier RAM. In test mode, test pattern checking is done and no data is
                                                                 written to antenna carrier RAM.
                                                                   0 = normal mode.
                                                                   1 = test mode.
                                                                 Antenna carrier must be enabled also for test mode operation. */
        uint32_t air_start_sample      : 1;  /**< [  2:  2](R/W) Store the first 16-bit sample after start of airframe to CRX_TEST_STATUS.
                                                                 This bit should be active for only one AxC at a time. If sample storing is
                                                                 enabled for multiple AxC, the sample stored in CRX_TEST_STATUS will be
                                                                 overwritten always when there is start of air interface for any of the AxC
                                                                 having AIR_START_SAMPLE active. */
        uint32_t decompress            : 1;  /**< [  3:  3](R/W) Decompression enable. When enabled, IQ samples are decompressed by CRX Law function.
                                                                   0 = disabled.
                                                                   1 = enabled. */
        uint32_t interface_s           : 1;  /**< [  4:  4](RO/H) Indicator of the Stream Router interface. Interface is allocated automatically
                                                                 by hardware. The value of this field is informational only.
                                                                   0 = Primary interface.
                                                                   1 = Secondary interface.

                                                                 Note: If CONTAINER_N of any AxC is modified while that AxC is enabled, non-
                                                                 overridden interface allocation of any AxC may fail until CRX has been disabled
                                                                 by writing zero to CRX_CTRL:CRX_EN. */
        uint32_t override              : 1;  /**< [  5:  5](R/W) Override automatic Stream Router interface allocation.
                                                                   0 = no override.
                                                                   1 = override. */
        uint32_t secondary             : 1;  /**< [  6:  6](R/W) Stream Router interface selection when hardware allocation is overridden.
                                                                   0 = primary.
                                                                   1 = secondary.

                                                                 Register field SECONDARY of the current combination of enabled carriers in CRX
                                                                 should be set so, that no more than half of the AxC message bandwidth towards
                                                                 Stream Router is allocated to the secondary interface. Consumed message
                                                                 bandwidth based on CONTAINER_N is as follows:
                                                                               0 =\> 1 msg per four Basic Frames.
                                                                               1 =\> 2 msg per four Basic Frames.
                                                                            2, 3 =\> 4 msg per four Basic Frames.
                                                                      4, 5, 6, 7 =\> 8 msg per four Basic Frames. */
        uint32_t reserved_7            : 1;
        uint32_t crx_axc_type          : 5;  /**< [ 12:  8](R/W) RP3 message type field for AxC. */
        uint32_t crx_axc_ts            : 6;  /**< [ 18: 13](R/W) RP3 message timestamp start value for AxC.
                                                                 Timestamp start value should always be configured as zero. */
        uint32_t crx_axc_addr          : 13; /**< [ 31: 19](R/W) RP3 message address field for AxC.
                                                                   0 .. 0x1FFE = valid.
                                                                        0x1FFF = invalid. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crx_axcx_ctrl_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crx_axcx_ctrl_lnx cavm_cprix_cn4ipx_crx_axcx_ctrl_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_AXCX_CTRL_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_AXCX_CTRL_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=63) && (d<=1)))
        return 0x864000820400ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10ll * ((c) & 0x3f) + 0x10000ll * ((d) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRX_AXCX_CTRL_LNX", 4, a, b, c, d, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRX_AXCX_CTRL_LNX(a,b,c,d) cavm_cprix_cn4ipx_crx_axcx_ctrl_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRX_AXCX_CTRL_LNX(a,b,c,d) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRX_AXCX_CTRL_LNX(a,b,c,d) "CPRIX_CN4IPX_CRX_AXCX_CTRL_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRX_AXCX_CTRL_LNX(a,b,c,d) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRX_AXCX_CTRL_LNX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) cpri#_cn4ip#_crx_axc#_ownrsp_ln#
 *
 * CPRI CONN4 IP CPRI RX AXC Container Ownership Configuration Register
 */
union cavm_cprix_cn4ipx_crx_axcx_ownrsp_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crx_axcx_ownrsp_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t container_k           : 1;  /**< [  0:  0](R/W) Number K of basic frames in the AxC container block.
                                                                   0 = one.
                                                                   1 = two. */
#else /* Word 0 - Little Endian */
        uint32_t container_k           : 1;  /**< [  0:  0](R/W) Number K of basic frames in the AxC container block.
                                                                   0 = one.
                                                                   1 = two. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crx_axcx_ownrsp_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crx_axcx_ownrsp_lnx cavm_cprix_cn4ipx_crx_axcx_ownrsp_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_AXCX_OWNRSP_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_AXCX_OWNRSP_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=63) && (d<=1)))
        return 0x864000820408ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10ll * ((c) & 0x3f) + 0x10000ll * ((d) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRX_AXCX_OWNRSP_LNX", 4, a, b, c, d, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRX_AXCX_OWNRSP_LNX(a,b,c,d) cavm_cprix_cn4ipx_crx_axcx_ownrsp_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRX_AXCX_OWNRSP_LNX(a,b,c,d) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRX_AXCX_OWNRSP_LNX(a,b,c,d) "CPRIX_CN4IPX_CRX_AXCX_OWNRSP_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRX_AXCX_OWNRSP_LNX(a,b,c,d) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRX_AXCX_OWNRSP_LNX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) cpri#_cn4ip#_crx_bank_ctrl#_ln#
 *
 * CPRI CONN4 IP CPRI RX Register Bank Configuration 0 to 15 Register
 */
union cavm_cprix_cn4ipx_crx_bank_ctrlx_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crx_bank_ctrlx_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_26_31        : 6;
        uint32_t bank_enable_high      : 1;  /**< [ 25: 25](R/W) Receive enable for high byte.
                                                                   0 = disabled.
                                                                   1 = enabled. */
        uint32_t bank_enable_low       : 1;  /**< [ 24: 24](R/W) Receive enable for low byte.
                                                                   0 = disabled.
                                                                   1 = enabled. */
        uint32_t reserved_22_23        : 2;
        uint32_t bank_mode             : 2;  /**< [ 21: 20](R/W) Receive mode for both data bytes. Received data matching the mode is loaded into
                                                                 CRX_BANK_DATA: BANK_DATA.
                                                                   0 = never receive.
                                                                   1 = receive when non-zero.
                                                                   2 = receive when not equal to current BANK_DATA.
                                                                   3 = always receive. */
        uint32_t reserved_19           : 1;
        uint32_t bank_y                : 3;  /**< [ 18: 16](R/W) Receive from the part of the CPRI word matching this coordinate.
                                                                   0 = bytes 1 and 0.
                                                                   1 = bytes 3 and 2.
                                                                   2 = bytes 5 and 4.
                                                                   3 = bytes 7 and 6.
                                                                   4 = bytes 9 and 8.
                                                                   5 = bytes 11 and 10.
                                                                   6 = bytes 13 and 12.
                                                                   7 = bytes 15 and 14.

                                                                 Note: If the bytes do not exist on selected line rate, the data is never received. */
        uint32_t bank_x                : 8;  /**< [ 15:  8](R/W) Receive from the Basic Frame with this X coordinate.
                                                                       0..0xFF = valid. */
        uint32_t bank_z                : 8;  /**< [  7:  0](R/W) Receive from the Hyperframe with this Z coordinate. Value 0xFF disregards
                                                                 comparison and matches any hyperframe.
                                                                       0..0x95  = matches the hyperframe.
                                                                     0x96..0xFE = no match.
                                                                          0xFF  = matches any hyperframe. */
#else /* Word 0 - Little Endian */
        uint32_t bank_z                : 8;  /**< [  7:  0](R/W) Receive from the Hyperframe with this Z coordinate. Value 0xFF disregards
                                                                 comparison and matches any hyperframe.
                                                                       0..0x95  = matches the hyperframe.
                                                                     0x96..0xFE = no match.
                                                                          0xFF  = matches any hyperframe. */
        uint32_t bank_x                : 8;  /**< [ 15:  8](R/W) Receive from the Basic Frame with this X coordinate.
                                                                       0..0xFF = valid. */
        uint32_t bank_y                : 3;  /**< [ 18: 16](R/W) Receive from the part of the CPRI word matching this coordinate.
                                                                   0 = bytes 1 and 0.
                                                                   1 = bytes 3 and 2.
                                                                   2 = bytes 5 and 4.
                                                                   3 = bytes 7 and 6.
                                                                   4 = bytes 9 and 8.
                                                                   5 = bytes 11 and 10.
                                                                   6 = bytes 13 and 12.
                                                                   7 = bytes 15 and 14.

                                                                 Note: If the bytes do not exist on selected line rate, the data is never received. */
        uint32_t reserved_19           : 1;
        uint32_t bank_mode             : 2;  /**< [ 21: 20](R/W) Receive mode for both data bytes. Received data matching the mode is loaded into
                                                                 CRX_BANK_DATA: BANK_DATA.
                                                                   0 = never receive.
                                                                   1 = receive when non-zero.
                                                                   2 = receive when not equal to current BANK_DATA.
                                                                   3 = always receive. */
        uint32_t reserved_22_23        : 2;
        uint32_t bank_enable_low       : 1;  /**< [ 24: 24](R/W) Receive enable for low byte.
                                                                   0 = disabled.
                                                                   1 = enabled. */
        uint32_t bank_enable_high      : 1;  /**< [ 25: 25](R/W) Receive enable for high byte.
                                                                   0 = disabled.
                                                                   1 = enabled. */
        uint32_t reserved_26_31        : 6;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crx_bank_ctrlx_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crx_bank_ctrlx_lnx cavm_cprix_cn4ipx_crx_bank_ctrlx_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_BANK_CTRLX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_BANK_CTRLX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=15) && (d<=1)))
        return 0x864000820080ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 8ll * ((c) & 0xf) + 0x10000ll * ((d) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRX_BANK_CTRLX_LNX", 4, a, b, c, d, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRX_BANK_CTRLX_LNX(a,b,c,d) cavm_cprix_cn4ipx_crx_bank_ctrlx_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRX_BANK_CTRLX_LNX(a,b,c,d) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRX_BANK_CTRLX_LNX(a,b,c,d) "CPRIX_CN4IPX_CRX_BANK_CTRLX_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRX_BANK_CTRLX_LNX(a,b,c,d) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRX_BANK_CTRLX_LNX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) cpri#_cn4ip#_crx_bank_data#_ln#
 *
 * CPRI CONN4 IP CPRI RX Register Bank Data 0 to 15 Register
 */
union cavm_cprix_cn4ipx_crx_bank_datax_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crx_bank_datax_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t bank_data             : 16; /**< [ 15:  0](RO/H) Received payload. When reception is enabled, this data will be received from the
                                                                 CPRI line at the coordinates configured in CRX_BANK_CONTROL. */
#else /* Word 0 - Little Endian */
        uint32_t bank_data             : 16; /**< [ 15:  0](RO/H) Received payload. When reception is enabled, this data will be received from the
                                                                 CPRI line at the coordinates configured in CRX_BANK_CONTROL. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crx_bank_datax_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crx_bank_datax_lnx cavm_cprix_cn4ipx_crx_bank_datax_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_BANK_DATAX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_BANK_DATAX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=15) && (d<=1)))
        return 0x864000820084ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 8ll * ((c) & 0xf) + 0x10000ll * ((d) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRX_BANK_DATAX_LNX", 4, a, b, c, d, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRX_BANK_DATAX_LNX(a,b,c,d) cavm_cprix_cn4ipx_crx_bank_datax_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRX_BANK_DATAX_LNX(a,b,c,d) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRX_BANK_DATAX_LNX(a,b,c,d) "CPRIX_CN4IPX_CRX_BANK_DATAX_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRX_BANK_DATAX_LNX(a,b,c,d) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRX_BANK_DATAX_LNX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) cpri#_cn4ip#_crx_ckfifo_lvl_ln#
 *
 * CPRI CONN4 IP CRX Clock Crossing FIFO fill level Register
 */
union cavm_cprix_cn4ipx_crx_ckfifo_lvl_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crx_ckfifo_lvl_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_9_31         : 23;
        uint32_t rx_ckfifo_lvl         : 9;  /**< [  8:  0](RO/H) CPRI RX clock crossing FIFO fill level. When the FIFO is synchronized, this
                                                                 register gets the initial value of CRX_CKFIFO_THR */
#else /* Word 0 - Little Endian */
        uint32_t rx_ckfifo_lvl         : 9;  /**< [  8:  0](RO/H) CPRI RX clock crossing FIFO fill level. When the FIFO is synchronized, this
                                                                 register gets the initial value of CRX_CKFIFO_THR */
        uint32_t reserved_9_31         : 23;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crx_ckfifo_lvl_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crx_ckfifo_lvl_lnx cavm_cprix_cn4ipx_crx_ckfifo_lvl_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_CKFIFO_LVL_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_CKFIFO_LVL_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x86400082002cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRX_CKFIFO_LVL_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRX_CKFIFO_LVL_LNX(a,b,c) cavm_cprix_cn4ipx_crx_ckfifo_lvl_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRX_CKFIFO_LVL_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRX_CKFIFO_LVL_LNX(a,b,c) "CPRIX_CN4IPX_CRX_CKFIFO_LVL_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRX_CKFIFO_LVL_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRX_CKFIFO_LVL_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_crx_ckfifo_thr_ln#
 *
 * CPRI CONN4 IP CRX Clock Crossing FIFO initial fill level Register
 */
union cavm_cprix_cn4ipx_crx_ckfifo_thr_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crx_ckfifo_thr_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_29_31        : 3;
        uint32_t force_s               : 1;  /**< [ 28: 28](R/W/H) Force CPRX clock crossing FIFO to immediately adjust its fill level to the value
                                                                 of field CRX_CKFIFO_THR.
                                                                   0 = do not force.
                                                                   1 = force. */
        uint32_t reserved_25_27        : 3;
        uint32_t delta                 : 9;  /**< [ 24: 16](R/W) Clock crossing FIFO read pointer shift value to be forced.
                                                                 Value is two's complement. Adjustment is applied when one is written to FORCE field. */
        uint32_t reserved_9_15         : 7;
        uint32_t crx_ckfifo_thr        : 9;  /**< [  8:  0](R/W) CPRI RX clock crossing FIFO initial fill level. Minimum setting is 4.
                                                                 The maximum setting is 0x3fd. */
#else /* Word 0 - Little Endian */
        uint32_t crx_ckfifo_thr        : 9;  /**< [  8:  0](R/W) CPRI RX clock crossing FIFO initial fill level. Minimum setting is 4.
                                                                 The maximum setting is 0x3fd. */
        uint32_t reserved_9_15         : 7;
        uint32_t delta                 : 9;  /**< [ 24: 16](R/W) Clock crossing FIFO read pointer shift value to be forced.
                                                                 Value is two's complement. Adjustment is applied when one is written to FORCE field. */
        uint32_t reserved_25_27        : 3;
        uint32_t force_s               : 1;  /**< [ 28: 28](R/W/H) Force CPRX clock crossing FIFO to immediately adjust its fill level to the value
                                                                 of field CRX_CKFIFO_THR.
                                                                   0 = do not force.
                                                                   1 = force. */
        uint32_t reserved_29_31        : 3;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crx_ckfifo_thr_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crx_ckfifo_thr_lnx cavm_cprix_cn4ipx_crx_ckfifo_thr_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_CKFIFO_THR_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_CKFIFO_THR_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000820028ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRX_CKFIFO_THR_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRX_CKFIFO_THR_LNX(a,b,c) cavm_cprix_cn4ipx_crx_ckfifo_thr_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRX_CKFIFO_THR_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRX_CKFIFO_THR_LNX(a,b,c) "CPRIX_CN4IPX_CRX_CKFIFO_THR_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRX_CKFIFO_THR_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRX_CKFIFO_THR_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_crx_ctrl_ln#
 *
 * CPRI CONN4 IP CPRI RX Control Register
 */
union cavm_cprix_cn4ipx_crx_ctrl_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crx_ctrl_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t crx_l1_reset_ack      : 1;  /**< [  5:  5](R/W) Enable L1 reset forwarding to CPRI TX.
                                                                   0 = L1 reset forwarding disabled.
                                                                   1 = L1 reset forwarding enabled. */
        uint32_t crx_l1_hw_res_en      : 1;  /**< [  4:  4](R/W) Enable hardware reset after L1 reset forwarding to CPRI TX (5 hyperframes).
                                                                   0 = L1 hardware reset disabled.
                                                                   1 = L1 hardware reset enabled. */
        uint32_t crx_fast_sync         : 1;  /**< [  3:  3](R/W) Enable fast frame synchronization.
                                                                   0 = Normal frame synchronization.
                                                                   1 = Fast frame synchronization. */
        uint32_t crx_force_unsync      : 1;  /**< [  2:  2](R/W) Force CPRI RX state machine to XACQ1 (unsync) state.
                                                                   0 = RX state machine runs free.
                                                                   1 = RX state machine is forced to XACQ1. */
        uint32_t crx_protocol_ver      : 1;  /**< [  1:  1](R/W) CPRI RX protocol version selection.
                                                                   0 = version 1.
                                                                   1 = version 2 (descrambling enabled). */
        uint32_t crx_en                : 1;  /**< [  0:  0](R/W) CPRI RX Enable.
                                                                   0 = CPRI RX disabled.
                                                                   1 = CPRI RX enabled. */
#else /* Word 0 - Little Endian */
        uint32_t crx_en                : 1;  /**< [  0:  0](R/W) CPRI RX Enable.
                                                                   0 = CPRI RX disabled.
                                                                   1 = CPRI RX enabled. */
        uint32_t crx_protocol_ver      : 1;  /**< [  1:  1](R/W) CPRI RX protocol version selection.
                                                                   0 = version 1.
                                                                   1 = version 2 (descrambling enabled). */
        uint32_t crx_force_unsync      : 1;  /**< [  2:  2](R/W) Force CPRI RX state machine to XACQ1 (unsync) state.
                                                                   0 = RX state machine runs free.
                                                                   1 = RX state machine is forced to XACQ1. */
        uint32_t crx_fast_sync         : 1;  /**< [  3:  3](R/W) Enable fast frame synchronization.
                                                                   0 = Normal frame synchronization.
                                                                   1 = Fast frame synchronization. */
        uint32_t crx_l1_hw_res_en      : 1;  /**< [  4:  4](R/W) Enable hardware reset after L1 reset forwarding to CPRI TX (5 hyperframes).
                                                                   0 = L1 hardware reset disabled.
                                                                   1 = L1 hardware reset enabled. */
        uint32_t crx_l1_reset_ack      : 1;  /**< [  5:  5](R/W) Enable L1 reset forwarding to CPRI TX.
                                                                   0 = L1 reset forwarding disabled.
                                                                   1 = L1 reset forwarding enabled. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crx_ctrl_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crx_ctrl_lnx cavm_cprix_cn4ipx_crx_ctrl_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_CTRL_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_CTRL_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000820000ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRX_CTRL_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRX_CTRL_LNX(a,b,c) cavm_cprix_cn4ipx_crx_ctrl_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRX_CTRL_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRX_CTRL_LNX(a,b,c) "CPRIX_CN4IPX_CRX_CTRL_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRX_CTRL_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRX_CTRL_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_crx_eth_ctrl_ln#
 *
 * CPRI CONN4 IP CPRI RX Ethernet Control Register
 */
union cavm_cprix_cn4ipx_crx_eth_ctrl_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crx_eth_ctrl_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t crx_eth_ctrl          : 6;  /**< [  5:  0](R/W) Pointer to the subchannel where Ethernet links starts.
                                                                   0x13-0x0 = Ethernet disabled.
                                                                   0x3F-0x14 = Start of Ethernet channel. */
#else /* Word 0 - Little Endian */
        uint32_t crx_eth_ctrl          : 6;  /**< [  5:  0](R/W) Pointer to the subchannel where Ethernet links starts.
                                                                   0x13-0x0 = Ethernet disabled.
                                                                   0x3F-0x14 = Start of Ethernet channel. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crx_eth_ctrl_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crx_eth_ctrl_lnx cavm_cprix_cn4ipx_crx_eth_ctrl_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_ETH_CTRL_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_ETH_CTRL_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x86400082001cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRX_ETH_CTRL_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRX_ETH_CTRL_LNX(a,b,c) cavm_cprix_cn4ipx_crx_eth_ctrl_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRX_ETH_CTRL_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRX_ETH_CTRL_LNX(a,b,c) "CPRIX_CN4IPX_CRX_ETH_CTRL_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRX_ETH_CTRL_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRX_ETH_CTRL_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_crx_hdlc_c0_ln#
 *
 * CPRI CONN4 IP CPRI RX HDLC Buffer Configuration 0 Register
 */
union cavm_cprix_cn4ipx_crx_hdlc_c0_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crx_hdlc_c0_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_17_31        : 15;
        uint32_t enable                : 1;  /**< [ 16: 16](R/W) CRX HDLC Buffer enable.
                                                                   0 = disabled.
                                                                   1 = enabled. */
        uint32_t reserved_10_15        : 6;
        uint32_t length                : 10; /**< [  9:  0](R/W) Pointer to the last location allocated for the buffer in CRX VSB RAM.
                                                                 Unit of the pointer is a 32-bit word.
                                                                 Actual length of the buffer is value of this field plus one i.e. range is from 1
                                                                 word to 1024 words. */
#else /* Word 0 - Little Endian */
        uint32_t length                : 10; /**< [  9:  0](R/W) Pointer to the last location allocated for the buffer in CRX VSB RAM.
                                                                 Unit of the pointer is a 32-bit word.
                                                                 Actual length of the buffer is value of this field plus one i.e. range is from 1
                                                                 word to 1024 words. */
        uint32_t reserved_10_15        : 6;
        uint32_t enable                : 1;  /**< [ 16: 16](R/W) CRX HDLC Buffer enable.
                                                                   0 = disabled.
                                                                   1 = enabled. */
        uint32_t reserved_17_31        : 15;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crx_hdlc_c0_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crx_hdlc_c0_lnx cavm_cprix_cn4ipx_crx_hdlc_c0_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_HDLC_C0_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_HDLC_C0_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000820240ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRX_HDLC_C0_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRX_HDLC_C0_LNX(a,b,c) cavm_cprix_cn4ipx_crx_hdlc_c0_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRX_HDLC_C0_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRX_HDLC_C0_LNX(a,b,c) "CPRIX_CN4IPX_CRX_HDLC_C0_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRX_HDLC_C0_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRX_HDLC_C0_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_crx_hdlc_c1_ln#
 *
 * CPRI CONN4 IP CPRI RX HDLC Buffer Configuration 1 Register
 */
union cavm_cprix_cn4ipx_crx_hdlc_c1_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crx_hdlc_c1_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_10_31        : 22;
        uint32_t read_pointer          : 10; /**< [  9:  0](R/W) Pointer to the most recently read HDLC data in the buffer.
                                                                 SW should update this pointer after reading each subframe.
                                                                 Unit of the pointer is a 32-bit word. */
#else /* Word 0 - Little Endian */
        uint32_t read_pointer          : 10; /**< [  9:  0](R/W) Pointer to the most recently read HDLC data in the buffer.
                                                                 SW should update this pointer after reading each subframe.
                                                                 Unit of the pointer is a 32-bit word. */
        uint32_t reserved_10_31        : 22;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crx_hdlc_c1_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crx_hdlc_c1_lnx cavm_cprix_cn4ipx_crx_hdlc_c1_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_HDLC_C1_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_HDLC_C1_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000820244ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRX_HDLC_C1_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRX_HDLC_C1_LNX(a,b,c) cavm_cprix_cn4ipx_crx_hdlc_c1_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRX_HDLC_C1_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRX_HDLC_C1_LNX(a,b,c) "CPRIX_CN4IPX_CRX_HDLC_C1_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRX_HDLC_C1_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRX_HDLC_C1_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_crx_hdlc_ctrl_ln#
 *
 * CPRI CONN4 IP CPRI RX HDLC Buffer Control Register
 */
union cavm_cprix_cn4ipx_crx_hdlc_ctrl_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crx_hdlc_ctrl_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t crx_hdlc_bit_order    : 1;  /**< [  6:  6](R/W) Reverse bits within received FCS byte.
                                                                   0 = normal.
                                                                   1 = Reversed. */
        uint32_t crx_hdlc_crc_order    : 1;  /**< [  5:  5](R/W) Order of the received FCS bytes.
                                                                   0 = normal (as received).
                                                                   1 = swapped. */
        uint32_t crx_hdlc_crc_inv      : 1;  /**< [  4:  4](R/W) CRC checksum value after the FCS is shifted in.
                                                                   0 = 0x1D0F (FCS not inverted).
                                                                   1 = 0x0000 (FCS inverted). */
        uint32_t crx_hdlc_crc_init     : 1;  /**< [  3:  3](R/W) Preset value of the CRC calculation register.
                                                                   0 = 0xFFFF.
                                                                   1 = 0x0000. */
        uint32_t crx_hdlc_ctrl         : 3;  /**< [  2:  0](R/W) HDLC bit rate selection:
                                                                   0x0 = Not used (HDLC disabled).
                                                                   0x1 = 240 kbit/s.
                                                                   0x2 = 480 kbit/s.
                                                                   0x3 = 960 kbit/s.
                                                                   0x4 = 1920 kbit/s (valid for line rates \>= 2457.6 Mbit/s).
                                                                   0x5 = 2400 kbit/s (valid for line rates \>= 4915.2 Mbit/s).
                                                                   0x6 = 3840 kbit/s when CPRI line rate is 4915.2 Mbit/s or 4800 kbit/s when
                                                                 CPRI line rate is 6144.0 Mbit/s 7680 kbit/s when line rate is 9830.4 Mbit/s
                                                                 (valid for line rates \>= 4915.2 Mbit/s).
                                                                   0x7 = Not used (HDLC disabled). */
#else /* Word 0 - Little Endian */
        uint32_t crx_hdlc_ctrl         : 3;  /**< [  2:  0](R/W) HDLC bit rate selection:
                                                                   0x0 = Not used (HDLC disabled).
                                                                   0x1 = 240 kbit/s.
                                                                   0x2 = 480 kbit/s.
                                                                   0x3 = 960 kbit/s.
                                                                   0x4 = 1920 kbit/s (valid for line rates \>= 2457.6 Mbit/s).
                                                                   0x5 = 2400 kbit/s (valid for line rates \>= 4915.2 Mbit/s).
                                                                   0x6 = 3840 kbit/s when CPRI line rate is 4915.2 Mbit/s or 4800 kbit/s when
                                                                 CPRI line rate is 6144.0 Mbit/s 7680 kbit/s when line rate is 9830.4 Mbit/s
                                                                 (valid for line rates \>= 4915.2 Mbit/s).
                                                                   0x7 = Not used (HDLC disabled). */
        uint32_t crx_hdlc_crc_init     : 1;  /**< [  3:  3](R/W) Preset value of the CRC calculation register.
                                                                   0 = 0xFFFF.
                                                                   1 = 0x0000. */
        uint32_t crx_hdlc_crc_inv      : 1;  /**< [  4:  4](R/W) CRC checksum value after the FCS is shifted in.
                                                                   0 = 0x1D0F (FCS not inverted).
                                                                   1 = 0x0000 (FCS inverted). */
        uint32_t crx_hdlc_crc_order    : 1;  /**< [  5:  5](R/W) Order of the received FCS bytes.
                                                                   0 = normal (as received).
                                                                   1 = swapped. */
        uint32_t crx_hdlc_bit_order    : 1;  /**< [  6:  6](R/W) Reverse bits within received FCS byte.
                                                                   0 = normal.
                                                                   1 = Reversed. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crx_hdlc_ctrl_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crx_hdlc_ctrl_lnx cavm_cprix_cn4ipx_crx_hdlc_ctrl_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_HDLC_CTRL_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_HDLC_CTRL_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x86400082024cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRX_HDLC_CTRL_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRX_HDLC_CTRL_LNX(a,b,c) cavm_cprix_cn4ipx_crx_hdlc_ctrl_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRX_HDLC_CTRL_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRX_HDLC_CTRL_LNX(a,b,c) "CPRIX_CN4IPX_CRX_HDLC_CTRL_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRX_HDLC_CTRL_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRX_HDLC_CTRL_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_crx_hdlc_mon_ln#
 *
 * CPRI CONN4 IP CPRI RX HDLC Monitor Control Register
 */
union cavm_cprix_cn4ipx_crx_hdlc_mon_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crx_hdlc_mon_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t hdlc_ck               : 1;  /**< [  1:  1](R/W) Enable output of HDLC clock to HDLC_CK.
                                                                   0 = disabled.
                                                                   1 = enabled. */
        uint32_t hdlc_rx               : 1;  /**< [  0:  0](R/W) Enable output of HDLC data to HDLC_RX.
                                                                   0 = disabled.
                                                                   1 = enabled. */
#else /* Word 0 - Little Endian */
        uint32_t hdlc_rx               : 1;  /**< [  0:  0](R/W) Enable output of HDLC data to HDLC_RX.
                                                                   0 = disabled.
                                                                   1 = enabled. */
        uint32_t hdlc_ck               : 1;  /**< [  1:  1](R/W) Enable output of HDLC clock to HDLC_CK.
                                                                   0 = disabled.
                                                                   1 = enabled. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crx_hdlc_mon_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crx_hdlc_mon_lnx cavm_cprix_cn4ipx_crx_hdlc_mon_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_HDLC_MON_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_HDLC_MON_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000820250ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRX_HDLC_MON_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRX_HDLC_MON_LNX(a,b,c) cavm_cprix_cn4ipx_crx_hdlc_mon_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRX_HDLC_MON_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRX_HDLC_MON_LNX(a,b,c) "CPRIX_CN4IPX_CRX_HDLC_MON_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRX_HDLC_MON_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRX_HDLC_MON_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_crx_hdlc_sts_ln#
 *
 * CPRI CONN4 IP CPRI RX HDLC Buffer Status Register
 */
union cavm_cprix_cn4ipx_crx_hdlc_sts_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crx_hdlc_sts_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_10_31        : 22;
        uint32_t receive_pointer       : 10; /**< [  9:  0](RO/H) Pointer to the header of the most recently received HDLC subframe in the buffer.
                                                                 Unit of the pointer is a 32-bit word. */
#else /* Word 0 - Little Endian */
        uint32_t receive_pointer       : 10; /**< [  9:  0](RO/H) Pointer to the header of the most recently received HDLC subframe in the buffer.
                                                                 Unit of the pointer is a 32-bit word. */
        uint32_t reserved_10_31        : 22;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crx_hdlc_sts_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crx_hdlc_sts_lnx cavm_cprix_cn4ipx_crx_hdlc_sts_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_HDLC_STS_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_HDLC_STS_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000820248ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRX_HDLC_STS_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRX_HDLC_STS_LNX(a,b,c) cavm_cprix_cn4ipx_crx_hdlc_sts_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRX_HDLC_STS_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRX_HDLC_STS_LNX(a,b,c) "CPRIX_CN4IPX_CRX_HDLC_STS_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRX_HDLC_STS_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRX_HDLC_STS_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_crx_int_clr_ln#
 *
 * CPRI CONN4 IP CPRI RX Interrupt Clear Register
 */
union cavm_cprix_cn4ipx_crx_int_clr_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crx_int_clr_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t shadow_sync           : 1;  /**< [ 31: 31](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT.
                                                                     0 = no effect.
                                                                     1 = Interrupt Clear. */
        uint32_t shadow_state          : 1;  /**< [ 30: 30](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t shadow_lof            : 1;  /**< [ 29: 29](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t shadow_los            : 1;  /**< [ 28: 28](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t reserved_25_27        : 3;
        uint32_t hdlc_flag_ff          : 1;  /**< [ 24: 24](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_flag_7f          : 1;  /**< [ 23: 23](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_flag_7e          : 1;  /**< [ 22: 22](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_tunnel_error      : 1;  /**< [ 21: 21](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t axc_collision         : 1;  /**< [ 20: 20](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_overflow         : 1;  /**< [ 19: 19](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_subframe_received : 1; /**< [ 18: 18](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t meas_transfer_err     : 1;  /**< [ 17: 17](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t sdvm_error            : 1;  /**< [ 16: 16](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_protocol_ver_int : 1;/**< [ 15: 15](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_eth_ctrl_int   : 1;  /**< [ 14: 14](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_hdlc_ctrl_int  : 1;  /**< [ 13: 13](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_lof_int        : 1;  /**< [ 12: 12](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_los_int        : 1;  /**< [ 11: 11](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_sdi_int        : 1;  /**< [ 10: 10](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_rai_int        : 1;  /**< [  9:  9](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_reset_int      : 1;  /**< [  8:  8](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t reserved_6_7          : 2;
        uint32_t eth_esd_err           : 1;  /**< [  5:  5](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_ckfifo_err        : 1;  /**< [  4:  4](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_sync_int          : 1;  /**< [  3:  3](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_state_int         : 1;  /**< [  2:  2](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_lof_int           : 1;  /**< [  1:  1](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_los_int           : 1;  /**< [  0:  0](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
#else /* Word 0 - Little Endian */
        uint32_t crx_los_int           : 1;  /**< [  0:  0](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_lof_int           : 1;  /**< [  1:  1](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_state_int         : 1;  /**< [  2:  2](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_sync_int          : 1;  /**< [  3:  3](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_ckfifo_err        : 1;  /**< [  4:  4](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t eth_esd_err           : 1;  /**< [  5:  5](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t reserved_6_7          : 2;
        uint32_t crx_l1_reset_int      : 1;  /**< [  8:  8](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_rai_int        : 1;  /**< [  9:  9](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_sdi_int        : 1;  /**< [ 10: 10](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_los_int        : 1;  /**< [ 11: 11](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_lof_int        : 1;  /**< [ 12: 12](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_hdlc_ctrl_int  : 1;  /**< [ 13: 13](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_eth_ctrl_int   : 1;  /**< [ 14: 14](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_protocol_ver_int : 1;/**< [ 15: 15](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t sdvm_error            : 1;  /**< [ 16: 16](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t meas_transfer_err     : 1;  /**< [ 17: 17](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_subframe_received : 1; /**< [ 18: 18](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_overflow         : 1;  /**< [ 19: 19](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t axc_collision         : 1;  /**< [ 20: 20](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_tunnel_error      : 1;  /**< [ 21: 21](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_flag_7e          : 1;  /**< [ 22: 22](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_flag_7f          : 1;  /**< [ 23: 23](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_flag_ff          : 1;  /**< [ 24: 24](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t reserved_25_27        : 3;
        uint32_t shadow_los            : 1;  /**< [ 28: 28](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t shadow_lof            : 1;  /**< [ 29: 29](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t shadow_state          : 1;  /**< [ 30: 30](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t shadow_sync           : 1;  /**< [ 31: 31](R/W1C/H) Clear for corresponding interrupt status bits in CRX_INT.
                                                                     0 = no effect.
                                                                     1 = Interrupt Clear. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crx_int_clr_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crx_int_clr_lnx cavm_cprix_cn4ipx_crx_int_clr_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_INT_CLR_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_INT_CLR_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000820044ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRX_INT_CLR_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRX_INT_CLR_LNX(a,b,c) cavm_cprix_cn4ipx_crx_int_clr_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRX_INT_CLR_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRX_INT_CLR_LNX(a,b,c) "CPRIX_CN4IPX_CRX_INT_CLR_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRX_INT_CLR_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRX_INT_CLR_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_crx_int_mask_ln#
 *
 * CPRI CONN4 IP CPRI RX Interrupt Mask Register
 */
union cavm_cprix_cn4ipx_crx_int_mask_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crx_int_mask_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t shadow_sync           : 1;  /**< [ 31: 31](R/W) Mask for corresponding interrupt status bits in CRX_INT.
                                                                     0 = Interrupt enabled.
                                                                     1 = Interrupt masked. */
        uint32_t shadow_state          : 1;  /**< [ 30: 30](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t shadow_lof            : 1;  /**< [ 29: 29](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t shadow_los            : 1;  /**< [ 28: 28](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t reserved_25_27        : 3;
        uint32_t hdlc_flag_ff          : 1;  /**< [ 24: 24](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_flag_7f          : 1;  /**< [ 23: 23](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_flag_7e          : 1;  /**< [ 22: 22](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_tunnel_error      : 1;  /**< [ 21: 21](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t axc_collision         : 1;  /**< [ 20: 20](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_overflow         : 1;  /**< [ 19: 19](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_subframe_received : 1; /**< [ 18: 18](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t meas_transfer_err     : 1;  /**< [ 17: 17](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t sdvm_error            : 1;  /**< [ 16: 16](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_protocol_ver_int : 1;/**< [ 15: 15](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_eth_ctrl_int   : 1;  /**< [ 14: 14](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_hdlc_ctrl_int  : 1;  /**< [ 13: 13](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_lof_int        : 1;  /**< [ 12: 12](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_los_int        : 1;  /**< [ 11: 11](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_sdi_int        : 1;  /**< [ 10: 10](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_rai_int        : 1;  /**< [  9:  9](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_reset_int      : 1;  /**< [  8:  8](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t reserved_6_7          : 2;
        uint32_t eth_esd_err           : 1;  /**< [  5:  5](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_ckfifo_err        : 1;  /**< [  4:  4](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_sync_int          : 1;  /**< [  3:  3](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_state_int         : 1;  /**< [  2:  2](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_lof_int           : 1;  /**< [  1:  1](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_los_int           : 1;  /**< [  0:  0](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
#else /* Word 0 - Little Endian */
        uint32_t crx_los_int           : 1;  /**< [  0:  0](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_lof_int           : 1;  /**< [  1:  1](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_state_int         : 1;  /**< [  2:  2](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_sync_int          : 1;  /**< [  3:  3](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_ckfifo_err        : 1;  /**< [  4:  4](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t eth_esd_err           : 1;  /**< [  5:  5](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t reserved_6_7          : 2;
        uint32_t crx_l1_reset_int      : 1;  /**< [  8:  8](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_rai_int        : 1;  /**< [  9:  9](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_sdi_int        : 1;  /**< [ 10: 10](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_los_int        : 1;  /**< [ 11: 11](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_lof_int        : 1;  /**< [ 12: 12](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_hdlc_ctrl_int  : 1;  /**< [ 13: 13](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_eth_ctrl_int   : 1;  /**< [ 14: 14](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_protocol_ver_int : 1;/**< [ 15: 15](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t sdvm_error            : 1;  /**< [ 16: 16](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t meas_transfer_err     : 1;  /**< [ 17: 17](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_subframe_received : 1; /**< [ 18: 18](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_overflow         : 1;  /**< [ 19: 19](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t axc_collision         : 1;  /**< [ 20: 20](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_tunnel_error      : 1;  /**< [ 21: 21](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_flag_7e          : 1;  /**< [ 22: 22](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_flag_7f          : 1;  /**< [ 23: 23](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_flag_ff          : 1;  /**< [ 24: 24](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t reserved_25_27        : 3;
        uint32_t shadow_los            : 1;  /**< [ 28: 28](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t shadow_lof            : 1;  /**< [ 29: 29](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t shadow_state          : 1;  /**< [ 30: 30](R/W) Mask for corresponding interrupt status bits in CRX_INT. */
        uint32_t shadow_sync           : 1;  /**< [ 31: 31](R/W) Mask for corresponding interrupt status bits in CRX_INT.
                                                                     0 = Interrupt enabled.
                                                                     1 = Interrupt masked. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crx_int_mask_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crx_int_mask_lnx cavm_cprix_cn4ipx_crx_int_mask_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_INT_MASK_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_INT_MASK_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000820050ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRX_INT_MASK_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRX_INT_MASK_LNX(a,b,c) cavm_cprix_cn4ipx_crx_int_mask_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRX_INT_MASK_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRX_INT_MASK_LNX(a,b,c) "CPRIX_CN4IPX_CRX_INT_MASK_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRX_INT_MASK_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRX_INT_MASK_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_crx_int_mskclr_ln#
 *
 * CPRI CONN4 IP CPRI RX Interrupt Mask Clear Register
 */
union cavm_cprix_cn4ipx_crx_int_mskclr_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crx_int_mskclr_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t shadow_sync           : 1;  /**< [ 31: 31](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT.
                                                                     0 = No effect.
                                                                     1 = Mask clear. */
        uint32_t shadow_state          : 1;  /**< [ 30: 30](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t shadow_lof            : 1;  /**< [ 29: 29](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t shadow_los            : 1;  /**< [ 28: 28](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t reserved_25_27        : 3;
        uint32_t hdlc_flag_ff          : 1;  /**< [ 24: 24](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_flag_7f          : 1;  /**< [ 23: 23](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_flag_7e          : 1;  /**< [ 22: 22](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_tunnel_error      : 1;  /**< [ 21: 21](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t axc_collision         : 1;  /**< [ 20: 20](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_overflow         : 1;  /**< [ 19: 19](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_subframe_received : 1; /**< [ 18: 18](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t meas_transfer_err     : 1;  /**< [ 17: 17](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t sdvm_error            : 1;  /**< [ 16: 16](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_protocol_ver_int : 1;/**< [ 15: 15](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_eth_ctrl_int   : 1;  /**< [ 14: 14](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_hdlc_ctrl_int  : 1;  /**< [ 13: 13](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_lof_int        : 1;  /**< [ 12: 12](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_los_int        : 1;  /**< [ 11: 11](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_sdi_int        : 1;  /**< [ 10: 10](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_rai_int        : 1;  /**< [  9:  9](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_reset_int      : 1;  /**< [  8:  8](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t reserved_6_7          : 2;
        uint32_t eth_esd_err           : 1;  /**< [  5:  5](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_ckfifo_err        : 1;  /**< [  4:  4](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_sync_int          : 1;  /**< [  3:  3](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_state_int         : 1;  /**< [  2:  2](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_lof_int           : 1;  /**< [  1:  1](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_los_int           : 1;  /**< [  0:  0](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
#else /* Word 0 - Little Endian */
        uint32_t crx_los_int           : 1;  /**< [  0:  0](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_lof_int           : 1;  /**< [  1:  1](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_state_int         : 1;  /**< [  2:  2](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_sync_int          : 1;  /**< [  3:  3](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_ckfifo_err        : 1;  /**< [  4:  4](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t eth_esd_err           : 1;  /**< [  5:  5](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t reserved_6_7          : 2;
        uint32_t crx_l1_reset_int      : 1;  /**< [  8:  8](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_rai_int        : 1;  /**< [  9:  9](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_sdi_int        : 1;  /**< [ 10: 10](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_los_int        : 1;  /**< [ 11: 11](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_lof_int        : 1;  /**< [ 12: 12](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_hdlc_ctrl_int  : 1;  /**< [ 13: 13](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_eth_ctrl_int   : 1;  /**< [ 14: 14](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_protocol_ver_int : 1;/**< [ 15: 15](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t sdvm_error            : 1;  /**< [ 16: 16](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t meas_transfer_err     : 1;  /**< [ 17: 17](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_subframe_received : 1; /**< [ 18: 18](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_overflow         : 1;  /**< [ 19: 19](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t axc_collision         : 1;  /**< [ 20: 20](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_tunnel_error      : 1;  /**< [ 21: 21](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_flag_7e          : 1;  /**< [ 22: 22](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_flag_7f          : 1;  /**< [ 23: 23](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_flag_ff          : 1;  /**< [ 24: 24](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t reserved_25_27        : 3;
        uint32_t shadow_los            : 1;  /**< [ 28: 28](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t shadow_lof            : 1;  /**< [ 29: 29](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t shadow_state          : 1;  /**< [ 30: 30](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT. */
        uint32_t shadow_sync           : 1;  /**< [ 31: 31](R/W1C/H) Mask clear for corresponding interrupt status bits in CRX_INT.
                                                                     0 = No effect.
                                                                     1 = Mask clear. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crx_int_mskclr_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crx_int_mskclr_lnx cavm_cprix_cn4ipx_crx_int_mskclr_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_INT_MSKCLR_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_INT_MSKCLR_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000820054ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRX_INT_MSKCLR_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRX_INT_MSKCLR_LNX(a,b,c) cavm_cprix_cn4ipx_crx_int_mskclr_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRX_INT_MSKCLR_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRX_INT_MSKCLR_LNX(a,b,c) "CPRIX_CN4IPX_CRX_INT_MSKCLR_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRX_INT_MSKCLR_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRX_INT_MSKCLR_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_crx_int_mskset_ln#
 *
 * CPRI CONN4 IP CPRI RX Interrupt Mask Set Register
 */
union cavm_cprix_cn4ipx_crx_int_mskset_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crx_int_mskset_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t shadow_sync           : 1;  /**< [ 31: 31](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT.
                                                                     0 = No effect.
                                                                     1 = Mask set. */
        uint32_t shadow_state          : 1;  /**< [ 30: 30](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t shadow_lof            : 1;  /**< [ 29: 29](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t shadow_los            : 1;  /**< [ 28: 28](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t reserved_25_27        : 3;
        uint32_t hdlc_flag_ff          : 1;  /**< [ 24: 24](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_flag_7f          : 1;  /**< [ 23: 23](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_flag_7e          : 1;  /**< [ 22: 22](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_tunnel_error      : 1;  /**< [ 21: 21](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t axc_collision         : 1;  /**< [ 20: 20](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_overflow         : 1;  /**< [ 19: 19](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_subframe_received : 1; /**< [ 18: 18](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t meas_transfer_err     : 1;  /**< [ 17: 17](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t sdvm_error            : 1;  /**< [ 16: 16](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_protocol_ver_int : 1;/**< [ 15: 15](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_eth_ctrl_int   : 1;  /**< [ 14: 14](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_hdlc_ctrl_int  : 1;  /**< [ 13: 13](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_lof_int        : 1;  /**< [ 12: 12](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_los_int        : 1;  /**< [ 11: 11](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_sdi_int        : 1;  /**< [ 10: 10](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_rai_int        : 1;  /**< [  9:  9](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_reset_int      : 1;  /**< [  8:  8](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t reserved_6_7          : 2;
        uint32_t eth_esd_err           : 1;  /**< [  5:  5](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_ckfifo_err        : 1;  /**< [  4:  4](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_sync_int          : 1;  /**< [  3:  3](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_state_int         : 1;  /**< [  2:  2](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_lof_int           : 1;  /**< [  1:  1](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_los_int           : 1;  /**< [  0:  0](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
#else /* Word 0 - Little Endian */
        uint32_t crx_los_int           : 1;  /**< [  0:  0](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_lof_int           : 1;  /**< [  1:  1](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_state_int         : 1;  /**< [  2:  2](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_sync_int          : 1;  /**< [  3:  3](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_ckfifo_err        : 1;  /**< [  4:  4](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t eth_esd_err           : 1;  /**< [  5:  5](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t reserved_6_7          : 2;
        uint32_t crx_l1_reset_int      : 1;  /**< [  8:  8](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_rai_int        : 1;  /**< [  9:  9](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_sdi_int        : 1;  /**< [ 10: 10](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_los_int        : 1;  /**< [ 11: 11](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_lof_int        : 1;  /**< [ 12: 12](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_hdlc_ctrl_int  : 1;  /**< [ 13: 13](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_eth_ctrl_int   : 1;  /**< [ 14: 14](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_protocol_ver_int : 1;/**< [ 15: 15](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t sdvm_error            : 1;  /**< [ 16: 16](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t meas_transfer_err     : 1;  /**< [ 17: 17](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_subframe_received : 1; /**< [ 18: 18](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_overflow         : 1;  /**< [ 19: 19](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t axc_collision         : 1;  /**< [ 20: 20](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_tunnel_error      : 1;  /**< [ 21: 21](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_flag_7e          : 1;  /**< [ 22: 22](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_flag_7f          : 1;  /**< [ 23: 23](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_flag_ff          : 1;  /**< [ 24: 24](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t reserved_25_27        : 3;
        uint32_t shadow_los            : 1;  /**< [ 28: 28](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t shadow_lof            : 1;  /**< [ 29: 29](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t shadow_state          : 1;  /**< [ 30: 30](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT. */
        uint32_t shadow_sync           : 1;  /**< [ 31: 31](R/W1S/H) Mask set for corresponding interrupt status bits in CRX_INT.
                                                                     0 = No effect.
                                                                     1 = Mask set. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crx_int_mskset_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crx_int_mskset_lnx cavm_cprix_cn4ipx_crx_int_mskset_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_INT_MSKSET_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_INT_MSKSET_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000820058ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRX_INT_MSKSET_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRX_INT_MSKSET_LNX(a,b,c) cavm_cprix_cn4ipx_crx_int_mskset_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRX_INT_MSKSET_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRX_INT_MSKSET_LNX(a,b,c) "CPRIX_CN4IPX_CRX_INT_MSKSET_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRX_INT_MSKSET_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRX_INT_MSKSET_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_crx_int_set_ln#
 *
 * CPRI CONN4 IP CPRI RX Interrupt Set Register
 */
union cavm_cprix_cn4ipx_crx_int_set_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crx_int_set_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t shadow_sync           : 1;  /**< [ 31: 31](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT.
                                                                     0 = no effect.
                                                                     1 = Interrupt Set. */
        uint32_t shadow_state          : 1;  /**< [ 30: 30](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t shadow_lof            : 1;  /**< [ 29: 29](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t shadow_los            : 1;  /**< [ 28: 28](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t reserved_25_27        : 3;
        uint32_t hdlc_flag_ff          : 1;  /**< [ 24: 24](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_flag_7f          : 1;  /**< [ 23: 23](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_flag_7e          : 1;  /**< [ 22: 22](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_tunnel_error      : 1;  /**< [ 21: 21](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t axc_collision         : 1;  /**< [ 20: 20](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_overflow         : 1;  /**< [ 19: 19](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_subframe_received : 1; /**< [ 18: 18](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t meas_transfer_err     : 1;  /**< [ 17: 17](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t sdvm_error            : 1;  /**< [ 16: 16](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_protocol_ver_int : 1;/**< [ 15: 15](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_eth_ctrl_int   : 1;  /**< [ 14: 14](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_hdlc_ctrl_int  : 1;  /**< [ 13: 13](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_lof_int        : 1;  /**< [ 12: 12](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_los_int        : 1;  /**< [ 11: 11](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_sdi_int        : 1;  /**< [ 10: 10](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_rai_int        : 1;  /**< [  9:  9](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_reset_int      : 1;  /**< [  8:  8](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t reserved_6_7          : 2;
        uint32_t eth_esd_err           : 1;  /**< [  5:  5](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_ckfifo_err        : 1;  /**< [  4:  4](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_sync_int          : 1;  /**< [  3:  3](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_state_int         : 1;  /**< [  2:  2](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_lof_int           : 1;  /**< [  1:  1](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_los_int           : 1;  /**< [  0:  0](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
#else /* Word 0 - Little Endian */
        uint32_t crx_los_int           : 1;  /**< [  0:  0](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_lof_int           : 1;  /**< [  1:  1](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_state_int         : 1;  /**< [  2:  2](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_sync_int          : 1;  /**< [  3:  3](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_ckfifo_err        : 1;  /**< [  4:  4](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t eth_esd_err           : 1;  /**< [  5:  5](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t reserved_6_7          : 2;
        uint32_t crx_l1_reset_int      : 1;  /**< [  8:  8](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_rai_int        : 1;  /**< [  9:  9](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_sdi_int        : 1;  /**< [ 10: 10](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_los_int        : 1;  /**< [ 11: 11](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_lof_int        : 1;  /**< [ 12: 12](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_hdlc_ctrl_int  : 1;  /**< [ 13: 13](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_eth_ctrl_int   : 1;  /**< [ 14: 14](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_l1_protocol_ver_int : 1;/**< [ 15: 15](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t sdvm_error            : 1;  /**< [ 16: 16](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t meas_transfer_err     : 1;  /**< [ 17: 17](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_subframe_received : 1; /**< [ 18: 18](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_overflow         : 1;  /**< [ 19: 19](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t axc_collision         : 1;  /**< [ 20: 20](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t crx_tunnel_error      : 1;  /**< [ 21: 21](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_flag_7e          : 1;  /**< [ 22: 22](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_flag_7f          : 1;  /**< [ 23: 23](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t hdlc_flag_ff          : 1;  /**< [ 24: 24](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t reserved_25_27        : 3;
        uint32_t shadow_los            : 1;  /**< [ 28: 28](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t shadow_lof            : 1;  /**< [ 29: 29](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t shadow_state          : 1;  /**< [ 30: 30](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT. */
        uint32_t shadow_sync           : 1;  /**< [ 31: 31](R/W1S/H) Set for corresponding interrupt status bits in CRX_INT.
                                                                     0 = no effect.
                                                                     1 = Interrupt Set. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crx_int_set_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crx_int_set_lnx cavm_cprix_cn4ipx_crx_int_set_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_INT_SET_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_INT_SET_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000820048ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRX_INT_SET_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRX_INT_SET_LNX(a,b,c) cavm_cprix_cn4ipx_crx_int_set_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRX_INT_SET_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRX_INT_SET_LNX(a,b,c) "CPRIX_CN4IPX_CRX_INT_SET_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRX_INT_SET_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRX_INT_SET_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_crx_int_sts_ln#
 *
 * CPRI CONN4 IP CPRI RX Interrupt Status Register
 */
union cavm_cprix_cn4ipx_crx_int_sts_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crx_int_sts_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t shadow_sync           : 1;  /**< [ 31: 31](RO/H) Shadow framer interrupt. The value of CPRI RX hyperframe counters (Z and BFN) have been updated. */
        uint32_t shadow_state          : 1;  /**< [ 30: 30](RO/H) Shadow framer interrupt. There has been a change of state in the CPRI RX state machine. */
        uint32_t shadow_lof            : 1;  /**< [ 29: 29](RO/H) Shadow framer interrupt. There has been a change in the value of the CRX_LOF status bit. */
        uint32_t shadow_los            : 1;  /**< [ 28: 28](RO/H) Shadow framer interrupt. There has been a change in the value of the CRX_LOS status bit. */
        uint32_t reserved_25_27        : 3;
        uint32_t hdlc_flag_ff          : 1;  /**< [ 24: 24](RO/H) 0xFF flag detected from received HDLC frame.
                                                                   0 = no interrupt.
                                                                   1 = interrupt. */
        uint32_t hdlc_flag_7f          : 1;  /**< [ 23: 23](RO/H) 0x7F flag detected from received HDLC frame. */
        uint32_t hdlc_flag_7e          : 1;  /**< [ 22: 22](RO/H) 0x7E flag detected from received HDLC frame. 0x7E is normal HDLC frame start/end
                                                                 flag and typically used to fill also HDLC interframe gaps. */
        uint32_t crx_tunnel_error      : 1;  /**< [ 21: 21](RO/H) CRX tunnel message has been discarded because of LCV */
        uint32_t axc_collision         : 1;  /**< [ 20: 20](RO/H) Collision detected in AxC configuration. More than one AxC is trying to write to
                                                                 AxC RAM at the same time. */
        uint32_t hdlc_overflow         : 1;  /**< [ 19: 19](RO/H) HDLC buffer overflow indicator. */
        uint32_t hdlc_subframe_received : 1; /**< [ 18: 18](RO/H) Reception of one HDLC subframe. */
        uint32_t meas_transfer_err     : 1;  /**< [ 17: 17](RO/H) Measurement message transmission error status. New message completed before
                                                                 previous message was sent. */
        uint32_t sdvm_error            : 1;  /**< [ 16: 16](RO/H) SDVM control message was discarded because a parity error occurred during reception. */
        uint32_t crx_l1_protocol_ver_int : 1;/**< [ 15: 15](RO/H) There has been a change in the value of  the received  CRX_L1_PROTOCOL_VER.. */
        uint32_t crx_l1_eth_ctrl_int   : 1;  /**< [ 14: 14](RO/H) There has been a change in the value of  the received  CRX_L1_ETH_CTRL. */
        uint32_t crx_l1_hdlc_ctrl_int  : 1;  /**< [ 13: 13](RO/H) There has been a change in the value of  the received  CRX_L1_HDLC_CTRL. */
        uint32_t crx_l1_lof_int        : 1;  /**< [ 12: 12](RO/H) There has been a change in the value of  the received  CRX_L1_LOF. */
        uint32_t crx_l1_los_int        : 1;  /**< [ 11: 11](RO/H) There has been a change in the value of  the received  CRX_L1_LOS. */
        uint32_t crx_l1_sdi_int        : 1;  /**< [ 10: 10](RO/H) There has been a change in the value of  the received  CRX_L1_SDI. */
        uint32_t crx_l1_rai_int        : 1;  /**< [  9:  9](RO/H) There has been a change in the value of  the received CRX_L1_RAI. */
        uint32_t crx_l1_reset_int      : 1;  /**< [  8:  8](RO/H) There has been a change in the value of  the received  CRX_L1_RESET. */
        uint32_t reserved_6_7          : 2;
        uint32_t eth_esd_err           : 1;  /**< [  5:  5](RO/H) Two SSD pattern detected with no ESD pattern between in Ethernet reception. */
        uint32_t crx_ckfifo_err        : 1;  /**< [  4:  4](RO/H) There has been an under/overflow in CRX clock crossing FIFO. */
        uint32_t crx_sync_int          : 1;  /**< [  3:  3](RO/H) The value of CPRI RX hyperframe counters (Z and BFN) have been updated. */
        uint32_t crx_state_int         : 1;  /**< [  2:  2](RO/H) There has been a change of state in the CPRI RX state machine. */
        uint32_t crx_lof_int           : 1;  /**< [  1:  1](RO/H) There has been a change in the value of the CRX_LOF status bit. */
        uint32_t crx_los_int           : 1;  /**< [  0:  0](RO/H) There has been a change in the value of the CRX_LOS status bit. */
#else /* Word 0 - Little Endian */
        uint32_t crx_los_int           : 1;  /**< [  0:  0](RO/H) There has been a change in the value of the CRX_LOS status bit. */
        uint32_t crx_lof_int           : 1;  /**< [  1:  1](RO/H) There has been a change in the value of the CRX_LOF status bit. */
        uint32_t crx_state_int         : 1;  /**< [  2:  2](RO/H) There has been a change of state in the CPRI RX state machine. */
        uint32_t crx_sync_int          : 1;  /**< [  3:  3](RO/H) The value of CPRI RX hyperframe counters (Z and BFN) have been updated. */
        uint32_t crx_ckfifo_err        : 1;  /**< [  4:  4](RO/H) There has been an under/overflow in CRX clock crossing FIFO. */
        uint32_t eth_esd_err           : 1;  /**< [  5:  5](RO/H) Two SSD pattern detected with no ESD pattern between in Ethernet reception. */
        uint32_t reserved_6_7          : 2;
        uint32_t crx_l1_reset_int      : 1;  /**< [  8:  8](RO/H) There has been a change in the value of  the received  CRX_L1_RESET. */
        uint32_t crx_l1_rai_int        : 1;  /**< [  9:  9](RO/H) There has been a change in the value of  the received CRX_L1_RAI. */
        uint32_t crx_l1_sdi_int        : 1;  /**< [ 10: 10](RO/H) There has been a change in the value of  the received  CRX_L1_SDI. */
        uint32_t crx_l1_los_int        : 1;  /**< [ 11: 11](RO/H) There has been a change in the value of  the received  CRX_L1_LOS. */
        uint32_t crx_l1_lof_int        : 1;  /**< [ 12: 12](RO/H) There has been a change in the value of  the received  CRX_L1_LOF. */
        uint32_t crx_l1_hdlc_ctrl_int  : 1;  /**< [ 13: 13](RO/H) There has been a change in the value of  the received  CRX_L1_HDLC_CTRL. */
        uint32_t crx_l1_eth_ctrl_int   : 1;  /**< [ 14: 14](RO/H) There has been a change in the value of  the received  CRX_L1_ETH_CTRL. */
        uint32_t crx_l1_protocol_ver_int : 1;/**< [ 15: 15](RO/H) There has been a change in the value of  the received  CRX_L1_PROTOCOL_VER.. */
        uint32_t sdvm_error            : 1;  /**< [ 16: 16](RO/H) SDVM control message was discarded because a parity error occurred during reception. */
        uint32_t meas_transfer_err     : 1;  /**< [ 17: 17](RO/H) Measurement message transmission error status. New message completed before
                                                                 previous message was sent. */
        uint32_t hdlc_subframe_received : 1; /**< [ 18: 18](RO/H) Reception of one HDLC subframe. */
        uint32_t hdlc_overflow         : 1;  /**< [ 19: 19](RO/H) HDLC buffer overflow indicator. */
        uint32_t axc_collision         : 1;  /**< [ 20: 20](RO/H) Collision detected in AxC configuration. More than one AxC is trying to write to
                                                                 AxC RAM at the same time. */
        uint32_t crx_tunnel_error      : 1;  /**< [ 21: 21](RO/H) CRX tunnel message has been discarded because of LCV */
        uint32_t hdlc_flag_7e          : 1;  /**< [ 22: 22](RO/H) 0x7E flag detected from received HDLC frame. 0x7E is normal HDLC frame start/end
                                                                 flag and typically used to fill also HDLC interframe gaps. */
        uint32_t hdlc_flag_7f          : 1;  /**< [ 23: 23](RO/H) 0x7F flag detected from received HDLC frame. */
        uint32_t hdlc_flag_ff          : 1;  /**< [ 24: 24](RO/H) 0xFF flag detected from received HDLC frame.
                                                                   0 = no interrupt.
                                                                   1 = interrupt. */
        uint32_t reserved_25_27        : 3;
        uint32_t shadow_los            : 1;  /**< [ 28: 28](RO/H) Shadow framer interrupt. There has been a change in the value of the CRX_LOS status bit. */
        uint32_t shadow_lof            : 1;  /**< [ 29: 29](RO/H) Shadow framer interrupt. There has been a change in the value of the CRX_LOF status bit. */
        uint32_t shadow_state          : 1;  /**< [ 30: 30](RO/H) Shadow framer interrupt. There has been a change of state in the CPRI RX state machine. */
        uint32_t shadow_sync           : 1;  /**< [ 31: 31](RO/H) Shadow framer interrupt. The value of CPRI RX hyperframe counters (Z and BFN) have been updated. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crx_int_sts_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crx_int_sts_lnx cavm_cprix_cn4ipx_crx_int_sts_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_INT_STS_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_INT_STS_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000820040ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRX_INT_STS_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRX_INT_STS_LNX(a,b,c) cavm_cprix_cn4ipx_crx_int_sts_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRX_INT_STS_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRX_INT_STS_LNX(a,b,c) "CPRIX_CN4IPX_CRX_INT_STS_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRX_INT_STS_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRX_INT_STS_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_crx_l1_status_ln#
 *
 * CPRI CONN4 IP CPRI RX L1 Inband Protocol Status Register
 */
union cavm_cprix_cn4ipx_crx_l1_status_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crx_l1_status_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t crx_l1_protocol_ver   : 8;  /**< [ 23: 16](RO/H) Received CPRI protocol version. */
        uint32_t reserved_14_15        : 2;
        uint32_t crx_l1_eth_ctrl       : 6;  /**< [ 13:  8](RO/H) Received Ethernet subchannel control.
                                                                   0x0       = no Ethernet.
                                                                   0x13-0x1  = invalid.
                                                                   0x3F-0x14 = start of Ethernet channel. */
        uint32_t crx_l1_hdlc_ctrl      : 3;  /**< [  7:  5](RO/H) Received HDLC bit rate control.
                                                                   0x0 = No HDLC.
                                                                   0x1 = 240 kbit/s.
                                                                   0x2 = 480 kbit/s.
                                                                   0x3 = 960 kbit/s.
                                                                   0x4 = 1920 kbit/s.
                                                                   0x5 = 2400 kbit/s.
                                                                   0x6 = highest possible
                                                                 NOTE: SW has to select the correct rate depending on the CPRI line rate.
                                                                   0x7 = negotiated on higher layer. */
        uint32_t crx_l1_lof            : 1;  /**< [  4:  4](RO/H) Received LOF notification. */
        uint32_t crx_l1_los            : 1;  /**< [  3:  3](RO/H) Received LOS notification. */
        uint32_t crx_l1_sdi            : 1;  /**< [  2:  2](RO/H) Received SDI notification. */
        uint32_t crx_l1_rai            : 1;  /**< [  1:  1](RO/H) Received RAI notification. */
        uint32_t crx_l1_reset          : 1;  /**< [  0:  0](RO/H) Received Reset notification. */
#else /* Word 0 - Little Endian */
        uint32_t crx_l1_reset          : 1;  /**< [  0:  0](RO/H) Received Reset notification. */
        uint32_t crx_l1_rai            : 1;  /**< [  1:  1](RO/H) Received RAI notification. */
        uint32_t crx_l1_sdi            : 1;  /**< [  2:  2](RO/H) Received SDI notification. */
        uint32_t crx_l1_los            : 1;  /**< [  3:  3](RO/H) Received LOS notification. */
        uint32_t crx_l1_lof            : 1;  /**< [  4:  4](RO/H) Received LOF notification. */
        uint32_t crx_l1_hdlc_ctrl      : 3;  /**< [  7:  5](RO/H) Received HDLC bit rate control.
                                                                   0x0 = No HDLC.
                                                                   0x1 = 240 kbit/s.
                                                                   0x2 = 480 kbit/s.
                                                                   0x3 = 960 kbit/s.
                                                                   0x4 = 1920 kbit/s.
                                                                   0x5 = 2400 kbit/s.
                                                                   0x6 = highest possible
                                                                 NOTE: SW has to select the correct rate depending on the CPRI line rate.
                                                                   0x7 = negotiated on higher layer. */
        uint32_t crx_l1_eth_ctrl       : 6;  /**< [ 13:  8](RO/H) Received Ethernet subchannel control.
                                                                   0x0       = no Ethernet.
                                                                   0x13-0x1  = invalid.
                                                                   0x3F-0x14 = start of Ethernet channel. */
        uint32_t reserved_14_15        : 2;
        uint32_t crx_l1_protocol_ver   : 8;  /**< [ 23: 16](RO/H) Received CPRI protocol version. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crx_l1_status_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crx_l1_status_lnx cavm_cprix_cn4ipx_crx_l1_status_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_L1_STATUS_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_L1_STATUS_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x86400082000cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRX_L1_STATUS_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRX_L1_STATUS_LNX(a,b,c) cavm_cprix_cn4ipx_crx_l1_status_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRX_L1_STATUS_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRX_L1_STATUS_LNX(a,b,c) "CPRIX_CN4IPX_CRX_L1_STATUS_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRX_L1_STATUS_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRX_L1_STATUS_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_crx_mf_meas_ln#
 *
 * CPRI CONN4 IP CPRI RX MF Measurement Register
 */
union cavm_cprix_cn4ipx_crx_mf_meas_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crx_mf_meas_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t crx_mf_meas           : 24; /**< [ 23:  0](RO/H) Captured N2 value of the BCN_N1_N2. Two LSbs are always zero. */
#else /* Word 0 - Little Endian */
        uint32_t crx_mf_meas           : 24; /**< [ 23:  0](RO/H) Captured N2 value of the BCN_N1_N2. Two LSbs are always zero. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crx_mf_meas_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crx_mf_meas_lnx cavm_cprix_cn4ipx_crx_mf_meas_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_MF_MEAS_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_MF_MEAS_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000820008ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRX_MF_MEAS_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRX_MF_MEAS_LNX(a,b,c) cavm_cprix_cn4ipx_crx_mf_meas_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRX_MF_MEAS_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRX_MF_MEAS_LNX(a,b,c) "CPRIX_CN4IPX_CRX_MF_MEAS_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRX_MF_MEAS_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRX_MF_MEAS_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_crx_sdvm_ns_ln#
 *
 * CPRI CONN4 IP CPRI RX SDVM Control Tunnel Subchannel Register
 */
union cavm_cprix_cn4ipx_crx_sdvm_ns_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crx_sdvm_ns_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_17_31        : 15;
        uint32_t tunnel_enable         : 1;  /**< [ 16: 16](R/W) Tunneling enable.
                                                                   0 = disabled.
                                                                   1 = enabled. */
        uint32_t reserved_15           : 1;
        uint32_t type_msbs             : 3;  /**< [ 14: 12](R/W) Three most significant bits of header field Type for decompressed RP3 messages. */
        uint32_t reserved_10_11        : 2;
        uint32_t rate                  : 2;  /**< [  9:  8](R/W) Tunneling rate.
                                                                   0 = Quarter i.e. NS.
                                                                   1 = Half i.e. NS, NS+1.
                                                                   2 = Full i.e. NS, NS+1, NS+2, NS+3.
                                                                   3 = reserved.

                                                                 Note: Quarter rate is not supported at CPRI 10x line rate. */
        uint32_t reserved_6_7          : 2;
        uint32_t ns_s                  : 6;  /**< [  5:  0](R/W) Index of base CPRI subchannel within range 0 to 63. */
#else /* Word 0 - Little Endian */
        uint32_t ns_s                  : 6;  /**< [  5:  0](R/W) Index of base CPRI subchannel within range 0 to 63. */
        uint32_t reserved_6_7          : 2;
        uint32_t rate                  : 2;  /**< [  9:  8](R/W) Tunneling rate.
                                                                   0 = Quarter i.e. NS.
                                                                   1 = Half i.e. NS, NS+1.
                                                                   2 = Full i.e. NS, NS+1, NS+2, NS+3.
                                                                   3 = reserved.

                                                                 Note: Quarter rate is not supported at CPRI 10x line rate. */
        uint32_t reserved_10_11        : 2;
        uint32_t type_msbs             : 3;  /**< [ 14: 12](R/W) Three most significant bits of header field Type for decompressed RP3 messages. */
        uint32_t reserved_15           : 1;
        uint32_t tunnel_enable         : 1;  /**< [ 16: 16](R/W) Tunneling enable.
                                                                   0 = disabled.
                                                                   1 = enabled. */
        uint32_t reserved_17_31        : 15;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crx_sdvm_ns_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crx_sdvm_ns_lnx cavm_cprix_cn4ipx_crx_sdvm_ns_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_SDVM_NS_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_SDVM_NS_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000820020ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRX_SDVM_NS_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRX_SDVM_NS_LNX(a,b,c) cavm_cprix_cn4ipx_crx_sdvm_ns_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRX_SDVM_NS_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRX_SDVM_NS_LNX(a,b,c) "CPRIX_CN4IPX_CRX_SDVM_NS_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRX_SDVM_NS_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRX_SDVM_NS_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_crx_shadow_ln#
 *
 * CPRI CONN4 IP CPRI RX Shadow Framer Register
 */
union cavm_cprix_cn4ipx_crx_shadow_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crx_shadow_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t distance              : 16; /**< [ 31: 16](RO/H) Measured distance from CRX Shadow Hyperframe start to CRX Frame Hyperframe start.
                                                                 Unit is clock cycle. Distance saturates to maximum. Value is unsigned.
                                                                 Counter is reset when field ENABLE is deasserted.
                                                                   0 .. 0xFFFF = valid. */
        uint32_t enable                : 1;  /**< [ 15: 15](R/W) Enable CRX Shadow Framer scheme. When used, shadow framing should be enabled
                                                                 after frame synchronization has been reached i.e. CRX Main Framer is in HFNSYNC
                                                                 state and there is no LOF or LOS.
                                                                 When enabled, CRX Main Framer, state of which is shown by CRX_STATE, does not
                                                                 leave HFNSYNC state in LOF or LOS and remains forwarding null reception data.
                                                                 CRX Shadow Framer, state of which is shown by this register, receives line data.
                                                                 Distance between frame times of the frames is shown in fields CRX_STS:DISTANCE
                                                                 and CRX_SHADOW:DISTANCE.
                                                                   0 = disable.
                                                                   1 = enable. */
        uint32_t reserved_5_14         : 10;
        uint32_t crx_state             : 3;  /**< [  4:  2](RO/H) Current state of the CPRI RX shadow Framer state machine.
                                                                   0x0 = XACQ1.
                                                                   0x1 = XACQ2.
                                                                   0x2 = XSYNC1.
                                                                   0x3 = XSYNC2
                                                                   0x4 = HFNSYNC.
                                                                   0x7-0x5 = Not used. */
        uint32_t crx_lof               : 1;  /**< [  1:  1](RO/H) Loss of frame status bit at the CPRI RX Shadow Framer.
                                                                   0 = Loss of Frame not active.
                                                                   1 = Loss of Frame active. */
        uint32_t crx_los               : 1;  /**< [  0:  0](RO/H) Loss of signal status bit at the CPRI RX Shadow Framer.
                                                                   0 = Loss of Signal not active.
                                                                   1 = Loss of Signal active. */
#else /* Word 0 - Little Endian */
        uint32_t crx_los               : 1;  /**< [  0:  0](RO/H) Loss of signal status bit at the CPRI RX Shadow Framer.
                                                                   0 = Loss of Signal not active.
                                                                   1 = Loss of Signal active. */
        uint32_t crx_lof               : 1;  /**< [  1:  1](RO/H) Loss of frame status bit at the CPRI RX Shadow Framer.
                                                                   0 = Loss of Frame not active.
                                                                   1 = Loss of Frame active. */
        uint32_t crx_state             : 3;  /**< [  4:  2](RO/H) Current state of the CPRI RX shadow Framer state machine.
                                                                   0x0 = XACQ1.
                                                                   0x1 = XACQ2.
                                                                   0x2 = XSYNC1.
                                                                   0x3 = XSYNC2
                                                                   0x4 = HFNSYNC.
                                                                   0x7-0x5 = Not used. */
        uint32_t reserved_5_14         : 10;
        uint32_t enable                : 1;  /**< [ 15: 15](R/W) Enable CRX Shadow Framer scheme. When used, shadow framing should be enabled
                                                                 after frame synchronization has been reached i.e. CRX Main Framer is in HFNSYNC
                                                                 state and there is no LOF or LOS.
                                                                 When enabled, CRX Main Framer, state of which is shown by CRX_STATE, does not
                                                                 leave HFNSYNC state in LOF or LOS and remains forwarding null reception data.
                                                                 CRX Shadow Framer, state of which is shown by this register, receives line data.
                                                                 Distance between frame times of the frames is shown in fields CRX_STS:DISTANCE
                                                                 and CRX_SHADOW:DISTANCE.
                                                                   0 = disable.
                                                                   1 = enable. */
        uint32_t distance              : 16; /**< [ 31: 16](RO/H) Measured distance from CRX Shadow Hyperframe start to CRX Frame Hyperframe start.
                                                                 Unit is clock cycle. Distance saturates to maximum. Value is unsigned.
                                                                 Counter is reset when field ENABLE is deasserted.
                                                                   0 .. 0xFFFF = valid. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crx_shadow_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crx_shadow_lnx cavm_cprix_cn4ipx_crx_shadow_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_SHADOW_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_SHADOW_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x86400082003cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRX_SHADOW_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRX_SHADOW_LNX(a,b,c) cavm_cprix_cn4ipx_crx_shadow_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRX_SHADOW_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRX_SHADOW_LNX(a,b,c) "CPRIX_CN4IPX_CRX_SHADOW_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRX_SHADOW_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRX_SHADOW_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_crx_sts_ln#
 *
 * CPRI CONN4 IP CPRI RX Framer Status Register
 */
union cavm_cprix_cn4ipx_crx_sts_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crx_sts_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t distance              : 16; /**< [ 31: 16](RO/H) Measured distance from CRX Framer Hyperframe start to CRX Shadow Hyperframe start.
                                                                 Unit is clock cycle. Distance saturates to maximum. Value is unsigned.
                                                                 Counter is reset when field CRX_SHADOW:ENABLE is deasserted.
                                                                   0 .. 0xFFFF = valid. */
        uint32_t reserved_5_15         : 11;
        uint32_t crx_state             : 3;  /**< [  4:  2](RO/H) Current state of the CPRI RX state machine.
                                                                   0x0 = XACQ1.
                                                                   0x1 = XACQ2.
                                                                   0x2 = XSYNC1.
                                                                   0x3 = XSYNC2.
                                                                   0x4 = HFNSYNC.
                                                                   0x5-0x7 = Not used. */
        uint32_t crx_lof               : 1;  /**< [  1:  1](RO/H) Loss of frame status bit.
                                                                   0 = Loss of Frame not active.
                                                                   1 = Loss of Frame active. */
        uint32_t crx_los               : 1;  /**< [  0:  0](RO/H) Loss of signal status bit.
                                                                   0 = Loss of Signal not active.
                                                                   1 = Loss of Signal active. */
#else /* Word 0 - Little Endian */
        uint32_t crx_los               : 1;  /**< [  0:  0](RO/H) Loss of signal status bit.
                                                                   0 = Loss of Signal not active.
                                                                   1 = Loss of Signal active. */
        uint32_t crx_lof               : 1;  /**< [  1:  1](RO/H) Loss of frame status bit.
                                                                   0 = Loss of Frame not active.
                                                                   1 = Loss of Frame active. */
        uint32_t crx_state             : 3;  /**< [  4:  2](RO/H) Current state of the CPRI RX state machine.
                                                                   0x0 = XACQ1.
                                                                   0x1 = XACQ2.
                                                                   0x2 = XSYNC1.
                                                                   0x3 = XSYNC2.
                                                                   0x4 = HFNSYNC.
                                                                   0x5-0x7 = Not used. */
        uint32_t reserved_5_15         : 11;
        uint32_t distance              : 16; /**< [ 31: 16](RO/H) Measured distance from CRX Framer Hyperframe start to CRX Shadow Hyperframe start.
                                                                 Unit is clock cycle. Distance saturates to maximum. Value is unsigned.
                                                                 Counter is reset when field CRX_SHADOW:ENABLE is deasserted.
                                                                   0 .. 0xFFFF = valid. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crx_sts_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crx_sts_lnx cavm_cprix_cn4ipx_crx_sts_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_STS_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_STS_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000820004ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRX_STS_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRX_STS_LNX(a,b,c) cavm_cprix_cn4ipx_crx_sts_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRX_STS_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRX_STS_LNX(a,b,c) "CPRIX_CN4IPX_CRX_STS_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRX_STS_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRX_STS_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_crx_trace_ln#
 *
 * CPRI CONN4 IP CPRI RX Trace Control Register
 */
union cavm_cprix_cn4ipx_crx_trace_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crx_trace_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t select                : 1;  /**< [  1:  1](R/W) Select whether trace data is before or after descrambling.
                                                                   0 = after descrambling.
                                                                   1 = before descrambling. */
        uint32_t enable                : 1;  /**< [  0:  0](R/W) Enable transport of trace data to RP3 UL interface.
                                                                   0 = disable.
                                                                   1 = enable.
                                                                 Please note: only one test port source can be enabled at a time. */
#else /* Word 0 - Little Endian */
        uint32_t enable                : 1;  /**< [  0:  0](R/W) Enable transport of trace data to RP3 UL interface.
                                                                   0 = disable.
                                                                   1 = enable.
                                                                 Please note: only one test port source can be enabled at a time. */
        uint32_t select                : 1;  /**< [  1:  1](R/W) Select whether trace data is before or after descrambling.
                                                                   0 = after descrambling.
                                                                   1 = before descrambling. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crx_trace_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crx_trace_lnx cavm_cprix_cn4ipx_crx_trace_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_TRACE_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_TRACE_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000820038ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRX_TRACE_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRX_TRACE_LNX(a,b,c) cavm_cprix_cn4ipx_crx_trace_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRX_TRACE_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRX_TRACE_LNX(a,b,c) "CPRIX_CN4IPX_CRX_TRACE_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRX_TRACE_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRX_TRACE_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_crx_tst_errcnt_ln#
 *
 * CPRI CONN4 IP CPRI RX Test Mode Error Counter Register
 */
union cavm_cprix_cn4ipx_crx_tst_errcnt_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crx_tst_errcnt_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t test_err_count        : 32; /**< [ 31:  0](R/W/H) Number of erroneous samples detected during test payload checking.
                                                                 Counter saturates at max value.
                                                                 Counter is reset by writing '0' to bit 0. */
#else /* Word 0 - Little Endian */
        uint32_t test_err_count        : 32; /**< [ 31:  0](R/W/H) Number of erroneous samples detected during test payload checking.
                                                                 Counter saturates at max value.
                                                                 Counter is reset by writing '0' to bit 0. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crx_tst_errcnt_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crx_tst_errcnt_lnx cavm_cprix_cn4ipx_crx_tst_errcnt_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_TST_ERRCNT_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_TST_ERRCNT_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000820018ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRX_TST_ERRCNT_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRX_TST_ERRCNT_LNX(a,b,c) cavm_cprix_cn4ipx_crx_tst_errcnt_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRX_TST_ERRCNT_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRX_TST_ERRCNT_LNX(a,b,c) "CPRIX_CN4IPX_CRX_TST_ERRCNT_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRX_TST_ERRCNT_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRX_TST_ERRCNT_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_crx_tst_frmcnt_ln#
 *
 * CPRI CONN4 IP CPRI RX Test Mode Frame Counter Register
 */
union cavm_cprix_cn4ipx_crx_tst_frmcnt_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crx_tst_frmcnt_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t test_frame_count      : 32; /**< [ 31:  0](R/W/H) The number of 10ms CPRI frames that test payload checking has been active.
                                                                 Counter starts counting when any of the AxCs has test mode enabled.
                                                                 Counter saturates at max value.
                                                                 Counter is reset by writing '0' to bit 0. */
#else /* Word 0 - Little Endian */
        uint32_t test_frame_count      : 32; /**< [ 31:  0](R/W/H) The number of 10ms CPRI frames that test payload checking has been active.
                                                                 Counter starts counting when any of the AxCs has test mode enabled.
                                                                 Counter saturates at max value.
                                                                 Counter is reset by writing '0' to bit 0. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crx_tst_frmcnt_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crx_tst_frmcnt_lnx cavm_cprix_cn4ipx_crx_tst_frmcnt_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_TST_FRMCNT_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_TST_FRMCNT_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000820014ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRX_TST_FRMCNT_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRX_TST_FRMCNT_LNX(a,b,c) cavm_cprix_cn4ipx_crx_tst_frmcnt_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRX_TST_FRMCNT_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRX_TST_FRMCNT_LNX(a,b,c) "CPRIX_CN4IPX_CRX_TST_FRMCNT_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRX_TST_FRMCNT_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRX_TST_FRMCNT_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_crx_tst_ovfsts_ln#
 *
 * CPRI CONN4 IP CPRI RX Test Mode and Overflow Status Register
 */
union cavm_cprix_cn4ipx_crx_tst_ovfsts_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crx_tst_ovfsts_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_22_31        : 10;
        uint32_t axc_ovf_num           : 6;  /**< [ 21: 16](RO/H) The number of the AxC which caused AXC_OVF interrupt. */
        uint32_t test_sample           : 16; /**< [ 15:  0](RO/H) Q component of the first 16-bit IQ sample after start of air interface for a selected AxC.
                                                                 AxC selection is done with bit AIR_START_SAMPLE. */
#else /* Word 0 - Little Endian */
        uint32_t test_sample           : 16; /**< [ 15:  0](RO/H) Q component of the first 16-bit IQ sample after start of air interface for a selected AxC.
                                                                 AxC selection is done with bit AIR_START_SAMPLE. */
        uint32_t axc_ovf_num           : 6;  /**< [ 21: 16](RO/H) The number of the AxC which caused AXC_OVF interrupt. */
        uint32_t reserved_22_31        : 10;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crx_tst_ovfsts_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crx_tst_ovfsts_lnx cavm_cprix_cn4ipx_crx_tst_ovfsts_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_TST_OVFSTS_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_TST_OVFSTS_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000820010ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRX_TST_OVFSTS_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRX_TST_OVFSTS_LNX(a,b,c) cavm_cprix_cn4ipx_crx_tst_ovfsts_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRX_TST_OVFSTS_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRX_TST_OVFSTS_LNX(a,b,c) "CPRIX_CN4IPX_CRX_TST_OVFSTS_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRX_TST_OVFSTS_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRX_TST_OVFSTS_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_crx_tunn_#_cpri_ln#
 *
 * CPRI CONN4 IP CPRI RX Tunnel CPRI Frame Configuration 0 to 15 Register
 */
union cavm_cprix_cn4ipx_crx_tunn_x_cpri_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crx_tunn_x_cpri_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t enable                : 1;  /**< [ 31: 31](R/W) Reception Enable. */
        uint32_t reserved_29_30        : 2;
        uint32_t yh                    : 1;  /**< [ 28: 28](R/W) Byte coordinate Y selection.
                                                                   0 = bytes 0 to 7 of CPRI word.
                                                                   1 = bytes 8 to 15 of CPRI word. */
        uint32_t xs_3                  : 1;  /**< [ 27: 27](R/W) Enable bit for Xs == 3.
                                                                   0 = disabled.
                                                                   1 = enabled. */
        uint32_t xs_2                  : 1;  /**< [ 26: 26](R/W) Enable bit for Xs == 2. */
        uint32_t xs_1                  : 1;  /**< [ 25: 25](R/W) Enable bit for Xs == 1. */
        uint32_t xs_0                  : 1;  /**< [ 24: 24](R/W) Enable bit for Xs == 0. */
        uint32_t reserved_22_23        : 2;
        uint32_t ns_s                  : 6;  /**< [ 21: 16](R/W) Subchannel coordinate Ns.
                                                                      0 .. 0x3F = valid. */
        uint32_t index                 : 8;  /**< [ 15:  8](R/W) Index for Hyperframe coordinate Z. Hyperframe coordinate matches when index is
                                                                 equal to the value of the modulo counter.
                                                                    0 .. 0xff = valid. */
        uint32_t modulo                : 8;  /**< [  7:  0](R/W) Modulo value for modulo counter for Hyperframe coordinate Z.
                                                                     0 = disabled.
                                                                     1 .. 0xff = valid. */
#else /* Word 0 - Little Endian */
        uint32_t modulo                : 8;  /**< [  7:  0](R/W) Modulo value for modulo counter for Hyperframe coordinate Z.
                                                                     0 = disabled.
                                                                     1 .. 0xff = valid. */
        uint32_t index                 : 8;  /**< [ 15:  8](R/W) Index for Hyperframe coordinate Z. Hyperframe coordinate matches when index is
                                                                 equal to the value of the modulo counter.
                                                                    0 .. 0xff = valid. */
        uint32_t ns_s                  : 6;  /**< [ 21: 16](R/W) Subchannel coordinate Ns.
                                                                      0 .. 0x3F = valid. */
        uint32_t reserved_22_23        : 2;
        uint32_t xs_0                  : 1;  /**< [ 24: 24](R/W) Enable bit for Xs == 0. */
        uint32_t xs_1                  : 1;  /**< [ 25: 25](R/W) Enable bit for Xs == 1. */
        uint32_t xs_2                  : 1;  /**< [ 26: 26](R/W) Enable bit for Xs == 2. */
        uint32_t xs_3                  : 1;  /**< [ 27: 27](R/W) Enable bit for Xs == 3.
                                                                   0 = disabled.
                                                                   1 = enabled. */
        uint32_t yh                    : 1;  /**< [ 28: 28](R/W) Byte coordinate Y selection.
                                                                   0 = bytes 0 to 7 of CPRI word.
                                                                   1 = bytes 8 to 15 of CPRI word. */
        uint32_t reserved_29_30        : 2;
        uint32_t enable                : 1;  /**< [ 31: 31](R/W) Reception Enable. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crx_tunn_x_cpri_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crx_tunn_x_cpri_lnx cavm_cprix_cn4ipx_crx_tunn_x_cpri_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_TUNN_X_CPRI_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_TUNN_X_CPRI_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=15) && (d<=1)))
        return 0x864000820180ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 8ll * ((c) & 0xf) + 0x10000ll * ((d) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRX_TUNN_X_CPRI_LNX", 4, a, b, c, d, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRX_TUNN_X_CPRI_LNX(a,b,c,d) cavm_cprix_cn4ipx_crx_tunn_x_cpri_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRX_TUNN_X_CPRI_LNX(a,b,c,d) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRX_TUNN_X_CPRI_LNX(a,b,c,d) "CPRIX_CN4IPX_CRX_TUNN_X_CPRI_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRX_TUNN_X_CPRI_LNX(a,b,c,d) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRX_TUNN_X_CPRI_LNX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) cpri#_cn4ip#_crx_tunn_#_rp3_ln#
 *
 * CPRI CONN4 IP CPRI RX Tunnel RP3 Frame Configuration 0 to 15 Register
 */
union cavm_cprix_cn4ipx_crx_tunn_x_rp3_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crx_tunn_x_rp3_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t address               : 13; /**< [ 31: 19](R/W) RP3 message target node address. */
        uint32_t type_s                : 5;  /**< [ 18: 14](R/W) RP3 message type. */
        uint32_t reserved_10_13        : 4;
        uint32_t mode                  : 2;  /**< [  9:  8](R/W) Trigger mode for receiving CPRI data and composing an RP3 message.
                                                                   0 = receive always.
                                                                   1 = receive if unmasked data is non-zero.
                                                                   2 = receive if unmasked data has changed.
                                                                   3 = never receive. */
        uint32_t byte_7                : 1;  /**< [  7:  7](R/W) Trigger mask for byte 7.
                                                                   0 = not masked.
                                                                   1 = masked. */
        uint32_t byte_6                : 1;  /**< [  6:  6](R/W) Trigger mask for byte 6. */
        uint32_t byte_5                : 1;  /**< [  5:  5](R/W) Trigger mask for byte 5. */
        uint32_t byte_4                : 1;  /**< [  4:  4](R/W) Trigger mask for byte 4. */
        uint32_t byte_3                : 1;  /**< [  3:  3](R/W) Trigger mask for byte 3. */
        uint32_t byte_2                : 1;  /**< [  2:  2](R/W) Trigger mask for byte 2. */
        uint32_t byte_1                : 1;  /**< [  1:  1](R/W) Trigger mask for byte 1. */
        uint32_t byte_0                : 1;  /**< [  0:  0](R/W) Trigger mask for byte 0. */
#else /* Word 0 - Little Endian */
        uint32_t byte_0                : 1;  /**< [  0:  0](R/W) Trigger mask for byte 0. */
        uint32_t byte_1                : 1;  /**< [  1:  1](R/W) Trigger mask for byte 1. */
        uint32_t byte_2                : 1;  /**< [  2:  2](R/W) Trigger mask for byte 2. */
        uint32_t byte_3                : 1;  /**< [  3:  3](R/W) Trigger mask for byte 3. */
        uint32_t byte_4                : 1;  /**< [  4:  4](R/W) Trigger mask for byte 4. */
        uint32_t byte_5                : 1;  /**< [  5:  5](R/W) Trigger mask for byte 5. */
        uint32_t byte_6                : 1;  /**< [  6:  6](R/W) Trigger mask for byte 6. */
        uint32_t byte_7                : 1;  /**< [  7:  7](R/W) Trigger mask for byte 7.
                                                                   0 = not masked.
                                                                   1 = masked. */
        uint32_t mode                  : 2;  /**< [  9:  8](R/W) Trigger mode for receiving CPRI data and composing an RP3 message.
                                                                   0 = receive always.
                                                                   1 = receive if unmasked data is non-zero.
                                                                   2 = receive if unmasked data has changed.
                                                                   3 = never receive. */
        uint32_t reserved_10_13        : 4;
        uint32_t type_s                : 5;  /**< [ 18: 14](R/W) RP3 message type. */
        uint32_t address               : 13; /**< [ 31: 19](R/W) RP3 message target node address. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crx_tunn_x_rp3_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crx_tunn_x_rp3_lnx cavm_cprix_cn4ipx_crx_tunn_x_rp3_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_TUNN_X_RP3_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_TUNN_X_RP3_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=15) && (d<=1)))
        return 0x864000820184ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 8ll * ((c) & 0xf) + 0x10000ll * ((d) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRX_TUNN_X_RP3_LNX", 4, a, b, c, d, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRX_TUNN_X_RP3_LNX(a,b,c,d) cavm_cprix_cn4ipx_crx_tunn_x_rp3_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRX_TUNN_X_RP3_LNX(a,b,c,d) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRX_TUNN_X_RP3_LNX(a,b,c,d) "CPRIX_CN4IPX_CRX_TUNN_X_RP3_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRX_TUNN_X_RP3_LNX(a,b,c,d) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRX_TUNN_X_RP3_LNX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) cpri#_cn4ip#_crx_ulaw_gen_ln#
 *
 * CPRI CONN4 IP CPRI RX uLAW General Configuration Register
 */
union cavm_cprix_cn4ipx_crx_ulaw_gen_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crx_ulaw_gen_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t alignment             : 1;  /**< [  2:  2](R/W) Alignment of IQ samples when converting from CPRI to RP3. The following is true
                                                                 for a sample after a conversion to RP3:
                                                                   0 = LSb equals zero (as in Murkku2).
                                                                   1 = MSb equals sign. */
        uint32_t dual                  : 1;  /**< [  1:  1](RO/H) Enable use of primary and secondary Stream Router interface. Constantly enabled. */
        uint32_t decompress            : 1;  /**< [  0:  0](R/W) Enable status of IQ decompressor. IQ decompressor should be enabled when any
                                                                 carrier has decompression enabled.
                                                                   0 = disabled.
                                                                   1 = enabled.
                                                                 CRX Law lookup table can only be read by software when decompression is disabled. */
#else /* Word 0 - Little Endian */
        uint32_t decompress            : 1;  /**< [  0:  0](R/W) Enable status of IQ decompressor. IQ decompressor should be enabled when any
                                                                 carrier has decompression enabled.
                                                                   0 = disabled.
                                                                   1 = enabled.
                                                                 CRX Law lookup table can only be read by software when decompression is disabled. */
        uint32_t dual                  : 1;  /**< [  1:  1](RO/H) Enable use of primary and secondary Stream Router interface. Constantly enabled. */
        uint32_t alignment             : 1;  /**< [  2:  2](R/W) Alignment of IQ samples when converting from CPRI to RP3. The following is true
                                                                 for a sample after a conversion to RP3:
                                                                   0 = LSb equals zero (as in Murkku2).
                                                                   1 = MSb equals sign. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crx_ulaw_gen_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crx_ulaw_gen_lnx cavm_cprix_cn4ipx_crx_ulaw_gen_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_ULAW_GEN_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_ULAW_GEN_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000820024ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRX_ULAW_GEN_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRX_ULAW_GEN_LNX(a,b,c) cavm_cprix_cn4ipx_crx_ulaw_gen_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRX_ULAW_GEN_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRX_ULAW_GEN_LNX(a,b,c) "CPRIX_CN4IPX_CRX_ULAW_GEN_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRX_ULAW_GEN_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRX_ULAW_GEN_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_crx_ulaw_ram#_ln#
 *
 * CPRI CONN4 IP CPRI RX uLAW Lookup Ram Access Data Register
 */
union cavm_cprix_cn4ipx_crx_ulaw_ramx_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crx_ulaw_ramx_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_14_31        : 18;
        uint32_t data                  : 14; /**< [ 13:  0](R/W) Lookup RAM data word. Write and read accesses to this address are performed on the lookup RAM.
                                                                 CRX Law lookup table can only be read by software when compression is disabled
                                                                 by CRX_ULAW_GEN: DECOMPRESS. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 14; /**< [ 13:  0](R/W) Lookup RAM data word. Write and read accesses to this address are performed on the lookup RAM.
                                                                 CRX Law lookup table can only be read by software when compression is disabled
                                                                 by CRX_ULAW_GEN: DECOMPRESS. */
        uint32_t reserved_14_31        : 18;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crx_ulaw_ramx_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crx_ulaw_ramx_lnx cavm_cprix_cn4ipx_crx_ulaw_ramx_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_ULAW_RAMX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRX_ULAW_RAMX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=2047) && (d<=1)))
        return 0x864000824000ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 4ll * ((c) & 0x7ff) + 0x10000ll * ((d) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRX_ULAW_RAMX_LNX", 4, a, b, c, d, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRX_ULAW_RAMX_LNX(a,b,c,d) cavm_cprix_cn4ipx_crx_ulaw_ramx_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRX_ULAW_RAMX_LNX(a,b,c,d) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRX_ULAW_RAMX_LNX(a,b,c,d) "CPRIX_CN4IPX_CRX_ULAW_RAMX_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRX_ULAW_RAMX_LNX(a,b,c,d) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRX_ULAW_RAMX_LNX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) cpri#_cn4ip#_crxb_int_clr_ln#
 *
 * CPRI CONN4 IP CPRI RX Register Bank Interrupt Event Clear Register
 */
union cavm_cprix_cn4ipx_crxb_int_clr_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crxb_int_clr_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t bank_received_15      : 1;  /**< [ 15: 15](R/W1C/H) Clear for Interrupt BANK_RECEIVED_15.
                                                                   0 = No effect.
                                                                   1 = Interrupt clear. */
        uint32_t bank_received_14      : 1;  /**< [ 14: 14](R/W1C/H) Clear for Interrupt BANK_RECEIVED_14. */
        uint32_t bank_received_13      : 1;  /**< [ 13: 13](R/W1C/H) Clear for Interrupt BANK_RECEIVED_13. */
        uint32_t bank_received_12      : 1;  /**< [ 12: 12](R/W1C/H) Clear for Interrupt BANK_RECEIVED_12. */
        uint32_t bank_received_11      : 1;  /**< [ 11: 11](R/W1C/H) Clear for Interrupt BANK_RECEIVED_11. */
        uint32_t bank_received_10      : 1;  /**< [ 10: 10](R/W1C/H) Clear for Interrupt BANK_RECEIVED_10. */
        uint32_t bank_received_9       : 1;  /**< [  9:  9](R/W1C/H) Clear for Interrupt BANK_RECEIVED_9. */
        uint32_t bank_received_8       : 1;  /**< [  8:  8](R/W1C/H) Clear for Interrupt BANK_RECEIVED_8. */
        uint32_t bank_received_7       : 1;  /**< [  7:  7](R/W1C/H) Clear for Interrupt BANK_RECEIVED_7. */
        uint32_t bank_received_6       : 1;  /**< [  6:  6](R/W1C/H) Clear for Interrupt BANK_RECEIVED_6. */
        uint32_t bank_received_5       : 1;  /**< [  5:  5](R/W1C/H) Clear for Interrupt BANK_RECEIVED_5. */
        uint32_t bank_received_4       : 1;  /**< [  4:  4](R/W1C/H) Clear for Interrupt BANK_RECEIVED_4. */
        uint32_t bank_received_3       : 1;  /**< [  3:  3](R/W1C/H) Clear for Interrupt BANK_RECEIVED_3. */
        uint32_t bank_received_2       : 1;  /**< [  2:  2](R/W1C/H) Clear for Interrupt BANK_RECEIVED_2. */
        uint32_t bank_received_1       : 1;  /**< [  1:  1](R/W1C/H) Clear for Interrupt BANK_RECEIVED_1. */
        uint32_t bank_received_0       : 1;  /**< [  0:  0](R/W1C/H) Clear for Interrupt BANK_RECEIVED_0. */
#else /* Word 0 - Little Endian */
        uint32_t bank_received_0       : 1;  /**< [  0:  0](R/W1C/H) Clear for Interrupt BANK_RECEIVED_0. */
        uint32_t bank_received_1       : 1;  /**< [  1:  1](R/W1C/H) Clear for Interrupt BANK_RECEIVED_1. */
        uint32_t bank_received_2       : 1;  /**< [  2:  2](R/W1C/H) Clear for Interrupt BANK_RECEIVED_2. */
        uint32_t bank_received_3       : 1;  /**< [  3:  3](R/W1C/H) Clear for Interrupt BANK_RECEIVED_3. */
        uint32_t bank_received_4       : 1;  /**< [  4:  4](R/W1C/H) Clear for Interrupt BANK_RECEIVED_4. */
        uint32_t bank_received_5       : 1;  /**< [  5:  5](R/W1C/H) Clear for Interrupt BANK_RECEIVED_5. */
        uint32_t bank_received_6       : 1;  /**< [  6:  6](R/W1C/H) Clear for Interrupt BANK_RECEIVED_6. */
        uint32_t bank_received_7       : 1;  /**< [  7:  7](R/W1C/H) Clear for Interrupt BANK_RECEIVED_7. */
        uint32_t bank_received_8       : 1;  /**< [  8:  8](R/W1C/H) Clear for Interrupt BANK_RECEIVED_8. */
        uint32_t bank_received_9       : 1;  /**< [  9:  9](R/W1C/H) Clear for Interrupt BANK_RECEIVED_9. */
        uint32_t bank_received_10      : 1;  /**< [ 10: 10](R/W1C/H) Clear for Interrupt BANK_RECEIVED_10. */
        uint32_t bank_received_11      : 1;  /**< [ 11: 11](R/W1C/H) Clear for Interrupt BANK_RECEIVED_11. */
        uint32_t bank_received_12      : 1;  /**< [ 12: 12](R/W1C/H) Clear for Interrupt BANK_RECEIVED_12. */
        uint32_t bank_received_13      : 1;  /**< [ 13: 13](R/W1C/H) Clear for Interrupt BANK_RECEIVED_13. */
        uint32_t bank_received_14      : 1;  /**< [ 14: 14](R/W1C/H) Clear for Interrupt BANK_RECEIVED_14. */
        uint32_t bank_received_15      : 1;  /**< [ 15: 15](R/W1C/H) Clear for Interrupt BANK_RECEIVED_15.
                                                                   0 = No effect.
                                                                   1 = Interrupt clear. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crxb_int_clr_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crxb_int_clr_lnx cavm_cprix_cn4ipx_crxb_int_clr_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRXB_INT_CLR_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRXB_INT_CLR_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000820064ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRXB_INT_CLR_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRXB_INT_CLR_LNX(a,b,c) cavm_cprix_cn4ipx_crxb_int_clr_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRXB_INT_CLR_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRXB_INT_CLR_LNX(a,b,c) "CPRIX_CN4IPX_CRXB_INT_CLR_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRXB_INT_CLR_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRXB_INT_CLR_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_crxb_int_msk_ln#
 *
 * CPRI CONN4 IP CPRI RX Register Bank Interrupt Mask Register
 */
union cavm_cprix_cn4ipx_crxb_int_msk_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crxb_int_msk_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t bank_received_15      : 1;  /**< [ 15: 15](R/W) Mask for Interrupt BANK_RECEIVED_15.
                                                                   0 = Not masked.
                                                                   1 = Masked. */
        uint32_t bank_received_14      : 1;  /**< [ 14: 14](R/W) Mask for Interrupt BANK_RECEIVED_14. */
        uint32_t bank_received_13      : 1;  /**< [ 13: 13](R/W) Mask for Interrupt BANK_RECEIVED_13. */
        uint32_t bank_received_12      : 1;  /**< [ 12: 12](R/W) Mask for Interrupt BANK_RECEIVED_12. */
        uint32_t bank_received_11      : 1;  /**< [ 11: 11](R/W) Mask for Interrupt BANK_RECEIVED_11. */
        uint32_t bank_received_10      : 1;  /**< [ 10: 10](R/W) Mask for Interrupt BANK_RECEIVED_10. */
        uint32_t bank_received_9       : 1;  /**< [  9:  9](R/W) Mask for Interrupt BANK_RECEIVED_9. */
        uint32_t bank_received_8       : 1;  /**< [  8:  8](R/W) Mask for Interrupt BANK_RECEIVED_8. */
        uint32_t bank_received_7       : 1;  /**< [  7:  7](R/W) Mask for Interrupt BANK_RECEIVED_7. */
        uint32_t bank_received_6       : 1;  /**< [  6:  6](R/W) Mask for Interrupt BANK_RECEIVED_6. */
        uint32_t bank_received_5       : 1;  /**< [  5:  5](R/W) Mask for Interrupt BANK_RECEIVED_5. */
        uint32_t bank_received_4       : 1;  /**< [  4:  4](R/W) Mask for Interrupt BANK_RECEIVED_4. */
        uint32_t bank_received_3       : 1;  /**< [  3:  3](R/W) Mask for Interrupt BANK_RECEIVED_3. */
        uint32_t bank_received_2       : 1;  /**< [  2:  2](R/W) Mask for Interrupt BANK_RECEIVED_2. */
        uint32_t bank_received_1       : 1;  /**< [  1:  1](R/W) Mask for Interrupt BANK_RECEIVED_1. */
        uint32_t bank_received_0       : 1;  /**< [  0:  0](R/W) Mask for Interrupt BANK_RECEIVED_0. */
#else /* Word 0 - Little Endian */
        uint32_t bank_received_0       : 1;  /**< [  0:  0](R/W) Mask for Interrupt BANK_RECEIVED_0. */
        uint32_t bank_received_1       : 1;  /**< [  1:  1](R/W) Mask for Interrupt BANK_RECEIVED_1. */
        uint32_t bank_received_2       : 1;  /**< [  2:  2](R/W) Mask for Interrupt BANK_RECEIVED_2. */
        uint32_t bank_received_3       : 1;  /**< [  3:  3](R/W) Mask for Interrupt BANK_RECEIVED_3. */
        uint32_t bank_received_4       : 1;  /**< [  4:  4](R/W) Mask for Interrupt BANK_RECEIVED_4. */
        uint32_t bank_received_5       : 1;  /**< [  5:  5](R/W) Mask for Interrupt BANK_RECEIVED_5. */
        uint32_t bank_received_6       : 1;  /**< [  6:  6](R/W) Mask for Interrupt BANK_RECEIVED_6. */
        uint32_t bank_received_7       : 1;  /**< [  7:  7](R/W) Mask for Interrupt BANK_RECEIVED_7. */
        uint32_t bank_received_8       : 1;  /**< [  8:  8](R/W) Mask for Interrupt BANK_RECEIVED_8. */
        uint32_t bank_received_9       : 1;  /**< [  9:  9](R/W) Mask for Interrupt BANK_RECEIVED_9. */
        uint32_t bank_received_10      : 1;  /**< [ 10: 10](R/W) Mask for Interrupt BANK_RECEIVED_10. */
        uint32_t bank_received_11      : 1;  /**< [ 11: 11](R/W) Mask for Interrupt BANK_RECEIVED_11. */
        uint32_t bank_received_12      : 1;  /**< [ 12: 12](R/W) Mask for Interrupt BANK_RECEIVED_12. */
        uint32_t bank_received_13      : 1;  /**< [ 13: 13](R/W) Mask for Interrupt BANK_RECEIVED_13. */
        uint32_t bank_received_14      : 1;  /**< [ 14: 14](R/W) Mask for Interrupt BANK_RECEIVED_14. */
        uint32_t bank_received_15      : 1;  /**< [ 15: 15](R/W) Mask for Interrupt BANK_RECEIVED_15.
                                                                   0 = Not masked.
                                                                   1 = Masked. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crxb_int_msk_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crxb_int_msk_lnx cavm_cprix_cn4ipx_crxb_int_msk_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRXB_INT_MSK_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRXB_INT_MSK_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000820070ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRXB_INT_MSK_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRXB_INT_MSK_LNX(a,b,c) cavm_cprix_cn4ipx_crxb_int_msk_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRXB_INT_MSK_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRXB_INT_MSK_LNX(a,b,c) "CPRIX_CN4IPX_CRXB_INT_MSK_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRXB_INT_MSK_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRXB_INT_MSK_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_crxb_int_mskcl_ln#
 *
 * CPRI CONN4 IP CPRI RX Register Bank Interrupt Mask Clear Register
 */
union cavm_cprix_cn4ipx_crxb_int_mskcl_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crxb_int_mskcl_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t bank_received_15      : 1;  /**< [ 15: 15](R/W1C/H) Mask clear for Interrupt BANK_RECEIVED_15.
                                                                   0 = No effect.
                                                                   1 = Mask clear. */
        uint32_t bank_received_14      : 1;  /**< [ 14: 14](R/W1C/H) Mask clear for Interrupt BANK_RECEIVED_14. */
        uint32_t bank_received_13      : 1;  /**< [ 13: 13](R/W1C/H) Mask clear for Interrupt BANK_RECEIVED_13. */
        uint32_t bank_received_12      : 1;  /**< [ 12: 12](R/W1C/H) Mask clear for Interrupt BANK_RECEIVED_12. */
        uint32_t bank_received_11      : 1;  /**< [ 11: 11](R/W1C/H) Mask clear for Interrupt BANK_RECEIVED_11. */
        uint32_t bank_received_10      : 1;  /**< [ 10: 10](R/W1C/H) Mask clear for Interrupt BANK_RECEIVED_10. */
        uint32_t bank_received_9       : 1;  /**< [  9:  9](R/W1C/H) Mask clear for Interrupt BANK_RECEIVED_9. */
        uint32_t bank_received_8       : 1;  /**< [  8:  8](R/W1C/H) Mask clear for Interrupt BANK_RECEIVED_8. */
        uint32_t bank_received_7       : 1;  /**< [  7:  7](R/W1C/H) Mask clear for Interrupt BANK_RECEIVED_7. */
        uint32_t bank_received_6       : 1;  /**< [  6:  6](R/W1C/H) Mask clear for Interrupt BANK_RECEIVED_6. */
        uint32_t bank_received_5       : 1;  /**< [  5:  5](R/W1C/H) Mask clear for Interrupt BANK_RECEIVED_5. */
        uint32_t bank_received_4       : 1;  /**< [  4:  4](R/W1C/H) Mask clear for Interrupt BANK_RECEIVED_4. */
        uint32_t bank_received_3       : 1;  /**< [  3:  3](R/W1C/H) Mask clear for Interrupt BANK_RECEIVED_3. */
        uint32_t bank_received_2       : 1;  /**< [  2:  2](R/W1C/H) Mask clear for Interrupt BANK_RECEIVED_2. */
        uint32_t bank_received_1       : 1;  /**< [  1:  1](R/W1C/H) Mask clear for Interrupt BANK_RECEIVED_1. */
        uint32_t bank_received_0       : 1;  /**< [  0:  0](R/W1C/H) Mask clear for Interrupt BANK_RECEIVED_0. */
#else /* Word 0 - Little Endian */
        uint32_t bank_received_0       : 1;  /**< [  0:  0](R/W1C/H) Mask clear for Interrupt BANK_RECEIVED_0. */
        uint32_t bank_received_1       : 1;  /**< [  1:  1](R/W1C/H) Mask clear for Interrupt BANK_RECEIVED_1. */
        uint32_t bank_received_2       : 1;  /**< [  2:  2](R/W1C/H) Mask clear for Interrupt BANK_RECEIVED_2. */
        uint32_t bank_received_3       : 1;  /**< [  3:  3](R/W1C/H) Mask clear for Interrupt BANK_RECEIVED_3. */
        uint32_t bank_received_4       : 1;  /**< [  4:  4](R/W1C/H) Mask clear for Interrupt BANK_RECEIVED_4. */
        uint32_t bank_received_5       : 1;  /**< [  5:  5](R/W1C/H) Mask clear for Interrupt BANK_RECEIVED_5. */
        uint32_t bank_received_6       : 1;  /**< [  6:  6](R/W1C/H) Mask clear for Interrupt BANK_RECEIVED_6. */
        uint32_t bank_received_7       : 1;  /**< [  7:  7](R/W1C/H) Mask clear for Interrupt BANK_RECEIVED_7. */
        uint32_t bank_received_8       : 1;  /**< [  8:  8](R/W1C/H) Mask clear for Interrupt BANK_RECEIVED_8. */
        uint32_t bank_received_9       : 1;  /**< [  9:  9](R/W1C/H) Mask clear for Interrupt BANK_RECEIVED_9. */
        uint32_t bank_received_10      : 1;  /**< [ 10: 10](R/W1C/H) Mask clear for Interrupt BANK_RECEIVED_10. */
        uint32_t bank_received_11      : 1;  /**< [ 11: 11](R/W1C/H) Mask clear for Interrupt BANK_RECEIVED_11. */
        uint32_t bank_received_12      : 1;  /**< [ 12: 12](R/W1C/H) Mask clear for Interrupt BANK_RECEIVED_12. */
        uint32_t bank_received_13      : 1;  /**< [ 13: 13](R/W1C/H) Mask clear for Interrupt BANK_RECEIVED_13. */
        uint32_t bank_received_14      : 1;  /**< [ 14: 14](R/W1C/H) Mask clear for Interrupt BANK_RECEIVED_14. */
        uint32_t bank_received_15      : 1;  /**< [ 15: 15](R/W1C/H) Mask clear for Interrupt BANK_RECEIVED_15.
                                                                   0 = No effect.
                                                                   1 = Mask clear. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crxb_int_mskcl_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crxb_int_mskcl_lnx cavm_cprix_cn4ipx_crxb_int_mskcl_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRXB_INT_MSKCL_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRXB_INT_MSKCL_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000820074ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRXB_INT_MSKCL_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRXB_INT_MSKCL_LNX(a,b,c) cavm_cprix_cn4ipx_crxb_int_mskcl_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRXB_INT_MSKCL_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRXB_INT_MSKCL_LNX(a,b,c) "CPRIX_CN4IPX_CRXB_INT_MSKCL_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRXB_INT_MSKCL_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRXB_INT_MSKCL_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_crxb_int_mskst_ln#
 *
 * CPRI CONN4 IP CPRI RX Register Bank Interrupt Mask Set Register
 */
union cavm_cprix_cn4ipx_crxb_int_mskst_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crxb_int_mskst_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t bank_received_15      : 1;  /**< [ 15: 15](R/W1S/H) Mask set for Interrupt BANK_RECEIVED_15.
                                                                   0 = No effect.
                                                                   1 = Mask set. */
        uint32_t bank_received_14      : 1;  /**< [ 14: 14](R/W1S/H) Mask set for Interrupt BANK_RECEIVED_14. */
        uint32_t bank_received_13      : 1;  /**< [ 13: 13](R/W1S/H) Mask set for Interrupt BANK_RECEIVED_13. */
        uint32_t bank_received_12      : 1;  /**< [ 12: 12](R/W1S/H) Mask set for Interrupt BANK_RECEIVED_12. */
        uint32_t bank_received_11      : 1;  /**< [ 11: 11](R/W1S/H) Mask set for Interrupt BANK_RECEIVED_11. */
        uint32_t bank_received_10      : 1;  /**< [ 10: 10](R/W1S/H) Mask set for Interrupt BANK_RECEIVED_10. */
        uint32_t bank_received_9       : 1;  /**< [  9:  9](R/W1S/H) Mask set for Interrupt BANK_RECEIVED_9. */
        uint32_t bank_received_8       : 1;  /**< [  8:  8](R/W1S/H) Mask set for Interrupt BANK_RECEIVED_8. */
        uint32_t bank_received_7       : 1;  /**< [  7:  7](R/W1S/H) Mask set for Interrupt BANK_RECEIVED_7. */
        uint32_t bank_received_6       : 1;  /**< [  6:  6](R/W1S/H) Mask set for Interrupt BANK_RECEIVED_6. */
        uint32_t bank_received_5       : 1;  /**< [  5:  5](R/W1S/H) Mask set for Interrupt BANK_RECEIVED_5. */
        uint32_t bank_received_4       : 1;  /**< [  4:  4](R/W1S/H) Mask set for Interrupt BANK_RECEIVED_4. */
        uint32_t bank_received_3       : 1;  /**< [  3:  3](R/W1S/H) Mask set for Interrupt BANK_RECEIVED_3. */
        uint32_t bank_received_2       : 1;  /**< [  2:  2](R/W1S/H) Mask set for Interrupt BANK_RECEIVED_2. */
        uint32_t bank_received_1       : 1;  /**< [  1:  1](R/W1S/H) Mask set for Interrupt BANK_RECEIVED_1. */
        uint32_t bank_received_0       : 1;  /**< [  0:  0](R/W1S/H) Mask set for Interrupt BANK_RECEIVED_0. */
#else /* Word 0 - Little Endian */
        uint32_t bank_received_0       : 1;  /**< [  0:  0](R/W1S/H) Mask set for Interrupt BANK_RECEIVED_0. */
        uint32_t bank_received_1       : 1;  /**< [  1:  1](R/W1S/H) Mask set for Interrupt BANK_RECEIVED_1. */
        uint32_t bank_received_2       : 1;  /**< [  2:  2](R/W1S/H) Mask set for Interrupt BANK_RECEIVED_2. */
        uint32_t bank_received_3       : 1;  /**< [  3:  3](R/W1S/H) Mask set for Interrupt BANK_RECEIVED_3. */
        uint32_t bank_received_4       : 1;  /**< [  4:  4](R/W1S/H) Mask set for Interrupt BANK_RECEIVED_4. */
        uint32_t bank_received_5       : 1;  /**< [  5:  5](R/W1S/H) Mask set for Interrupt BANK_RECEIVED_5. */
        uint32_t bank_received_6       : 1;  /**< [  6:  6](R/W1S/H) Mask set for Interrupt BANK_RECEIVED_6. */
        uint32_t bank_received_7       : 1;  /**< [  7:  7](R/W1S/H) Mask set for Interrupt BANK_RECEIVED_7. */
        uint32_t bank_received_8       : 1;  /**< [  8:  8](R/W1S/H) Mask set for Interrupt BANK_RECEIVED_8. */
        uint32_t bank_received_9       : 1;  /**< [  9:  9](R/W1S/H) Mask set for Interrupt BANK_RECEIVED_9. */
        uint32_t bank_received_10      : 1;  /**< [ 10: 10](R/W1S/H) Mask set for Interrupt BANK_RECEIVED_10. */
        uint32_t bank_received_11      : 1;  /**< [ 11: 11](R/W1S/H) Mask set for Interrupt BANK_RECEIVED_11. */
        uint32_t bank_received_12      : 1;  /**< [ 12: 12](R/W1S/H) Mask set for Interrupt BANK_RECEIVED_12. */
        uint32_t bank_received_13      : 1;  /**< [ 13: 13](R/W1S/H) Mask set for Interrupt BANK_RECEIVED_13. */
        uint32_t bank_received_14      : 1;  /**< [ 14: 14](R/W1S/H) Mask set for Interrupt BANK_RECEIVED_14. */
        uint32_t bank_received_15      : 1;  /**< [ 15: 15](R/W1S/H) Mask set for Interrupt BANK_RECEIVED_15.
                                                                   0 = No effect.
                                                                   1 = Mask set. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crxb_int_mskst_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crxb_int_mskst_lnx cavm_cprix_cn4ipx_crxb_int_mskst_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRXB_INT_MSKST_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRXB_INT_MSKST_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000820078ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRXB_INT_MSKST_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRXB_INT_MSKST_LNX(a,b,c) cavm_cprix_cn4ipx_crxb_int_mskst_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRXB_INT_MSKST_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRXB_INT_MSKST_LNX(a,b,c) "CPRIX_CN4IPX_CRXB_INT_MSKST_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRXB_INT_MSKST_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRXB_INT_MSKST_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_crxb_int_set_ln#
 *
 * CPRI CONN4 IP CPRI RX Register Bank Interrupt Event Set Register
 */
union cavm_cprix_cn4ipx_crxb_int_set_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crxb_int_set_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t bank_received_15      : 1;  /**< [ 15: 15](R/W1S/H) Set for Interrupt BANK_RECEIVED_15.
                                                                   0 = No effect.
                                                                   1 = Interrupt set. */
        uint32_t bank_received_14      : 1;  /**< [ 14: 14](R/W1S/H) Set for Interrupt BANK_RECEIVED_14. */
        uint32_t bank_received_13      : 1;  /**< [ 13: 13](R/W1S/H) Set for Interrupt BANK_RECEIVED_13. */
        uint32_t bank_received_12      : 1;  /**< [ 12: 12](R/W1S/H) Set for Interrupt BANK_RECEIVED_12. */
        uint32_t bank_received_11      : 1;  /**< [ 11: 11](R/W1S/H) Set for Interrupt BANK_RECEIVED_11. */
        uint32_t bank_received_10      : 1;  /**< [ 10: 10](R/W1S/H) Set for Interrupt BANK_RECEIVED_10. */
        uint32_t bank_received_9       : 1;  /**< [  9:  9](R/W1S/H) Set for Interrupt BANK_RECEIVED_9. */
        uint32_t bank_received_8       : 1;  /**< [  8:  8](R/W1S/H) Set for Interrupt BANK_RECEIVED_8. */
        uint32_t bank_received_7       : 1;  /**< [  7:  7](R/W1S/H) Set for Interrupt BANK_RECEIVED_7. */
        uint32_t bank_received_6       : 1;  /**< [  6:  6](R/W1S/H) Set for Interrupt BANK_RECEIVED_6. */
        uint32_t bank_received_5       : 1;  /**< [  5:  5](R/W1S/H) Set for Interrupt BANK_RECEIVED_5. */
        uint32_t bank_received_4       : 1;  /**< [  4:  4](R/W1S/H) Set for Interrupt BANK_RECEIVED_4. */
        uint32_t bank_received_3       : 1;  /**< [  3:  3](R/W1S/H) Set for Interrupt BANK_RECEIVED_3. */
        uint32_t bank_received_2       : 1;  /**< [  2:  2](R/W1S/H) Set for Interrupt BANK_RECEIVED_2. */
        uint32_t bank_received_1       : 1;  /**< [  1:  1](R/W1S/H) Set for Interrupt BANK_RECEIVED_1. */
        uint32_t bank_received_0       : 1;  /**< [  0:  0](R/W1S/H) Set for Interrupt BANK_RECEIVED_0. */
#else /* Word 0 - Little Endian */
        uint32_t bank_received_0       : 1;  /**< [  0:  0](R/W1S/H) Set for Interrupt BANK_RECEIVED_0. */
        uint32_t bank_received_1       : 1;  /**< [  1:  1](R/W1S/H) Set for Interrupt BANK_RECEIVED_1. */
        uint32_t bank_received_2       : 1;  /**< [  2:  2](R/W1S/H) Set for Interrupt BANK_RECEIVED_2. */
        uint32_t bank_received_3       : 1;  /**< [  3:  3](R/W1S/H) Set for Interrupt BANK_RECEIVED_3. */
        uint32_t bank_received_4       : 1;  /**< [  4:  4](R/W1S/H) Set for Interrupt BANK_RECEIVED_4. */
        uint32_t bank_received_5       : 1;  /**< [  5:  5](R/W1S/H) Set for Interrupt BANK_RECEIVED_5. */
        uint32_t bank_received_6       : 1;  /**< [  6:  6](R/W1S/H) Set for Interrupt BANK_RECEIVED_6. */
        uint32_t bank_received_7       : 1;  /**< [  7:  7](R/W1S/H) Set for Interrupt BANK_RECEIVED_7. */
        uint32_t bank_received_8       : 1;  /**< [  8:  8](R/W1S/H) Set for Interrupt BANK_RECEIVED_8. */
        uint32_t bank_received_9       : 1;  /**< [  9:  9](R/W1S/H) Set for Interrupt BANK_RECEIVED_9. */
        uint32_t bank_received_10      : 1;  /**< [ 10: 10](R/W1S/H) Set for Interrupt BANK_RECEIVED_10. */
        uint32_t bank_received_11      : 1;  /**< [ 11: 11](R/W1S/H) Set for Interrupt BANK_RECEIVED_11. */
        uint32_t bank_received_12      : 1;  /**< [ 12: 12](R/W1S/H) Set for Interrupt BANK_RECEIVED_12. */
        uint32_t bank_received_13      : 1;  /**< [ 13: 13](R/W1S/H) Set for Interrupt BANK_RECEIVED_13. */
        uint32_t bank_received_14      : 1;  /**< [ 14: 14](R/W1S/H) Set for Interrupt BANK_RECEIVED_14. */
        uint32_t bank_received_15      : 1;  /**< [ 15: 15](R/W1S/H) Set for Interrupt BANK_RECEIVED_15.
                                                                   0 = No effect.
                                                                   1 = Interrupt set. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crxb_int_set_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crxb_int_set_lnx cavm_cprix_cn4ipx_crxb_int_set_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRXB_INT_SET_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRXB_INT_SET_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000820068ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRXB_INT_SET_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRXB_INT_SET_LNX(a,b,c) cavm_cprix_cn4ipx_crxb_int_set_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRXB_INT_SET_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRXB_INT_SET_LNX(a,b,c) "CPRIX_CN4IPX_CRXB_INT_SET_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRXB_INT_SET_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRXB_INT_SET_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_crxb_int_sts_ln#
 *
 * CPRI CONN4 IP CPRI RX Register Bank Interrupt Status Register
 */
union cavm_cprix_cn4ipx_crxb_int_sts_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crxb_int_sts_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t bank_received_15      : 1;  /**< [ 15: 15](RO/H) Reception status of box 15.
                                                                   0 = not received.
                                                                   1 = enabled bytes were received. */
        uint32_t bank_received_14      : 1;  /**< [ 14: 14](RO/H) Reception status of box 14. */
        uint32_t bank_received_13      : 1;  /**< [ 13: 13](RO/H) Reception status of box 13. */
        uint32_t bank_received_12      : 1;  /**< [ 12: 12](RO/H) Reception status of box 12. */
        uint32_t bank_received_11      : 1;  /**< [ 11: 11](RO/H) Reception status of box 11. */
        uint32_t bank_received_10      : 1;  /**< [ 10: 10](RO/H) Reception status of box 10. */
        uint32_t bank_received_9       : 1;  /**< [  9:  9](RO/H) Reception status of box 9. */
        uint32_t bank_received_8       : 1;  /**< [  8:  8](RO/H) Reception status of box 8. */
        uint32_t bank_received_7       : 1;  /**< [  7:  7](RO/H) Reception status of box 7. */
        uint32_t bank_received_6       : 1;  /**< [  6:  6](RO/H) Reception status of box 6. */
        uint32_t bank_received_5       : 1;  /**< [  5:  5](RO/H) Reception status of box 5. */
        uint32_t bank_received_4       : 1;  /**< [  4:  4](RO/H) Reception status of box 4. */
        uint32_t bank_received_3       : 1;  /**< [  3:  3](RO/H) Reception status of box 3. */
        uint32_t bank_received_2       : 1;  /**< [  2:  2](RO/H) Reception status of box 2. */
        uint32_t bank_received_1       : 1;  /**< [  1:  1](RO/H) Reception status of box 1. */
        uint32_t bank_received_0       : 1;  /**< [  0:  0](RO/H) Reception status of box 0. */
#else /* Word 0 - Little Endian */
        uint32_t bank_received_0       : 1;  /**< [  0:  0](RO/H) Reception status of box 0. */
        uint32_t bank_received_1       : 1;  /**< [  1:  1](RO/H) Reception status of box 1. */
        uint32_t bank_received_2       : 1;  /**< [  2:  2](RO/H) Reception status of box 2. */
        uint32_t bank_received_3       : 1;  /**< [  3:  3](RO/H) Reception status of box 3. */
        uint32_t bank_received_4       : 1;  /**< [  4:  4](RO/H) Reception status of box 4. */
        uint32_t bank_received_5       : 1;  /**< [  5:  5](RO/H) Reception status of box 5. */
        uint32_t bank_received_6       : 1;  /**< [  6:  6](RO/H) Reception status of box 6. */
        uint32_t bank_received_7       : 1;  /**< [  7:  7](RO/H) Reception status of box 7. */
        uint32_t bank_received_8       : 1;  /**< [  8:  8](RO/H) Reception status of box 8. */
        uint32_t bank_received_9       : 1;  /**< [  9:  9](RO/H) Reception status of box 9. */
        uint32_t bank_received_10      : 1;  /**< [ 10: 10](RO/H) Reception status of box 10. */
        uint32_t bank_received_11      : 1;  /**< [ 11: 11](RO/H) Reception status of box 11. */
        uint32_t bank_received_12      : 1;  /**< [ 12: 12](RO/H) Reception status of box 12. */
        uint32_t bank_received_13      : 1;  /**< [ 13: 13](RO/H) Reception status of box 13. */
        uint32_t bank_received_14      : 1;  /**< [ 14: 14](RO/H) Reception status of box 14. */
        uint32_t bank_received_15      : 1;  /**< [ 15: 15](RO/H) Reception status of box 15.
                                                                   0 = not received.
                                                                   1 = enabled bytes were received. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crxb_int_sts_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crxb_int_sts_lnx cavm_cprix_cn4ipx_crxb_int_sts_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRXB_INT_STS_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRXB_INT_STS_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000820060ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRXB_INT_STS_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRXB_INT_STS_LNX(a,b,c) cavm_cprix_cn4ipx_crxb_int_sts_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRXB_INT_STS_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRXB_INT_STS_LNX(a,b,c) "CPRIX_CN4IPX_CRXB_INT_STS_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRXB_INT_STS_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRXB_INT_STS_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_crxvsb#_modulo_ln#
 *
 * CPRI CONN4 IP CPRI RX VSB Region A/B/C/D Modulo Register
 */
union cavm_cprix_cn4ipx_crxvsbx_modulo_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crxvsbx_modulo_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_20_31        : 12;
        uint32_t y                     : 4;  /**< [ 19: 16](R/W) Active bytes in the CPRI word:
                                                                   0x0 = Y1-Y0.
                                                                   0x1 = Y3-Y2.
                                                                   0x2 = Y5-Y4.   NOTE: not valid when line rate = 2457.6 Mbit/s.
                                                                   0x3 = Y7-Y6.   NOTE: not valid when line rate = 2457.6 Mbit/s.
                                                                   0x4 = Y9-Y8.   NOTE: not valid when line rate = 2457.6/4915.2/6144.0 Mbit/s.
                                                                   0x5 =Y11-Y10.  NOTE: not valid when line rate = 2457.6/4915. /6144.0 2 Mbit/s.
                                                                   0x6 =Y13-Y12.  NOTE: not valid when line rate = 2457.6/4915.2/6144.0  Mbit/s.
                                                                   0x7 =Y15-Y14.  NOTE: not valid when line rate = 2457.6/4915.2/6144.0  Mbit/s.
                                                                   0x8 = Y3-Y0.
                                                                   0x9 = Y7-Y4.   NOTE: not valid when line rate = 2457.6 Mbit/s.
                                                                   0xA =Y11-Y8.   NOTE: not valid when line rate = 2457.6/4915.2/6144.0  Mbit/s.
                                                                   0xB =Y15-Y12.  NOTE: not valid when line rate = 2457.6/4915.2/6144.0  Mbit/s.
                                                                   0xC = Y7-Y0.   NOTE: not valid when line rate = 2457.6 Mbit/s.
                                                                   0xD = Y15-Y8.  NOTE: not valid when line rate = 2457.6/4915.2/6144.0 Mbit/s.
                                                                   0xE = Y9-Y0.   NOTE: not valid when line rate = 2457.6/4915.2 Mbit/s.
                                                                   0xF = Y15-Y0.  NOTE: not valid when line rate = 2457.6/4915.2/6144.0  Mbit/s. */
        uint32_t index                 : 8;  /**< [ 15:  8](R/W) Index of the VSB region A activation rule. */
        uint32_t modulo                : 8;  /**< [  7:  0](R/W) Modulo of the VSB region A activation rule. */
#else /* Word 0 - Little Endian */
        uint32_t modulo                : 8;  /**< [  7:  0](R/W) Modulo of the VSB region A activation rule. */
        uint32_t index                 : 8;  /**< [ 15:  8](R/W) Index of the VSB region A activation rule. */
        uint32_t y                     : 4;  /**< [ 19: 16](R/W) Active bytes in the CPRI word:
                                                                   0x0 = Y1-Y0.
                                                                   0x1 = Y3-Y2.
                                                                   0x2 = Y5-Y4.   NOTE: not valid when line rate = 2457.6 Mbit/s.
                                                                   0x3 = Y7-Y6.   NOTE: not valid when line rate = 2457.6 Mbit/s.
                                                                   0x4 = Y9-Y8.   NOTE: not valid when line rate = 2457.6/4915.2/6144.0 Mbit/s.
                                                                   0x5 =Y11-Y10.  NOTE: not valid when line rate = 2457.6/4915. /6144.0 2 Mbit/s.
                                                                   0x6 =Y13-Y12.  NOTE: not valid when line rate = 2457.6/4915.2/6144.0  Mbit/s.
                                                                   0x7 =Y15-Y14.  NOTE: not valid when line rate = 2457.6/4915.2/6144.0  Mbit/s.
                                                                   0x8 = Y3-Y0.
                                                                   0x9 = Y7-Y4.   NOTE: not valid when line rate = 2457.6 Mbit/s.
                                                                   0xA =Y11-Y8.   NOTE: not valid when line rate = 2457.6/4915.2/6144.0  Mbit/s.
                                                                   0xB =Y15-Y12.  NOTE: not valid when line rate = 2457.6/4915.2/6144.0  Mbit/s.
                                                                   0xC = Y7-Y0.   NOTE: not valid when line rate = 2457.6 Mbit/s.
                                                                   0xD = Y15-Y8.  NOTE: not valid when line rate = 2457.6/4915.2/6144.0 Mbit/s.
                                                                   0xE = Y9-Y0.   NOTE: not valid when line rate = 2457.6/4915.2 Mbit/s.
                                                                   0xF = Y15-Y0.  NOTE: not valid when line rate = 2457.6/4915.2/6144.0  Mbit/s. */
        uint32_t reserved_20_31        : 12;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crxvsbx_modulo_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crxvsbx_modulo_lnx cavm_cprix_cn4ipx_crxvsbx_modulo_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRXVSBX_MODULO_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRXVSBX_MODULO_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=3) && (d<=1)))
        return 0x864000820104ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10ll * ((c) & 0x3) + 0x10000ll * ((d) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRXVSBX_MODULO_LNX", 4, a, b, c, d, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRXVSBX_MODULO_LNX(a,b,c,d) cavm_cprix_cn4ipx_crxvsbx_modulo_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRXVSBX_MODULO_LNX(a,b,c,d) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRXVSBX_MODULO_LNX(a,b,c,d) "CPRIX_CN4IPX_CRXVSBX_MODULO_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRXVSBX_MODULO_LNX(a,b,c,d) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRXVSBX_MODULO_LNX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) cpri#_cn4ip#_crxvsb#_rg_sl#st_ln#
 *
 * CPRI CONN4 IP CPRI RX VSB Region A/B/C/D Slice 0/1/2/3 Status Register
 */
union cavm_cprix_cn4ipx_crxvsbx_rg_slxst_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crxvsbx_rg_slxst_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t error_s               : 1;  /**< [  3:  3](RO/H) VSB region A slice 0 error status.
                                                                   0 = no line code violation detected during the slice reception.
                                                                   1 = line code violation detected in the received VSB byte (the byte is forced to zero). */
        uint32_t bfn_wrapped           : 1;  /**< [  2:  2](RO/H) VSB region A slice 0 sync status.
                                                                   0 = no BFN wrap around detected.
                                                                   1 = BFN wrap around (4095 -\> 0) detected during this slice reception or after previous slice. */
        uint32_t z_wrapped             : 1;  /**< [  1:  1](RO/H) VSB region A slice 0 sync status.
                                                                   0 = no Z wrap around detected.
                                                                   1 = Z wrap around (149 -\> 0) detected during this slice reception or after previous slice. */
        uint32_t nonempty              : 1;  /**< [  0:  0](RO/H) VSB region A slice 0  status.
                                                                   0 = no data in the buffer slice.
                                                                   1 = unread data in the buffer slice. */
#else /* Word 0 - Little Endian */
        uint32_t nonempty              : 1;  /**< [  0:  0](RO/H) VSB region A slice 0  status.
                                                                   0 = no data in the buffer slice.
                                                                   1 = unread data in the buffer slice. */
        uint32_t z_wrapped             : 1;  /**< [  1:  1](RO/H) VSB region A slice 0 sync status.
                                                                   0 = no Z wrap around detected.
                                                                   1 = Z wrap around (149 -\> 0) detected during this slice reception or after previous slice. */
        uint32_t bfn_wrapped           : 1;  /**< [  2:  2](RO/H) VSB region A slice 0 sync status.
                                                                   0 = no BFN wrap around detected.
                                                                   1 = BFN wrap around (4095 -\> 0) detected during this slice reception or after previous slice. */
        uint32_t error_s               : 1;  /**< [  3:  3](RO/H) VSB region A slice 0 error status.
                                                                   0 = no line code violation detected during the slice reception.
                                                                   1 = line code violation detected in the received VSB byte (the byte is forced to zero). */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crxvsbx_rg_slxst_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crxvsbx_rg_slxst_lnx cavm_cprix_cn4ipx_crxvsbx_rg_slxst_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRXVSBX_RG_SLXST_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d, unsigned long e) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRXVSBX_RG_SLXST_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d, unsigned long e)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=3) && (d<=3) && (e<=1)))
        return 0x864000820140ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10ll * ((c) & 0x3) + 4ll * ((d) & 0x3) + 0x10000ll * ((e) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRXVSBX_RG_SLXST_LNX", 5, a, b, c, d, e, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRXVSBX_RG_SLXST_LNX(a,b,c,d,e) cavm_cprix_cn4ipx_crxvsbx_rg_slxst_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRXVSBX_RG_SLXST_LNX(a,b,c,d,e) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRXVSBX_RG_SLXST_LNX(a,b,c,d,e) "CPRIX_CN4IPX_CRXVSBX_RG_SLXST_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRXVSBX_RG_SLXST_LNX(a,b,c,d,e) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRXVSBX_RG_SLXST_LNX(a,b,c,d,e) (a),(b),(c),(d),(e)

/**
 * Register (NCB32b) cpri#_cn4ip#_crxvsb#_slice_ln#
 *
 * CPRI CONN4 IP CPRI RX VSB Region A/B/C/D Slice Register
 */
union cavm_cprix_cn4ipx_crxvsbx_slice_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crxvsbx_slice_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_19_31        : 13;
        uint32_t slice_length          : 9;  /**< [ 18: 10](R/W) Length of the VSB region A buffer slice in four bytes (0-256):
                                                                         0 = not valid.
                                                                         1 = 4 bytes long.
                                                                         2 = 8 bytes long.

                                                                       0x100 = 1024 bytes long.
                                                                   0x1FF-0x101 = not valid.

                                                                 NOTE : the length of the whole VSB buffer is 4*CRX_VSB1_SLC_LEN*4 bytes. */
        uint32_t buffer_start          : 10; /**< [  9:  0](R/W) Start address of the VSB region A buffer in the buffer memory. */
#else /* Word 0 - Little Endian */
        uint32_t buffer_start          : 10; /**< [  9:  0](R/W) Start address of the VSB region A buffer in the buffer memory. */
        uint32_t slice_length          : 9;  /**< [ 18: 10](R/W) Length of the VSB region A buffer slice in four bytes (0-256):
                                                                         0 = not valid.
                                                                         1 = 4 bytes long.
                                                                         2 = 8 bytes long.

                                                                       0x100 = 1024 bytes long.
                                                                   0x1FF-0x101 = not valid.

                                                                 NOTE : the length of the whole VSB buffer is 4*CRX_VSB1_SLC_LEN*4 bytes. */
        uint32_t reserved_19_31        : 13;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crxvsbx_slice_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crxvsbx_slice_lnx cavm_cprix_cn4ipx_crxvsbx_slice_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRXVSBX_SLICE_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRXVSBX_SLICE_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=3) && (d<=1)))
        return 0x864000820108ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10ll * ((c) & 0x3) + 0x10000ll * ((d) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRXVSBX_SLICE_LNX", 4, a, b, c, d, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRXVSBX_SLICE_LNX(a,b,c,d) cavm_cprix_cn4ipx_crxvsbx_slice_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRXVSBX_SLICE_LNX(a,b,c,d) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRXVSBX_SLICE_LNX(a,b,c,d) "CPRIX_CN4IPX_CRXVSBX_SLICE_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRXVSBX_SLICE_LNX(a,b,c,d) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRXVSBX_SLICE_LNX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) cpri#_cn4ip#_crxvsb#_subchnl_ln#
 *
 * CPRI CONN4 IP CPRI RX VSB Region A/B/C/D Subchannel Register
 */
union cavm_cprix_cn4ipx_crxvsbx_subchnl_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crxvsbx_subchnl_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_19_31        : 13;
        uint32_t rx_mode               : 2;  /**< [ 18: 17](R/W) VSB region A data reception mode :
                                                                    0 = all received slices are accepted.
                                                                    1 = only non-zero slices are accepted.
                                                                    2 = only slices having change in the incoming data are accepted. The lowest
                                                                 four bytes (32 bits) of the first CPRI word are monitored.
                                                                    3 = only slices having different CRC32 signature are accepted. */
        uint32_t enable                : 1;  /**< [ 16: 16](R/W) VSB region A enable.
                                                                   0 = disabled.
                                                                   1 = enabled. */
        uint32_t ns1                   : 6;  /**< [ 15: 10](R/W) Ns coordinate of bottom right corner of the region A. */
        uint32_t xs1                   : 2;  /**< [  9:  8](R/W) Xs coordinate of bottom right corner of the region A. */
        uint32_t ns0                   : 6;  /**< [  7:  2](R/W) Ns coordinate of top left corner of the region A. */
        uint32_t xs0                   : 2;  /**< [  1:  0](R/W) Xs coordinate of top left corner of the region A. */
#else /* Word 0 - Little Endian */
        uint32_t xs0                   : 2;  /**< [  1:  0](R/W) Xs coordinate of top left corner of the region A. */
        uint32_t ns0                   : 6;  /**< [  7:  2](R/W) Ns coordinate of top left corner of the region A. */
        uint32_t xs1                   : 2;  /**< [  9:  8](R/W) Xs coordinate of bottom right corner of the region A. */
        uint32_t ns1                   : 6;  /**< [ 15: 10](R/W) Ns coordinate of bottom right corner of the region A. */
        uint32_t enable                : 1;  /**< [ 16: 16](R/W) VSB region A enable.
                                                                   0 = disabled.
                                                                   1 = enabled. */
        uint32_t rx_mode               : 2;  /**< [ 18: 17](R/W) VSB region A data reception mode :
                                                                    0 = all received slices are accepted.
                                                                    1 = only non-zero slices are accepted.
                                                                    2 = only slices having change in the incoming data are accepted. The lowest
                                                                 four bytes (32 bits) of the first CPRI word are monitored.
                                                                    3 = only slices having different CRC32 signature are accepted. */
        uint32_t reserved_19_31        : 13;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crxvsbx_subchnl_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crxvsbx_subchnl_lnx cavm_cprix_cn4ipx_crxvsbx_subchnl_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRXVSBX_SUBCHNL_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRXVSBX_SUBCHNL_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=3) && (d<=1)))
        return 0x864000820100ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10ll * ((c) & 0x3) + 0x10000ll * ((d) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRXVSBX_SUBCHNL_LNX", 4, a, b, c, d, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRXVSBX_SUBCHNL_LNX(a,b,c,d) cavm_cprix_cn4ipx_crxvsbx_subchnl_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRXVSBX_SUBCHNL_LNX(a,b,c,d) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRXVSBX_SUBCHNL_LNX(a,b,c,d) "CPRIX_CN4IPX_CRXVSBX_SUBCHNL_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRXVSBX_SUBCHNL_LNX(a,b,c,d) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRXVSBX_SUBCHNL_LNX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) cpri#_cn4ip#_crxvsb_bufram#_ln#
 *
 * CPRI CONN4 IP CPRI RX VSB Buffer RAM Registers
 */
union cavm_cprix_cn4ipx_crxvsb_buframx_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crxvsb_buframx_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t byte3                 : 8;  /**< [ 31: 24](R/W) Byte three. Transmitted last. */
        uint32_t byte2                 : 8;  /**< [ 23: 16](R/W) Byte two. */
        uint32_t byte1                 : 8;  /**< [ 15:  8](R/W) Byte one. */
        uint32_t byte0                 : 8;  /**< [  7:  0](R/W) Byte zero. Transmitted first. */
#else /* Word 0 - Little Endian */
        uint32_t byte0                 : 8;  /**< [  7:  0](R/W) Byte zero. Transmitted first. */
        uint32_t byte1                 : 8;  /**< [ 15:  8](R/W) Byte one. */
        uint32_t byte2                 : 8;  /**< [ 23: 16](R/W) Byte two. */
        uint32_t byte3                 : 8;  /**< [ 31: 24](R/W) Byte three. Transmitted last. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crxvsb_buframx_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crxvsb_buframx_lnx cavm_cprix_cn4ipx_crxvsb_buframx_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRXVSB_BUFRAMX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRXVSB_BUFRAMX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1023) && (d<=1)))
        return 0x864000822000ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 4ll * ((c) & 0x3ff) + 0x10000ll * ((d) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRXVSB_BUFRAMX_LNX", 4, a, b, c, d, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRXVSB_BUFRAMX_LNX(a,b,c,d) cavm_cprix_cn4ipx_crxvsb_buframx_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRXVSB_BUFRAMX_LNX(a,b,c,d) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRXVSB_BUFRAMX_LNX(a,b,c,d) "CPRIX_CN4IPX_CRXVSB_BUFRAMX_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRXVSB_BUFRAMX_LNX(a,b,c,d) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRXVSB_BUFRAMX_LNX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) cpri#_cn4ip#_crxvsb_int_clr_ln#
 *
 * CPRI CONN4 IP CPRI RX VSB Buffer Interrupt Event Clear Register
 */
union cavm_cprix_cn4ipx_crxvsb_int_clr_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crxvsb_int_clr_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_21_31        : 11;
        uint32_t overlap               : 1;  /**< [ 20: 20](R/W1C/H) Clear status for VSB region overlap error.
                                                                   0 = no effect.
                                                                   1 = Clear Status. */
        uint32_t d_overflow            : 1;  /**< [ 19: 19](R/W1C/H) Clear status for VSB region D buffer overflow. */
        uint32_t c_overflow            : 1;  /**< [ 18: 18](R/W1C/H) Clear status for VSB region C  buffer overflow. */
        uint32_t b_overflow            : 1;  /**< [ 17: 17](R/W1C/H) Clear status for VSB region B  buffer overflow. */
        uint32_t a_overflow            : 1;  /**< [ 16: 16](R/W1C/H) Clear status for VSB region A  buffer overflow. */
        uint32_t d3_nonempty           : 1;  /**< [ 15: 15](R/W1C/H) Clear status for VSB region D slice 3  status. */
        uint32_t d2_nonempty           : 1;  /**< [ 14: 14](R/W1C/H) Clear status for VSB region D slice 2  status. */
        uint32_t d1_nonempty           : 1;  /**< [ 13: 13](R/W1C/H) Clear status for VSB region D slice 1  status. */
        uint32_t d0_nonempty           : 1;  /**< [ 12: 12](R/W1C/H) Clear status for VSB region D slice 0  status. */
        uint32_t c3_nonempty           : 1;  /**< [ 11: 11](R/W1C/H) Clear status for VSB region C slice 3  status. */
        uint32_t c2_nonempty           : 1;  /**< [ 10: 10](R/W1C/H) Clear status for VSB region C slice 2  status. */
        uint32_t c1_nonempty           : 1;  /**< [  9:  9](R/W1C/H) Clear status for VSB region C slice 1  status. */
        uint32_t c0_nonempty           : 1;  /**< [  8:  8](R/W1C/H) Clear status for VSB region C slice 0  status. */
        uint32_t b3_nonempty           : 1;  /**< [  7:  7](R/W1C/H) Clear status for VSB region B slice 3  status. */
        uint32_t b2_nonempty           : 1;  /**< [  6:  6](R/W1C/H) Clear status for VSB region B slice 2  status. */
        uint32_t b1_nonempty           : 1;  /**< [  5:  5](R/W1C/H) Clear status for VSB region B slice 1  status. */
        uint32_t b0_nonempty           : 1;  /**< [  4:  4](R/W1C/H) Clear status for VSB region B slice 0  status. */
        uint32_t a3_nonempty           : 1;  /**< [  3:  3](R/W1C/H) Clear status for VSB region A slice 3  status. */
        uint32_t a2_nonempty           : 1;  /**< [  2:  2](R/W1C/H) Clear status for VSB region A slice 2  status. */
        uint32_t a1_nonempty           : 1;  /**< [  1:  1](R/W1C/H) Clear status for VSB region A slice 1  status. */
        uint32_t a0_nonempty           : 1;  /**< [  0:  0](R/W1C/H) Clear status for VSB region A slice 0  status. */
#else /* Word 0 - Little Endian */
        uint32_t a0_nonempty           : 1;  /**< [  0:  0](R/W1C/H) Clear status for VSB region A slice 0  status. */
        uint32_t a1_nonempty           : 1;  /**< [  1:  1](R/W1C/H) Clear status for VSB region A slice 1  status. */
        uint32_t a2_nonempty           : 1;  /**< [  2:  2](R/W1C/H) Clear status for VSB region A slice 2  status. */
        uint32_t a3_nonempty           : 1;  /**< [  3:  3](R/W1C/H) Clear status for VSB region A slice 3  status. */
        uint32_t b0_nonempty           : 1;  /**< [  4:  4](R/W1C/H) Clear status for VSB region B slice 0  status. */
        uint32_t b1_nonempty           : 1;  /**< [  5:  5](R/W1C/H) Clear status for VSB region B slice 1  status. */
        uint32_t b2_nonempty           : 1;  /**< [  6:  6](R/W1C/H) Clear status for VSB region B slice 2  status. */
        uint32_t b3_nonempty           : 1;  /**< [  7:  7](R/W1C/H) Clear status for VSB region B slice 3  status. */
        uint32_t c0_nonempty           : 1;  /**< [  8:  8](R/W1C/H) Clear status for VSB region C slice 0  status. */
        uint32_t c1_nonempty           : 1;  /**< [  9:  9](R/W1C/H) Clear status for VSB region C slice 1  status. */
        uint32_t c2_nonempty           : 1;  /**< [ 10: 10](R/W1C/H) Clear status for VSB region C slice 2  status. */
        uint32_t c3_nonempty           : 1;  /**< [ 11: 11](R/W1C/H) Clear status for VSB region C slice 3  status. */
        uint32_t d0_nonempty           : 1;  /**< [ 12: 12](R/W1C/H) Clear status for VSB region D slice 0  status. */
        uint32_t d1_nonempty           : 1;  /**< [ 13: 13](R/W1C/H) Clear status for VSB region D slice 1  status. */
        uint32_t d2_nonempty           : 1;  /**< [ 14: 14](R/W1C/H) Clear status for VSB region D slice 2  status. */
        uint32_t d3_nonempty           : 1;  /**< [ 15: 15](R/W1C/H) Clear status for VSB region D slice 3  status. */
        uint32_t a_overflow            : 1;  /**< [ 16: 16](R/W1C/H) Clear status for VSB region A  buffer overflow. */
        uint32_t b_overflow            : 1;  /**< [ 17: 17](R/W1C/H) Clear status for VSB region B  buffer overflow. */
        uint32_t c_overflow            : 1;  /**< [ 18: 18](R/W1C/H) Clear status for VSB region C  buffer overflow. */
        uint32_t d_overflow            : 1;  /**< [ 19: 19](R/W1C/H) Clear status for VSB region D buffer overflow. */
        uint32_t overlap               : 1;  /**< [ 20: 20](R/W1C/H) Clear status for VSB region overlap error.
                                                                   0 = no effect.
                                                                   1 = Clear Status. */
        uint32_t reserved_21_31        : 11;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crxvsb_int_clr_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crxvsb_int_clr_lnx cavm_cprix_cn4ipx_crxvsb_int_clr_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRXVSB_INT_CLR_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRXVSB_INT_CLR_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000820264ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRXVSB_INT_CLR_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRXVSB_INT_CLR_LNX(a,b,c) cavm_cprix_cn4ipx_crxvsb_int_clr_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRXVSB_INT_CLR_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRXVSB_INT_CLR_LNX(a,b,c) "CPRIX_CN4IPX_CRXVSB_INT_CLR_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRXVSB_INT_CLR_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRXVSB_INT_CLR_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_crxvsb_int_msk_ln#
 *
 * CPRI CONN4 IP CPRI RX VSB Buffer Interrupt Event Mask Register
 */
union cavm_cprix_cn4ipx_crxvsb_int_msk_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crxvsb_int_msk_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_21_31        : 11;
        uint32_t overlap               : 1;  /**< [ 20: 20](R/W) Mask status for VSB region overlap error.
                                                                   0 = Interrupt enabled.
                                                                   1 = Interrupt masked. */
        uint32_t d_overflow            : 1;  /**< [ 19: 19](R/W) Mask status for VSB region D buffer overflow. */
        uint32_t c_overflow            : 1;  /**< [ 18: 18](R/W) Mask status for VSB region C  buffer overflow. */
        uint32_t b_overflow            : 1;  /**< [ 17: 17](R/W) Mask status for VSB region B  buffer overflow. */
        uint32_t a_overflow            : 1;  /**< [ 16: 16](R/W) Mask status for VSB region A  buffer overflow. */
        uint32_t d3_nonempty           : 1;  /**< [ 15: 15](R/W) Mask status for VSB region D slice 3  status. */
        uint32_t d2_nonempty           : 1;  /**< [ 14: 14](R/W) Mask status for VSB region D slice 2  status. */
        uint32_t d1_nonempty           : 1;  /**< [ 13: 13](R/W) Mask status for VSB region D slice 1  status. */
        uint32_t d0_nonempty           : 1;  /**< [ 12: 12](R/W) Mask status for VSB region D slice 0  status. */
        uint32_t c3_nonempty           : 1;  /**< [ 11: 11](R/W) Mask status for VSB region C slice 3  status. */
        uint32_t c2_nonempty           : 1;  /**< [ 10: 10](R/W) Mask status for VSB region C slice 2  status. */
        uint32_t c1_nonempty           : 1;  /**< [  9:  9](R/W) Mask status for VSB region C slice 1  status. */
        uint32_t c0_nonempty           : 1;  /**< [  8:  8](R/W) Mask status for VSB region C slice 0  status. */
        uint32_t b3_nonempty           : 1;  /**< [  7:  7](R/W) Mask status for VSB region B slice 3  status. */
        uint32_t b2_nonempty           : 1;  /**< [  6:  6](R/W) Mask status for VSB region B slice 2  status. */
        uint32_t b1_nonempty           : 1;  /**< [  5:  5](R/W) Mask status for VSB region B slice 1  status. */
        uint32_t b0_nonempty           : 1;  /**< [  4:  4](R/W) Mask status for VSB region B slice 0  status. */
        uint32_t a3_nonempty           : 1;  /**< [  3:  3](R/W) Mask status for VSB region A slice 3  status. */
        uint32_t a2_nonempty           : 1;  /**< [  2:  2](R/W) Mask status for VSB region A slice 2  status. */
        uint32_t a1_nonempty           : 1;  /**< [  1:  1](R/W) Mask status for VSB region A slice 1  status. */
        uint32_t a0_nonempty           : 1;  /**< [  0:  0](R/W) Mask status for VSB region A slice 0  status. */
#else /* Word 0 - Little Endian */
        uint32_t a0_nonempty           : 1;  /**< [  0:  0](R/W) Mask status for VSB region A slice 0  status. */
        uint32_t a1_nonempty           : 1;  /**< [  1:  1](R/W) Mask status for VSB region A slice 1  status. */
        uint32_t a2_nonempty           : 1;  /**< [  2:  2](R/W) Mask status for VSB region A slice 2  status. */
        uint32_t a3_nonempty           : 1;  /**< [  3:  3](R/W) Mask status for VSB region A slice 3  status. */
        uint32_t b0_nonempty           : 1;  /**< [  4:  4](R/W) Mask status for VSB region B slice 0  status. */
        uint32_t b1_nonempty           : 1;  /**< [  5:  5](R/W) Mask status for VSB region B slice 1  status. */
        uint32_t b2_nonempty           : 1;  /**< [  6:  6](R/W) Mask status for VSB region B slice 2  status. */
        uint32_t b3_nonempty           : 1;  /**< [  7:  7](R/W) Mask status for VSB region B slice 3  status. */
        uint32_t c0_nonempty           : 1;  /**< [  8:  8](R/W) Mask status for VSB region C slice 0  status. */
        uint32_t c1_nonempty           : 1;  /**< [  9:  9](R/W) Mask status for VSB region C slice 1  status. */
        uint32_t c2_nonempty           : 1;  /**< [ 10: 10](R/W) Mask status for VSB region C slice 2  status. */
        uint32_t c3_nonempty           : 1;  /**< [ 11: 11](R/W) Mask status for VSB region C slice 3  status. */
        uint32_t d0_nonempty           : 1;  /**< [ 12: 12](R/W) Mask status for VSB region D slice 0  status. */
        uint32_t d1_nonempty           : 1;  /**< [ 13: 13](R/W) Mask status for VSB region D slice 1  status. */
        uint32_t d2_nonempty           : 1;  /**< [ 14: 14](R/W) Mask status for VSB region D slice 2  status. */
        uint32_t d3_nonempty           : 1;  /**< [ 15: 15](R/W) Mask status for VSB region D slice 3  status. */
        uint32_t a_overflow            : 1;  /**< [ 16: 16](R/W) Mask status for VSB region A  buffer overflow. */
        uint32_t b_overflow            : 1;  /**< [ 17: 17](R/W) Mask status for VSB region B  buffer overflow. */
        uint32_t c_overflow            : 1;  /**< [ 18: 18](R/W) Mask status for VSB region C  buffer overflow. */
        uint32_t d_overflow            : 1;  /**< [ 19: 19](R/W) Mask status for VSB region D buffer overflow. */
        uint32_t overlap               : 1;  /**< [ 20: 20](R/W) Mask status for VSB region overlap error.
                                                                   0 = Interrupt enabled.
                                                                   1 = Interrupt masked. */
        uint32_t reserved_21_31        : 11;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crxvsb_int_msk_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crxvsb_int_msk_lnx cavm_cprix_cn4ipx_crxvsb_int_msk_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRXVSB_INT_MSK_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRXVSB_INT_MSK_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000820270ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRXVSB_INT_MSK_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRXVSB_INT_MSK_LNX(a,b,c) cavm_cprix_cn4ipx_crxvsb_int_msk_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRXVSB_INT_MSK_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRXVSB_INT_MSK_LNX(a,b,c) "CPRIX_CN4IPX_CRXVSB_INT_MSK_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRXVSB_INT_MSK_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRXVSB_INT_MSK_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_crxvsb_int_set_ln#
 *
 * CPRI CONN4 IP CPRI RX VSB Buffer Interrupt Event Set Register
 */
union cavm_cprix_cn4ipx_crxvsb_int_set_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crxvsb_int_set_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_21_31        : 11;
        uint32_t overlap               : 1;  /**< [ 20: 20](R/W1S/H) Set status for VSB region overlap error.
                                                                   0 = no effect.
                                                                   1 = Set Status. */
        uint32_t d_overflow            : 1;  /**< [ 19: 19](R/W1S/H) Set status for VSB region D buffer overflow. */
        uint32_t c_overflow            : 1;  /**< [ 18: 18](R/W1S/H) Set status for VSB region C  buffer overflow. */
        uint32_t b_overflow            : 1;  /**< [ 17: 17](R/W1S/H) Set status for VSB region B  buffer overflow. */
        uint32_t a_overflow            : 1;  /**< [ 16: 16](R/W1S/H) Set status for VSB region A  buffer overflow. */
        uint32_t d3_nonempty           : 1;  /**< [ 15: 15](R/W1S/H) Set status for VSB region D slice 3  status. */
        uint32_t d2_nonempty           : 1;  /**< [ 14: 14](R/W1S/H) Set status for VSB region D slice 2  status. */
        uint32_t d1_nonempty           : 1;  /**< [ 13: 13](R/W1S/H) Set status for VSB region D slice 1  status. */
        uint32_t d0_nonempty           : 1;  /**< [ 12: 12](R/W1S/H) Set status for VSB region D slice 0  status. */
        uint32_t c3_nonempty           : 1;  /**< [ 11: 11](R/W1S/H) Set status for VSB region C slice 3  status. */
        uint32_t c2_nonempty           : 1;  /**< [ 10: 10](R/W1S/H) Set status for VSB region C slice 2  status. */
        uint32_t c1_nonempty           : 1;  /**< [  9:  9](R/W1S/H) Set status for VSB region C slice 1  status. */
        uint32_t c0_nonempty           : 1;  /**< [  8:  8](R/W1S/H) Set status for VSB region C slice 0  status. */
        uint32_t b3_nonempty           : 1;  /**< [  7:  7](R/W1S/H) Set status for VSB region B slice 3  status. */
        uint32_t b2_nonempty           : 1;  /**< [  6:  6](R/W1S/H) Set status for VSB region B slice 2  status. */
        uint32_t b1_nonempty           : 1;  /**< [  5:  5](R/W1S/H) Set status for VSB region B slice 1  status. */
        uint32_t b0_nonempty           : 1;  /**< [  4:  4](R/W1S/H) Set status for VSB region B slice 0  status. */
        uint32_t a3_nonempty           : 1;  /**< [  3:  3](R/W1S/H) Set status for VSB region A slice 3  status. */
        uint32_t a2_nonempty           : 1;  /**< [  2:  2](R/W1S/H) Set status for VSB region A slice 2  status. */
        uint32_t a1_nonempty           : 1;  /**< [  1:  1](R/W1S/H) Set status for VSB region A slice 1  status. */
        uint32_t a0_nonempty           : 1;  /**< [  0:  0](R/W1S/H) Set status for VSB region A slice 0  status. */
#else /* Word 0 - Little Endian */
        uint32_t a0_nonempty           : 1;  /**< [  0:  0](R/W1S/H) Set status for VSB region A slice 0  status. */
        uint32_t a1_nonempty           : 1;  /**< [  1:  1](R/W1S/H) Set status for VSB region A slice 1  status. */
        uint32_t a2_nonempty           : 1;  /**< [  2:  2](R/W1S/H) Set status for VSB region A slice 2  status. */
        uint32_t a3_nonempty           : 1;  /**< [  3:  3](R/W1S/H) Set status for VSB region A slice 3  status. */
        uint32_t b0_nonempty           : 1;  /**< [  4:  4](R/W1S/H) Set status for VSB region B slice 0  status. */
        uint32_t b1_nonempty           : 1;  /**< [  5:  5](R/W1S/H) Set status for VSB region B slice 1  status. */
        uint32_t b2_nonempty           : 1;  /**< [  6:  6](R/W1S/H) Set status for VSB region B slice 2  status. */
        uint32_t b3_nonempty           : 1;  /**< [  7:  7](R/W1S/H) Set status for VSB region B slice 3  status. */
        uint32_t c0_nonempty           : 1;  /**< [  8:  8](R/W1S/H) Set status for VSB region C slice 0  status. */
        uint32_t c1_nonempty           : 1;  /**< [  9:  9](R/W1S/H) Set status for VSB region C slice 1  status. */
        uint32_t c2_nonempty           : 1;  /**< [ 10: 10](R/W1S/H) Set status for VSB region C slice 2  status. */
        uint32_t c3_nonempty           : 1;  /**< [ 11: 11](R/W1S/H) Set status for VSB region C slice 3  status. */
        uint32_t d0_nonempty           : 1;  /**< [ 12: 12](R/W1S/H) Set status for VSB region D slice 0  status. */
        uint32_t d1_nonempty           : 1;  /**< [ 13: 13](R/W1S/H) Set status for VSB region D slice 1  status. */
        uint32_t d2_nonempty           : 1;  /**< [ 14: 14](R/W1S/H) Set status for VSB region D slice 2  status. */
        uint32_t d3_nonempty           : 1;  /**< [ 15: 15](R/W1S/H) Set status for VSB region D slice 3  status. */
        uint32_t a_overflow            : 1;  /**< [ 16: 16](R/W1S/H) Set status for VSB region A  buffer overflow. */
        uint32_t b_overflow            : 1;  /**< [ 17: 17](R/W1S/H) Set status for VSB region B  buffer overflow. */
        uint32_t c_overflow            : 1;  /**< [ 18: 18](R/W1S/H) Set status for VSB region C  buffer overflow. */
        uint32_t d_overflow            : 1;  /**< [ 19: 19](R/W1S/H) Set status for VSB region D buffer overflow. */
        uint32_t overlap               : 1;  /**< [ 20: 20](R/W1S/H) Set status for VSB region overlap error.
                                                                   0 = no effect.
                                                                   1 = Set Status. */
        uint32_t reserved_21_31        : 11;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crxvsb_int_set_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crxvsb_int_set_lnx cavm_cprix_cn4ipx_crxvsb_int_set_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRXVSB_INT_SET_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRXVSB_INT_SET_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000820268ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRXVSB_INT_SET_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRXVSB_INT_SET_LNX(a,b,c) cavm_cprix_cn4ipx_crxvsb_int_set_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRXVSB_INT_SET_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRXVSB_INT_SET_LNX(a,b,c) "CPRIX_CN4IPX_CRXVSB_INT_SET_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRXVSB_INT_SET_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRXVSB_INT_SET_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_crxvsb_int_sts_ln#
 *
 * CPRI CONN4 IP CPRI RX VSB Buffer Interrupt Status Register
 */
union cavm_cprix_cn4ipx_crxvsb_int_sts_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crxvsb_int_sts_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_21_31        : 11;
        uint32_t overlap               : 1;  /**< [ 20: 20](RO/H) VSB region overlap error.
                                                                   0 = no overlap detected.
                                                                   1 = VSB region overlap detected (configuration error). */
        uint32_t d_overflow            : 1;  /**< [ 19: 19](RO/H) VSB region D buffer overflow.
                                                                   0 = no overflows.
                                                                   1 = buffer overflow detected. */
        uint32_t c_overflow            : 1;  /**< [ 18: 18](RO/H) VSB region C  buffer overflow. */
        uint32_t b_overflow            : 1;  /**< [ 17: 17](RO/H) VSB region B  buffer overflow. */
        uint32_t a_overflow            : 1;  /**< [ 16: 16](RO/H) VSB region A  buffer overflow. */
        uint32_t d3_nonempty           : 1;  /**< [ 15: 15](RO/H) VSB region D slice 3  status.
                                                                   0 = no data in the buffer slice.
                                                                   1 = unread data in the buffer slice. */
        uint32_t d2_nonempty           : 1;  /**< [ 14: 14](RO/H) VSB region D slice 2  status. */
        uint32_t d1_nonempty           : 1;  /**< [ 13: 13](RO/H) VSB region D slice 1  status. */
        uint32_t d0_nonempty           : 1;  /**< [ 12: 12](RO/H) VSB region D slice 0  status. */
        uint32_t c3_nonempty           : 1;  /**< [ 11: 11](RO/H) VSB region C slice 3  status. */
        uint32_t c2_nonempty           : 1;  /**< [ 10: 10](RO/H) VSB region C slice 2  status. */
        uint32_t c1_nonempty           : 1;  /**< [  9:  9](RO/H) VSB region C slice 1  status. */
        uint32_t c0_nonempty           : 1;  /**< [  8:  8](RO/H) VSB region C slice 0  status. */
        uint32_t b3_nonempty           : 1;  /**< [  7:  7](RO/H) VSB region B slice 3  status. */
        uint32_t b2_nonempty           : 1;  /**< [  6:  6](RO/H) VSB region B slice 2  status. */
        uint32_t b1_nonempty           : 1;  /**< [  5:  5](RO/H) VSB region B slice 1  status. */
        uint32_t b0_nonempty           : 1;  /**< [  4:  4](RO/H) VSB region B slice 0  status. */
        uint32_t a3_nonempty           : 1;  /**< [  3:  3](RO/H) VSB region A slice 3  status. */
        uint32_t a2_nonempty           : 1;  /**< [  2:  2](RO/H) VSB region A slice 2  status. */
        uint32_t a1_nonempty           : 1;  /**< [  1:  1](RO/H) VSB region A slice 1  status. */
        uint32_t a0_nonempty           : 1;  /**< [  0:  0](RO/H) VSB region A slice 0  status. */
#else /* Word 0 - Little Endian */
        uint32_t a0_nonempty           : 1;  /**< [  0:  0](RO/H) VSB region A slice 0  status. */
        uint32_t a1_nonempty           : 1;  /**< [  1:  1](RO/H) VSB region A slice 1  status. */
        uint32_t a2_nonempty           : 1;  /**< [  2:  2](RO/H) VSB region A slice 2  status. */
        uint32_t a3_nonempty           : 1;  /**< [  3:  3](RO/H) VSB region A slice 3  status. */
        uint32_t b0_nonempty           : 1;  /**< [  4:  4](RO/H) VSB region B slice 0  status. */
        uint32_t b1_nonempty           : 1;  /**< [  5:  5](RO/H) VSB region B slice 1  status. */
        uint32_t b2_nonempty           : 1;  /**< [  6:  6](RO/H) VSB region B slice 2  status. */
        uint32_t b3_nonempty           : 1;  /**< [  7:  7](RO/H) VSB region B slice 3  status. */
        uint32_t c0_nonempty           : 1;  /**< [  8:  8](RO/H) VSB region C slice 0  status. */
        uint32_t c1_nonempty           : 1;  /**< [  9:  9](RO/H) VSB region C slice 1  status. */
        uint32_t c2_nonempty           : 1;  /**< [ 10: 10](RO/H) VSB region C slice 2  status. */
        uint32_t c3_nonempty           : 1;  /**< [ 11: 11](RO/H) VSB region C slice 3  status. */
        uint32_t d0_nonempty           : 1;  /**< [ 12: 12](RO/H) VSB region D slice 0  status. */
        uint32_t d1_nonempty           : 1;  /**< [ 13: 13](RO/H) VSB region D slice 1  status. */
        uint32_t d2_nonempty           : 1;  /**< [ 14: 14](RO/H) VSB region D slice 2  status. */
        uint32_t d3_nonempty           : 1;  /**< [ 15: 15](RO/H) VSB region D slice 3  status.
                                                                   0 = no data in the buffer slice.
                                                                   1 = unread data in the buffer slice. */
        uint32_t a_overflow            : 1;  /**< [ 16: 16](RO/H) VSB region A  buffer overflow. */
        uint32_t b_overflow            : 1;  /**< [ 17: 17](RO/H) VSB region B  buffer overflow. */
        uint32_t c_overflow            : 1;  /**< [ 18: 18](RO/H) VSB region C  buffer overflow. */
        uint32_t d_overflow            : 1;  /**< [ 19: 19](RO/H) VSB region D buffer overflow.
                                                                   0 = no overflows.
                                                                   1 = buffer overflow detected. */
        uint32_t overlap               : 1;  /**< [ 20: 20](RO/H) VSB region overlap error.
                                                                   0 = no overlap detected.
                                                                   1 = VSB region overlap detected (configuration error). */
        uint32_t reserved_21_31        : 11;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crxvsb_int_sts_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crxvsb_int_sts_lnx cavm_cprix_cn4ipx_crxvsb_int_sts_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRXVSB_INT_STS_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRXVSB_INT_STS_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000820260ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRXVSB_INT_STS_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRXVSB_INT_STS_LNX(a,b,c) cavm_cprix_cn4ipx_crxvsb_int_sts_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRXVSB_INT_STS_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRXVSB_INT_STS_LNX(a,b,c) "CPRIX_CN4IPX_CRXVSB_INT_STS_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRXVSB_INT_STS_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRXVSB_INT_STS_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_crxvsb_intmskc_ln#
 *
 * CPRI CONN4 IP CPRI RX VSB Buffer Interrupt Event Mask Clear Register
 */
union cavm_cprix_cn4ipx_crxvsb_intmskc_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crxvsb_intmskc_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_21_31        : 11;
        uint32_t overlap               : 1;  /**< [ 20: 20](R/W1C/H) Clear Mask status for VSB region overlap error.
                                                                   0 = No effect.
                                                                   1 = Clear mask. */
        uint32_t d_overflow            : 1;  /**< [ 19: 19](R/W1C/H) Clear Mask status for VSB region D buffer overflow. */
        uint32_t c_overflow            : 1;  /**< [ 18: 18](R/W1C/H) Clear Mask status for VSB region C  buffer overflow. */
        uint32_t b_overflow            : 1;  /**< [ 17: 17](R/W1C/H) Clear Mask status for VSB region B  buffer overflow. */
        uint32_t a_overflow            : 1;  /**< [ 16: 16](R/W1C/H) Clear Mask status for VSB region A  buffer overflow. */
        uint32_t d3_nonempty           : 1;  /**< [ 15: 15](R/W1C/H) Clear Mask status for VSB region D slice 3  status. */
        uint32_t d2_nonempty           : 1;  /**< [ 14: 14](R/W1C/H) Clear Mask status for VSB region D slice 2  status. */
        uint32_t d1_nonempty           : 1;  /**< [ 13: 13](R/W1C/H) Clear Mask status for VSB region D slice 1  status. */
        uint32_t d0_nonempty           : 1;  /**< [ 12: 12](R/W1C/H) Clear Mask status for VSB region D slice 0  status. */
        uint32_t c3_nonempty           : 1;  /**< [ 11: 11](R/W1C/H) Clear Mask status for VSB region C slice 3  status. */
        uint32_t c2_nonempty           : 1;  /**< [ 10: 10](R/W1C/H) Clear Mask status for VSB region C slice 2  status. */
        uint32_t c1_nonempty           : 1;  /**< [  9:  9](R/W1C/H) Clear Mask status for VSB region C slice 1  status. */
        uint32_t c0_nonempty           : 1;  /**< [  8:  8](R/W1C/H) Clear Mask status for VSB region C slice 0  status. */
        uint32_t b3_nonempty           : 1;  /**< [  7:  7](R/W1C/H) Clear Mask status for VSB region B slice 3  status. */
        uint32_t b2_nonempty           : 1;  /**< [  6:  6](R/W1C/H) Clear Mask status for VSB region B slice 2  status. */
        uint32_t b1_nonempty           : 1;  /**< [  5:  5](R/W1C/H) Clear Mask status for VSB region B slice 1  status. */
        uint32_t b0_nonempty           : 1;  /**< [  4:  4](R/W1C/H) Clear Mask status for VSB region B slice 0  status. */
        uint32_t a3_nonempty           : 1;  /**< [  3:  3](R/W1C/H) Clear Mask status for VSB region A slice 3  status. */
        uint32_t a2_nonempty           : 1;  /**< [  2:  2](R/W1C/H) Clear Mask status for VSB region A slice 2  status. */
        uint32_t a1_nonempty           : 1;  /**< [  1:  1](R/W1C/H) Clear Mask status for VSB region A slice 1  status. */
        uint32_t a0_nonempty           : 1;  /**< [  0:  0](R/W1C/H) Clear Mask status for VSB region A slice 0  status. */
#else /* Word 0 - Little Endian */
        uint32_t a0_nonempty           : 1;  /**< [  0:  0](R/W1C/H) Clear Mask status for VSB region A slice 0  status. */
        uint32_t a1_nonempty           : 1;  /**< [  1:  1](R/W1C/H) Clear Mask status for VSB region A slice 1  status. */
        uint32_t a2_nonempty           : 1;  /**< [  2:  2](R/W1C/H) Clear Mask status for VSB region A slice 2  status. */
        uint32_t a3_nonempty           : 1;  /**< [  3:  3](R/W1C/H) Clear Mask status for VSB region A slice 3  status. */
        uint32_t b0_nonempty           : 1;  /**< [  4:  4](R/W1C/H) Clear Mask status for VSB region B slice 0  status. */
        uint32_t b1_nonempty           : 1;  /**< [  5:  5](R/W1C/H) Clear Mask status for VSB region B slice 1  status. */
        uint32_t b2_nonempty           : 1;  /**< [  6:  6](R/W1C/H) Clear Mask status for VSB region B slice 2  status. */
        uint32_t b3_nonempty           : 1;  /**< [  7:  7](R/W1C/H) Clear Mask status for VSB region B slice 3  status. */
        uint32_t c0_nonempty           : 1;  /**< [  8:  8](R/W1C/H) Clear Mask status for VSB region C slice 0  status. */
        uint32_t c1_nonempty           : 1;  /**< [  9:  9](R/W1C/H) Clear Mask status for VSB region C slice 1  status. */
        uint32_t c2_nonempty           : 1;  /**< [ 10: 10](R/W1C/H) Clear Mask status for VSB region C slice 2  status. */
        uint32_t c3_nonempty           : 1;  /**< [ 11: 11](R/W1C/H) Clear Mask status for VSB region C slice 3  status. */
        uint32_t d0_nonempty           : 1;  /**< [ 12: 12](R/W1C/H) Clear Mask status for VSB region D slice 0  status. */
        uint32_t d1_nonempty           : 1;  /**< [ 13: 13](R/W1C/H) Clear Mask status for VSB region D slice 1  status. */
        uint32_t d2_nonempty           : 1;  /**< [ 14: 14](R/W1C/H) Clear Mask status for VSB region D slice 2  status. */
        uint32_t d3_nonempty           : 1;  /**< [ 15: 15](R/W1C/H) Clear Mask status for VSB region D slice 3  status. */
        uint32_t a_overflow            : 1;  /**< [ 16: 16](R/W1C/H) Clear Mask status for VSB region A  buffer overflow. */
        uint32_t b_overflow            : 1;  /**< [ 17: 17](R/W1C/H) Clear Mask status for VSB region B  buffer overflow. */
        uint32_t c_overflow            : 1;  /**< [ 18: 18](R/W1C/H) Clear Mask status for VSB region C  buffer overflow. */
        uint32_t d_overflow            : 1;  /**< [ 19: 19](R/W1C/H) Clear Mask status for VSB region D buffer overflow. */
        uint32_t overlap               : 1;  /**< [ 20: 20](R/W1C/H) Clear Mask status for VSB region overlap error.
                                                                   0 = No effect.
                                                                   1 = Clear mask. */
        uint32_t reserved_21_31        : 11;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crxvsb_intmskc_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crxvsb_intmskc_lnx cavm_cprix_cn4ipx_crxvsb_intmskc_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRXVSB_INTMSKC_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRXVSB_INTMSKC_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000820274ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRXVSB_INTMSKC_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRXVSB_INTMSKC_LNX(a,b,c) cavm_cprix_cn4ipx_crxvsb_intmskc_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRXVSB_INTMSKC_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRXVSB_INTMSKC_LNX(a,b,c) "CPRIX_CN4IPX_CRXVSB_INTMSKC_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRXVSB_INTMSKC_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRXVSB_INTMSKC_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_crxvsb_intmsks_ln#
 *
 * CPRI CONN4 IP CPRI RX VSB Buffer Interrupt Event Mask Set Register
 */
union cavm_cprix_cn4ipx_crxvsb_intmsks_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crxvsb_intmsks_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_21_31        : 11;
        uint32_t overlap               : 1;  /**< [ 20: 20](R/W1S/H) Set Mask status for VSB region overlap error.
                                                                   0 = No effect.
                                                                   1 = Set Mask. */
        uint32_t d_overflow            : 1;  /**< [ 19: 19](R/W1S/H) Set Mask status for VSB region D buffer overflow. */
        uint32_t c_overflow            : 1;  /**< [ 18: 18](R/W1S/H) Set Mask status for VSB region C  buffer overflow. */
        uint32_t b_overflow            : 1;  /**< [ 17: 17](R/W1S/H) Set Mask status for VSB region B  buffer overflow. */
        uint32_t a_overflow            : 1;  /**< [ 16: 16](R/W1S/H) Set Mask status for VSB region A  buffer overflow. */
        uint32_t d3_nonempty           : 1;  /**< [ 15: 15](R/W1S/H) Set Mask status for VSB region D slice 3  status. */
        uint32_t d2_nonempty           : 1;  /**< [ 14: 14](R/W1S/H) Set Mask status for VSB region D slice 2  status. */
        uint32_t d1_nonempty           : 1;  /**< [ 13: 13](R/W1S/H) Set Mask status for VSB region D slice 1  status. */
        uint32_t d0_nonempty           : 1;  /**< [ 12: 12](R/W1S/H) Set Mask status for VSB region D slice 0  status. */
        uint32_t c3_nonempty           : 1;  /**< [ 11: 11](R/W1S/H) Set Mask status for VSB region C slice 3  status. */
        uint32_t c2_nonempty           : 1;  /**< [ 10: 10](R/W1S/H) Set Mask status for VSB region C slice 2  status. */
        uint32_t c1_nonempty           : 1;  /**< [  9:  9](R/W1S/H) Set Mask status for VSB region C slice 1  status. */
        uint32_t c0_nonempty           : 1;  /**< [  8:  8](R/W1S/H) Set Mask status for VSB region C slice 0  status. */
        uint32_t b3_nonempty           : 1;  /**< [  7:  7](R/W1S/H) Set Mask status for VSB region B slice 3  status. */
        uint32_t b2_nonempty           : 1;  /**< [  6:  6](R/W1S/H) Set Mask status for VSB region B slice 2  status. */
        uint32_t b1_nonempty           : 1;  /**< [  5:  5](R/W1S/H) Set Mask status for VSB region B slice 1  status. */
        uint32_t b0_nonempty           : 1;  /**< [  4:  4](R/W1S/H) Set Mask status for VSB region B slice 0  status. */
        uint32_t a3_nonempty           : 1;  /**< [  3:  3](R/W1S/H) Set Mask status for VSB region A slice 3  status. */
        uint32_t a2_nonempty           : 1;  /**< [  2:  2](R/W1S/H) Set Mask status for VSB region A slice 2  status. */
        uint32_t a1_nonempty           : 1;  /**< [  1:  1](R/W1S/H) Set Mask status for VSB region A slice 1  status. */
        uint32_t a0_nonempty           : 1;  /**< [  0:  0](R/W1S/H) Set Mask status for VSB region A slice 0  status. */
#else /* Word 0 - Little Endian */
        uint32_t a0_nonempty           : 1;  /**< [  0:  0](R/W1S/H) Set Mask status for VSB region A slice 0  status. */
        uint32_t a1_nonempty           : 1;  /**< [  1:  1](R/W1S/H) Set Mask status for VSB region A slice 1  status. */
        uint32_t a2_nonempty           : 1;  /**< [  2:  2](R/W1S/H) Set Mask status for VSB region A slice 2  status. */
        uint32_t a3_nonempty           : 1;  /**< [  3:  3](R/W1S/H) Set Mask status for VSB region A slice 3  status. */
        uint32_t b0_nonempty           : 1;  /**< [  4:  4](R/W1S/H) Set Mask status for VSB region B slice 0  status. */
        uint32_t b1_nonempty           : 1;  /**< [  5:  5](R/W1S/H) Set Mask status for VSB region B slice 1  status. */
        uint32_t b2_nonempty           : 1;  /**< [  6:  6](R/W1S/H) Set Mask status for VSB region B slice 2  status. */
        uint32_t b3_nonempty           : 1;  /**< [  7:  7](R/W1S/H) Set Mask status for VSB region B slice 3  status. */
        uint32_t c0_nonempty           : 1;  /**< [  8:  8](R/W1S/H) Set Mask status for VSB region C slice 0  status. */
        uint32_t c1_nonempty           : 1;  /**< [  9:  9](R/W1S/H) Set Mask status for VSB region C slice 1  status. */
        uint32_t c2_nonempty           : 1;  /**< [ 10: 10](R/W1S/H) Set Mask status for VSB region C slice 2  status. */
        uint32_t c3_nonempty           : 1;  /**< [ 11: 11](R/W1S/H) Set Mask status for VSB region C slice 3  status. */
        uint32_t d0_nonempty           : 1;  /**< [ 12: 12](R/W1S/H) Set Mask status for VSB region D slice 0  status. */
        uint32_t d1_nonempty           : 1;  /**< [ 13: 13](R/W1S/H) Set Mask status for VSB region D slice 1  status. */
        uint32_t d2_nonempty           : 1;  /**< [ 14: 14](R/W1S/H) Set Mask status for VSB region D slice 2  status. */
        uint32_t d3_nonempty           : 1;  /**< [ 15: 15](R/W1S/H) Set Mask status for VSB region D slice 3  status. */
        uint32_t a_overflow            : 1;  /**< [ 16: 16](R/W1S/H) Set Mask status for VSB region A  buffer overflow. */
        uint32_t b_overflow            : 1;  /**< [ 17: 17](R/W1S/H) Set Mask status for VSB region B  buffer overflow. */
        uint32_t c_overflow            : 1;  /**< [ 18: 18](R/W1S/H) Set Mask status for VSB region C  buffer overflow. */
        uint32_t d_overflow            : 1;  /**< [ 19: 19](R/W1S/H) Set Mask status for VSB region D buffer overflow. */
        uint32_t overlap               : 1;  /**< [ 20: 20](R/W1S/H) Set Mask status for VSB region overlap error.
                                                                   0 = No effect.
                                                                   1 = Set Mask. */
        uint32_t reserved_21_31        : 11;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crxvsb_intmsks_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crxvsb_intmsks_lnx cavm_cprix_cn4ipx_crxvsb_intmsks_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRXVSB_INTMSKS_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRXVSB_INTMSKS_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000820278ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRXVSB_INTMSKS_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRXVSB_INTMSKS_LNX(a,b,c) cavm_cprix_cn4ipx_crxvsb_intmsks_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRXVSB_INTMSKS_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRXVSB_INTMSKS_LNX(a,b,c) "CPRIX_CN4IPX_CRXVSB_INTMSKS_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRXVSB_INTMSKS_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRXVSB_INTMSKS_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_crxvsb_overlap_ln#
 *
 * CPRI CONN4 IP CPRI RX VSB Region A/B/C/D Overlap Status Register
 */
union cavm_cprix_cn4ipx_crxvsb_overlap_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_crxvsb_overlap_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t region_overlap        : 5;  /**< [  4:  0](RO/H) VSB region overlapping error. Simultaneous '1' bits indicates that more than one
                                                                 region tries to write to the buffer RAM at the same clock cycle:
                                                                   bit 4 : VSB region D buffer.
                                                                   bit 3 : VSB region C buffer.
                                                                   bit 2 : VSB region B buffer.
                                                                   bit 1 : VSB region A buffer.
                                                                   bit 0 : HDLC buffer. */
#else /* Word 0 - Little Endian */
        uint32_t region_overlap        : 5;  /**< [  4:  0](RO/H) VSB region overlapping error. Simultaneous '1' bits indicates that more than one
                                                                 region tries to write to the buffer RAM at the same clock cycle:
                                                                   bit 4 : VSB region D buffer.
                                                                   bit 3 : VSB region C buffer.
                                                                   bit 2 : VSB region B buffer.
                                                                   bit 1 : VSB region A buffer.
                                                                   bit 0 : HDLC buffer. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_crxvsb_overlap_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_crxvsb_overlap_lnx cavm_cprix_cn4ipx_crxvsb_overlap_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CRXVSB_OVERLAP_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CRXVSB_OVERLAP_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x86400082027cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CRXVSB_OVERLAP_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CRXVSB_OVERLAP_LNX(a,b,c) cavm_cprix_cn4ipx_crxvsb_overlap_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CRXVSB_OVERLAP_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CRXVSB_OVERLAP_LNX(a,b,c) "CPRIX_CN4IPX_CRXVSB_OVERLAP_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CRXVSB_OVERLAP_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CRXVSB_OVERLAP_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_axc#_airfrm_ln#
 *
 * CPRI CONN4 IP CPRI TX AXC Air Interface Frame Synchronization Configuration Register
 */
union cavm_cprix_cn4ipx_ctx_axcx_airfrm_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_axcx_airfrm_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t airframe_x            : 8;  /**< [ 15:  8](R/W) Basic frame number X at start of air interface frame.
                                                                     0 .. 0xFF = valid. */
        uint32_t airframe_z            : 8;  /**< [  7:  0](R/W) Hyperframe number Z at start of air interface frame.
                                                                       0 .. 0x95 = valid.
                                                                     0x96 .. 0xFF = not valid. */
#else /* Word 0 - Little Endian */
        uint32_t airframe_z            : 8;  /**< [  7:  0](R/W) Hyperframe number Z at start of air interface frame.
                                                                       0 .. 0x95 = valid.
                                                                     0x96 .. 0xFF = not valid. */
        uint32_t airframe_x            : 8;  /**< [ 15:  8](R/W) Basic frame number X at start of air interface frame.
                                                                     0 .. 0xFF = valid. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_axcx_airfrm_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_axcx_airfrm_lnx cavm_cprix_cn4ipx_ctx_axcx_airfrm_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_AXCX_AIRFRM_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_AXCX_AIRFRM_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=63) && (d<=1)))
        return 0x864000828408ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10ll * ((c) & 0x3f) + 0x10000ll * ((d) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_AXCX_AIRFRM_LNX", 4, a, b, c, d, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_AXCX_AIRFRM_LNX(a,b,c,d) cavm_cprix_cn4ipx_ctx_axcx_airfrm_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_AXCX_AIRFRM_LNX(a,b,c,d) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_AXCX_AIRFRM_LNX(a,b,c,d) "CPRIX_CN4IPX_CTX_AXCX_AIRFRM_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_AXCX_AIRFRM_LNX(a,b,c,d) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_AXCX_AIRFRM_LNX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_axc#_contnr_ln#
 *
 * CPRI CONN4 IP CPRI TX AXC Ownership Configuration Register
 */
union cavm_cprix_cn4ipx_ctx_axcx_contnr_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_axcx_contnr_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_29_31        : 3;
        uint32_t enable_f              : 1;  /**< [ 28: 28](R/W) Enable free format configuration of IQ sample via CONTAINER_F field.
                                                                   0 = disabled, use CONTAINER_M.
                                                                   1 = enabled, use CONTAINER_F. */
        uint32_t container_f           : 4;  /**< [ 27: 24](R/W) Free formatting of an IQ sample. Indicates how an RP3 sample data word of 32
                                                                 bits is converted to CPRI. Least significant bits redundant in CPRI are enclosed
                                                                 in parenthesis. Those bits are removed in RP3 to CPRI conversion and replaced
                                                                 with a bit having a value of zero in CPRI to RP3 conversion.
                                                                      0x6 = 7+(1)+7+(1)+7+(1)+7+(1).
                                                                      0x7 = 8 + 8 + 8 + 8.
                                                                      0x8 = 9 + (7) + 9 + (7).
                                                                      0x9 = not supported.
                                                                      0xA = not supported.
                                                                      0xB = 12 + (4) + 12 + (4).
                                                                      0xC = not supported.
                                                                      0xD = not supported.
                                                                      0xE = 15 + (1) + 15 + (1).
                                                                      0xF = 16 + 16.
                                                                    others = not used.
                                                                 Note: Content of this field is used only if value of ENABLE_F field is one. */
        uint32_t reserved_23           : 1;
        uint32_t container_n           : 3;  /**< [ 22: 20](R/W) Number IQ samples in one AxC container. For example one 15 bit IQ sample
                                                                 requires a total space of 30 bits.
                                                                    0 = one 9/12/15/16 bit IQ sample or two 7/8 bit IQ samples.
                                                                    1 = two 9/12/15/16 bit IQ samples or four 7/8 bit IQ samples.
                                                                    2 = three 9/12/15/16 bit IQ samples or six 7/8 bit IQ samples.
                                                                    3 = four 9/12/15/16 bit IQ samples or eight 7/8 bit IQ samples.
                                                                    4 = reserved.
                                                                    5 = six 9/12/15/16 bit IQ samples or twelve 7/8 bit IQ samples.
                                                                    6 = reserved.
                                                                    7 = eight 9/12/15/16 bit IQ samples or sixteen 7/8 bit IQ samples. */
        uint32_t reserved_18_19        : 2;
        uint32_t container_m           : 2;  /**< [ 17: 16](R/W) Formatting of an IQ sample. Indicates how an RP3 sample data word of 32 bits is
                                                                 converted to CPRI. Least significant bits redundant in CPRI are enclosed in
                                                                 parenthesis. Those bits are replaced with a bit having a value of zero in CPRI
                                                                 to RP3 conversion.
                                                                   0 = 7 + (1) + 7 + (1) + 7 + (1) + 7 + (1).
                                                                   1 = 15 + (1) + 15 + (1).
                                                                   2 = 8 + 8 + 8 + 8.
                                                                   3 = 16 + 16.

                                                                 Total length of a 32-bit RP3 sample word in a CPRI AxC container including bit stuffing.
                                                                   0 = 28 bits.
                                                                   1 = 30 bits.
                                                                   2 = 32 bits.
                                                                   3 = 32 bits. */
        uint32_t reserved_13_15        : 3;
        uint32_t container_k           : 1;  /**< [ 12: 12](R/W) Number K of basic frames in the AxC container block.
                                                                   0 = one.
                                                                   1 = two. */
        uint32_t reserved_11           : 1;
        uint32_t container_b2          : 6;  /**< [ 10:  5](R/W) Basic frame bit coordinate B at start of AxC container divided by 2.
                                                                     0 ..  7 = valid for all rates.
                                                                     8 .. 0xF = valid for rates \>= 2457.6 Mbps.
                                                                    0x10 .. 0x1F = valid for rates \>= 4915.2 Mbps.
                                                                    0x20 .. 0x27 = valid for rate \>= 6144.0 Mbps.
                                                                    0x28 .. 0x3F = valid for rate = 9830.4 Mbps. */
        uint32_t reserved_4            : 1;
        uint32_t container_w           : 4;  /**< [  3:  0](R/W) Basic frame word coordinate W at start of AxC container.
                                                                           0 = not valid.
                                                                     1 .. 0xF = valid. */
#else /* Word 0 - Little Endian */
        uint32_t container_w           : 4;  /**< [  3:  0](R/W) Basic frame word coordinate W at start of AxC container.
                                                                           0 = not valid.
                                                                     1 .. 0xF = valid. */
        uint32_t reserved_4            : 1;
        uint32_t container_b2          : 6;  /**< [ 10:  5](R/W) Basic frame bit coordinate B at start of AxC container divided by 2.
                                                                     0 ..  7 = valid for all rates.
                                                                     8 .. 0xF = valid for rates \>= 2457.6 Mbps.
                                                                    0x10 .. 0x1F = valid for rates \>= 4915.2 Mbps.
                                                                    0x20 .. 0x27 = valid for rate \>= 6144.0 Mbps.
                                                                    0x28 .. 0x3F = valid for rate = 9830.4 Mbps. */
        uint32_t reserved_11           : 1;
        uint32_t container_k           : 1;  /**< [ 12: 12](R/W) Number K of basic frames in the AxC container block.
                                                                   0 = one.
                                                                   1 = two. */
        uint32_t reserved_13_15        : 3;
        uint32_t container_m           : 2;  /**< [ 17: 16](R/W) Formatting of an IQ sample. Indicates how an RP3 sample data word of 32 bits is
                                                                 converted to CPRI. Least significant bits redundant in CPRI are enclosed in
                                                                 parenthesis. Those bits are replaced with a bit having a value of zero in CPRI
                                                                 to RP3 conversion.
                                                                   0 = 7 + (1) + 7 + (1) + 7 + (1) + 7 + (1).
                                                                   1 = 15 + (1) + 15 + (1).
                                                                   2 = 8 + 8 + 8 + 8.
                                                                   3 = 16 + 16.

                                                                 Total length of a 32-bit RP3 sample word in a CPRI AxC container including bit stuffing.
                                                                   0 = 28 bits.
                                                                   1 = 30 bits.
                                                                   2 = 32 bits.
                                                                   3 = 32 bits. */
        uint32_t reserved_18_19        : 2;
        uint32_t container_n           : 3;  /**< [ 22: 20](R/W) Number IQ samples in one AxC container. For example one 15 bit IQ sample
                                                                 requires a total space of 30 bits.
                                                                    0 = one 9/12/15/16 bit IQ sample or two 7/8 bit IQ samples.
                                                                    1 = two 9/12/15/16 bit IQ samples or four 7/8 bit IQ samples.
                                                                    2 = three 9/12/15/16 bit IQ samples or six 7/8 bit IQ samples.
                                                                    3 = four 9/12/15/16 bit IQ samples or eight 7/8 bit IQ samples.
                                                                    4 = reserved.
                                                                    5 = six 9/12/15/16 bit IQ samples or twelve 7/8 bit IQ samples.
                                                                    6 = reserved.
                                                                    7 = eight 9/12/15/16 bit IQ samples or sixteen 7/8 bit IQ samples. */
        uint32_t reserved_23           : 1;
        uint32_t container_f           : 4;  /**< [ 27: 24](R/W) Free formatting of an IQ sample. Indicates how an RP3 sample data word of 32
                                                                 bits is converted to CPRI. Least significant bits redundant in CPRI are enclosed
                                                                 in parenthesis. Those bits are removed in RP3 to CPRI conversion and replaced
                                                                 with a bit having a value of zero in CPRI to RP3 conversion.
                                                                      0x6 = 7+(1)+7+(1)+7+(1)+7+(1).
                                                                      0x7 = 8 + 8 + 8 + 8.
                                                                      0x8 = 9 + (7) + 9 + (7).
                                                                      0x9 = not supported.
                                                                      0xA = not supported.
                                                                      0xB = 12 + (4) + 12 + (4).
                                                                      0xC = not supported.
                                                                      0xD = not supported.
                                                                      0xE = 15 + (1) + 15 + (1).
                                                                      0xF = 16 + 16.
                                                                    others = not used.
                                                                 Note: Content of this field is used only if value of ENABLE_F field is one. */
        uint32_t enable_f              : 1;  /**< [ 28: 28](R/W) Enable free format configuration of IQ sample via CONTAINER_F field.
                                                                   0 = disabled, use CONTAINER_M.
                                                                   1 = enabled, use CONTAINER_F. */
        uint32_t reserved_29_31        : 3;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_axcx_contnr_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_axcx_contnr_lnx cavm_cprix_cn4ipx_ctx_axcx_contnr_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_AXCX_CONTNR_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_AXCX_CONTNR_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=63) && (d<=1)))
        return 0x86400082840cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10ll * ((c) & 0x3f) + 0x10000ll * ((d) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_AXCX_CONTNR_LNX", 4, a, b, c, d, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_AXCX_CONTNR_LNX(a,b,c,d) cavm_cprix_cn4ipx_ctx_axcx_contnr_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_AXCX_CONTNR_LNX(a,b,c,d) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_AXCX_CONTNR_LNX(a,b,c,d) "CPRIX_CN4IPX_CTX_AXCX_CONTNR_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_AXCX_CONTNR_LNX(a,b,c,d) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_AXCX_CONTNR_LNX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_axc#_generl_ln#
 *
 * CPRI CONN4 IP CPRI TX AXC General Configuration Register
 */
union cavm_cprix_cn4ipx_ctx_axcx_generl_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_axcx_generl_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_11_31        : 21;
        uint32_t gsm                   : 1;  /**< [ 10: 10](R/W) GSM tunnel enable. Forces allocation of this AxC to secondary Stream Router interface.
                                                                   0 = disable.
                                                                   1 = enable. */
        uint32_t secondary             : 1;  /**< [  9:  9](R/W) Stream Router interface selection when hardware allocation is overridden..
                                                                   0 = primary.
                                                                   1 = secondary.

                                                                 Register field SECONDARY of the current combination of enabled carriers in CTX
                                                                 should be set so, that no more than half of the AxC message bandwidth from
                                                                 Stream Router is allocated to the secondary interface. Consumed message
                                                                 bandwidth based on CONTAINER_N is as follows:
                                                                               0 =\> 1 msg per four Basic Frames.
                                                                               1 =\> 2 msg per four Basic Frames.
                                                                            2, 3 =\> 4 msg per four Basic Frames.
                                                                      4, 5, 6, 7 =\> 8 msg per four Basic Frames. */
        uint32_t override              : 1;  /**< [  8:  8](R/W) Override automatic Stream Router interface allocation.
                                                                   0 = no override.
                                                                   1 = override. */
        uint32_t inactive              : 1;  /**< [  7:  7](RO/H) Indication that AxC has been enabled, but has not transmitted.
                                                                   0 = disabled or transmitted.
                                                                   1 = not transmitted. */
        uint32_t miss                  : 1;  /**< [  6:  6](RO/H) Indication that AxC has started transmission, but following that at least one
                                                                 message was not received from Stream Router.
                                                                   0 = no misses occurred.
                                                                   1 = misses occurred. */
        uint32_t saturated             : 1;  /**< [  5:  5](RO/H) Indicator that clipping and saturation has occurred when converting samples from
                                                                 RP3 to CPRI. This is only possible if SATURATE field has been configured as one.
                                                                 To clear this status, the AxC has to be disabled.
                                                                   0 = no clipping has occurred.
                                                                   1 = a sample was clipped. */
        uint32_t interface_s           : 1;  /**< [  4:  4](RO/H) Indicator of the Stream Router interface. Interface is allocated automatically
                                                                 by hardware. The value of this field is informational only.
                                                                   0 = Primary interface.
                                                                   1 = Secondary interface.

                                                                 Note: If CONTAINER_N of any AxC is modified while that AxC is enabled, interface
                                                                 allocation of any AxC may fail until CTX has been disabled by writing zero to
                                                                 CTX_CTRL:CTX_EN. */
        uint32_t compress              : 1;  /**< [  3:  3](R/W) Compression enable. When enabled, IQ samples are compressed by CTX Law function.
                                                                   0 = disabled.
                                                                   1 = enabled. */
        uint32_t round                 : 1;  /**< [  2:  2](R/W) Rounding enable. When enabled, compressed IQ samples are converted from 12 bits
                                                                 to 9 bits using convergent rounding as specified by IEEE 754 method "round to
                                                                 nearest, ties to even".
                                                                   0 = disabled.
                                                                   1 = enabled. */
        uint32_t mode                  : 1;  /**< [  1:  1](R/W) Operation mode of AxC. In normal mode the AxC payload data is requested and
                                                                 received from Stream router. In test mode the AxC payload data is generated
                                                                 internally.
                                                                   0 = normal mode.
                                                                   1 = test mode. */
        uint32_t enable                : 1;  /**< [  0:  0](R/W) State of this antenna carrier. AxC does not transmit any data into CPRI TX frame
                                                                 before it has been enabled.
                                                                   0 = AxC is disabled.
                                                                   1 = AxC is enabled.

                                                                 For enabling an AxC, global setting CTX_CTRL:CTX_EN must also be enabled.

                                                                 For restarting the air interface frame, CTX AxC needs to be first disabled and then re-enabled.

                                                                 Please note that value of the other fields of this register must not be changed
                                                                 when asserting ENABLE. */
#else /* Word 0 - Little Endian */
        uint32_t enable                : 1;  /**< [  0:  0](R/W) State of this antenna carrier. AxC does not transmit any data into CPRI TX frame
                                                                 before it has been enabled.
                                                                   0 = AxC is disabled.
                                                                   1 = AxC is enabled.

                                                                 For enabling an AxC, global setting CTX_CTRL:CTX_EN must also be enabled.

                                                                 For restarting the air interface frame, CTX AxC needs to be first disabled and then re-enabled.

                                                                 Please note that value of the other fields of this register must not be changed
                                                                 when asserting ENABLE. */
        uint32_t mode                  : 1;  /**< [  1:  1](R/W) Operation mode of AxC. In normal mode the AxC payload data is requested and
                                                                 received from Stream router. In test mode the AxC payload data is generated
                                                                 internally.
                                                                   0 = normal mode.
                                                                   1 = test mode. */
        uint32_t round                 : 1;  /**< [  2:  2](R/W) Rounding enable. When enabled, compressed IQ samples are converted from 12 bits
                                                                 to 9 bits using convergent rounding as specified by IEEE 754 method "round to
                                                                 nearest, ties to even".
                                                                   0 = disabled.
                                                                   1 = enabled. */
        uint32_t compress              : 1;  /**< [  3:  3](R/W) Compression enable. When enabled, IQ samples are compressed by CTX Law function.
                                                                   0 = disabled.
                                                                   1 = enabled. */
        uint32_t interface_s           : 1;  /**< [  4:  4](RO/H) Indicator of the Stream Router interface. Interface is allocated automatically
                                                                 by hardware. The value of this field is informational only.
                                                                   0 = Primary interface.
                                                                   1 = Secondary interface.

                                                                 Note: If CONTAINER_N of any AxC is modified while that AxC is enabled, interface
                                                                 allocation of any AxC may fail until CTX has been disabled by writing zero to
                                                                 CTX_CTRL:CTX_EN. */
        uint32_t saturated             : 1;  /**< [  5:  5](RO/H) Indicator that clipping and saturation has occurred when converting samples from
                                                                 RP3 to CPRI. This is only possible if SATURATE field has been configured as one.
                                                                 To clear this status, the AxC has to be disabled.
                                                                   0 = no clipping has occurred.
                                                                   1 = a sample was clipped. */
        uint32_t miss                  : 1;  /**< [  6:  6](RO/H) Indication that AxC has started transmission, but following that at least one
                                                                 message was not received from Stream Router.
                                                                   0 = no misses occurred.
                                                                   1 = misses occurred. */
        uint32_t inactive              : 1;  /**< [  7:  7](RO/H) Indication that AxC has been enabled, but has not transmitted.
                                                                   0 = disabled or transmitted.
                                                                   1 = not transmitted. */
        uint32_t override              : 1;  /**< [  8:  8](R/W) Override automatic Stream Router interface allocation.
                                                                   0 = no override.
                                                                   1 = override. */
        uint32_t secondary             : 1;  /**< [  9:  9](R/W) Stream Router interface selection when hardware allocation is overridden..
                                                                   0 = primary.
                                                                   1 = secondary.

                                                                 Register field SECONDARY of the current combination of enabled carriers in CTX
                                                                 should be set so, that no more than half of the AxC message bandwidth from
                                                                 Stream Router is allocated to the secondary interface. Consumed message
                                                                 bandwidth based on CONTAINER_N is as follows:
                                                                               0 =\> 1 msg per four Basic Frames.
                                                                               1 =\> 2 msg per four Basic Frames.
                                                                            2, 3 =\> 4 msg per four Basic Frames.
                                                                      4, 5, 6, 7 =\> 8 msg per four Basic Frames. */
        uint32_t gsm                   : 1;  /**< [ 10: 10](R/W) GSM tunnel enable. Forces allocation of this AxC to secondary Stream Router interface.
                                                                   0 = disable.
                                                                   1 = enable. */
        uint32_t reserved_11_31        : 21;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_axcx_generl_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_axcx_generl_lnx cavm_cprix_cn4ipx_ctx_axcx_generl_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_AXCX_GENERL_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_AXCX_GENERL_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=63) && (d<=1)))
        return 0x864000828400ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10ll * ((c) & 0x3f) + 0x10000ll * ((d) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_AXCX_GENERL_LNX", 4, a, b, c, d, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_AXCX_GENERL_LNX(a,b,c,d) cavm_cprix_cn4ipx_ctx_axcx_generl_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_AXCX_GENERL_LNX(a,b,c,d) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_AXCX_GENERL_LNX(a,b,c,d) "CPRIX_CN4IPX_CTX_AXCX_GENERL_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_AXCX_GENERL_LNX(a,b,c,d) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_AXCX_GENERL_LNX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_axc#_stream_ln#
 *
 * CPRI CONN4 IP CPRI TX AXC General Configuration Register
 */
union cavm_cprix_cn4ipx_ctx_axcx_stream_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_axcx_stream_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_18_31        : 14;
        uint32_t stream_ts             : 6;  /**< [ 17: 12](R/W) Timestamp of the first message of the air interface frame requested from Stream Router.
                                                                 Timestamp should always be configured as zero. */
        uint32_t reserved_8_11         : 4;
        uint32_t stream_id             : 8;  /**< [  7:  0](R/W) Stream ID in Stream Router for sourcing AxC data for CPRI transmission.
                                                                 Valid values for Stream ID are defined in description of Stream Router. */
#else /* Word 0 - Little Endian */
        uint32_t stream_id             : 8;  /**< [  7:  0](R/W) Stream ID in Stream Router for sourcing AxC data for CPRI transmission.
                                                                 Valid values for Stream ID are defined in description of Stream Router. */
        uint32_t reserved_8_11         : 4;
        uint32_t stream_ts             : 6;  /**< [ 17: 12](R/W) Timestamp of the first message of the air interface frame requested from Stream Router.
                                                                 Timestamp should always be configured as zero. */
        uint32_t reserved_18_31        : 14;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_axcx_stream_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_axcx_stream_lnx cavm_cprix_cn4ipx_ctx_axcx_stream_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_AXCX_STREAM_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_AXCX_STREAM_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=63) && (d<=1)))
        return 0x864000828404ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10ll * ((c) & 0x3f) + 0x10000ll * ((d) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_AXCX_STREAM_LNX", 4, a, b, c, d, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_AXCX_STREAM_LNX(a,b,c,d) cavm_cprix_cn4ipx_ctx_axcx_stream_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_AXCX_STREAM_LNX(a,b,c,d) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_AXCX_STREAM_LNX(a,b,c,d) "CPRIX_CN4IPX_CTX_AXCX_STREAM_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_AXCX_STREAM_LNX(a,b,c,d) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_AXCX_STREAM_LNX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_axc_sts0_ln#
 *
 * CPRI CONN4 IP CPRI TX AXC Status 0 Register
 */
union cavm_cprix_cn4ipx_ctx_axc_sts0_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_axc_sts0_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t axc_capture_31        : 1;  /**< [ 31: 31](RO/H) Status of request from AxC 31 at collision instant.
                                                                   0 = no request.
                                                                   1 = request active. */
        uint32_t axc_capture_30        : 1;  /**< [ 30: 30](RO/H) Status of request from AxC 30. */
        uint32_t axc_capture_29        : 1;  /**< [ 29: 29](RO/H) Status of request from AxC 29. */
        uint32_t axc_capture_28        : 1;  /**< [ 28: 28](RO/H) Status of request from AxC 28. */
        uint32_t axc_capture_27        : 1;  /**< [ 27: 27](RO/H) Status of request from AxC 27. */
        uint32_t axc_capture_26        : 1;  /**< [ 26: 26](RO/H) Status of request from AxC 26. */
        uint32_t axc_capture_25        : 1;  /**< [ 25: 25](RO/H) Status of request from AxC 25. */
        uint32_t axc_capture_24        : 1;  /**< [ 24: 24](RO/H) Status of request from AxC 24. */
        uint32_t axc_capture_23        : 1;  /**< [ 23: 23](RO/H) Status of request from AxC 23. */
        uint32_t axc_capture_22        : 1;  /**< [ 22: 22](RO/H) Status of request from AxC 22. */
        uint32_t axc_capture_21        : 1;  /**< [ 21: 21](RO/H) Status of request from AxC 21. */
        uint32_t axc_capture_20        : 1;  /**< [ 20: 20](RO/H) Status of request from AxC 20. */
        uint32_t axc_capture_19        : 1;  /**< [ 19: 19](RO/H) Status of request from AxC 19. */
        uint32_t axc_capture_18        : 1;  /**< [ 18: 18](RO/H) Status of request from AxC 18. */
        uint32_t axc_capture_17        : 1;  /**< [ 17: 17](RO/H) Status of request from AxC 17. */
        uint32_t axc_capture_16        : 1;  /**< [ 16: 16](RO/H) Status of request from AxC 16. */
        uint32_t axc_capture_15        : 1;  /**< [ 15: 15](RO/H) Status of request from AxC 15. */
        uint32_t axc_capture_14        : 1;  /**< [ 14: 14](RO/H) Status of request from AxC 14. */
        uint32_t axc_capture_13        : 1;  /**< [ 13: 13](RO/H) Status of request from AxC 13. */
        uint32_t axc_capture_12        : 1;  /**< [ 12: 12](RO/H) Status of request from AxC 12. */
        uint32_t axc_capture_11        : 1;  /**< [ 11: 11](RO/H) Status of request from AxC 11. */
        uint32_t axc_capture_10        : 1;  /**< [ 10: 10](RO/H) Status of request from AxC 10. */
        uint32_t axc_capture_9         : 1;  /**< [  9:  9](RO/H) Status of request from AxC 9. */
        uint32_t axc_capture_8         : 1;  /**< [  8:  8](RO/H) Status of request from AxC 8. */
        uint32_t axc_capture_7         : 1;  /**< [  7:  7](RO/H) Status of request from AxC 7. */
        uint32_t axc_capture_6         : 1;  /**< [  6:  6](RO/H) Status of request from AxC 6. */
        uint32_t axc_capture_5         : 1;  /**< [  5:  5](RO/H) Status of request from AxC 5. */
        uint32_t axc_capture_4         : 1;  /**< [  4:  4](RO/H) Status of request from AxC 4. */
        uint32_t axc_capture_3         : 1;  /**< [  3:  3](RO/H) Status of request from AxC 3. */
        uint32_t axc_capture_2         : 1;  /**< [  2:  2](RO/H) Status of request from AxC 2. */
        uint32_t axc_capture_1         : 1;  /**< [  1:  1](RO/H) Status of request from AxC 1. */
        uint32_t axc_capture_0         : 1;  /**< [  0:  0](RO/H) Status of request from AxC 0 at collision instant.
                                                                   0 = no request.
                                                                   1 = request active. */
#else /* Word 0 - Little Endian */
        uint32_t axc_capture_0         : 1;  /**< [  0:  0](RO/H) Status of request from AxC 0 at collision instant.
                                                                   0 = no request.
                                                                   1 = request active. */
        uint32_t axc_capture_1         : 1;  /**< [  1:  1](RO/H) Status of request from AxC 1. */
        uint32_t axc_capture_2         : 1;  /**< [  2:  2](RO/H) Status of request from AxC 2. */
        uint32_t axc_capture_3         : 1;  /**< [  3:  3](RO/H) Status of request from AxC 3. */
        uint32_t axc_capture_4         : 1;  /**< [  4:  4](RO/H) Status of request from AxC 4. */
        uint32_t axc_capture_5         : 1;  /**< [  5:  5](RO/H) Status of request from AxC 5. */
        uint32_t axc_capture_6         : 1;  /**< [  6:  6](RO/H) Status of request from AxC 6. */
        uint32_t axc_capture_7         : 1;  /**< [  7:  7](RO/H) Status of request from AxC 7. */
        uint32_t axc_capture_8         : 1;  /**< [  8:  8](RO/H) Status of request from AxC 8. */
        uint32_t axc_capture_9         : 1;  /**< [  9:  9](RO/H) Status of request from AxC 9. */
        uint32_t axc_capture_10        : 1;  /**< [ 10: 10](RO/H) Status of request from AxC 10. */
        uint32_t axc_capture_11        : 1;  /**< [ 11: 11](RO/H) Status of request from AxC 11. */
        uint32_t axc_capture_12        : 1;  /**< [ 12: 12](RO/H) Status of request from AxC 12. */
        uint32_t axc_capture_13        : 1;  /**< [ 13: 13](RO/H) Status of request from AxC 13. */
        uint32_t axc_capture_14        : 1;  /**< [ 14: 14](RO/H) Status of request from AxC 14. */
        uint32_t axc_capture_15        : 1;  /**< [ 15: 15](RO/H) Status of request from AxC 15. */
        uint32_t axc_capture_16        : 1;  /**< [ 16: 16](RO/H) Status of request from AxC 16. */
        uint32_t axc_capture_17        : 1;  /**< [ 17: 17](RO/H) Status of request from AxC 17. */
        uint32_t axc_capture_18        : 1;  /**< [ 18: 18](RO/H) Status of request from AxC 18. */
        uint32_t axc_capture_19        : 1;  /**< [ 19: 19](RO/H) Status of request from AxC 19. */
        uint32_t axc_capture_20        : 1;  /**< [ 20: 20](RO/H) Status of request from AxC 20. */
        uint32_t axc_capture_21        : 1;  /**< [ 21: 21](RO/H) Status of request from AxC 21. */
        uint32_t axc_capture_22        : 1;  /**< [ 22: 22](RO/H) Status of request from AxC 22. */
        uint32_t axc_capture_23        : 1;  /**< [ 23: 23](RO/H) Status of request from AxC 23. */
        uint32_t axc_capture_24        : 1;  /**< [ 24: 24](RO/H) Status of request from AxC 24. */
        uint32_t axc_capture_25        : 1;  /**< [ 25: 25](RO/H) Status of request from AxC 25. */
        uint32_t axc_capture_26        : 1;  /**< [ 26: 26](RO/H) Status of request from AxC 26. */
        uint32_t axc_capture_27        : 1;  /**< [ 27: 27](RO/H) Status of request from AxC 27. */
        uint32_t axc_capture_28        : 1;  /**< [ 28: 28](RO/H) Status of request from AxC 28. */
        uint32_t axc_capture_29        : 1;  /**< [ 29: 29](RO/H) Status of request from AxC 29. */
        uint32_t axc_capture_30        : 1;  /**< [ 30: 30](RO/H) Status of request from AxC 30. */
        uint32_t axc_capture_31        : 1;  /**< [ 31: 31](RO/H) Status of request from AxC 31 at collision instant.
                                                                   0 = no request.
                                                                   1 = request active. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_axc_sts0_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_axc_sts0_lnx cavm_cprix_cn4ipx_ctx_axc_sts0_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_AXC_STS0_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_AXC_STS0_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x8640008281f0ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_AXC_STS0_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_AXC_STS0_LNX(a,b,c) cavm_cprix_cn4ipx_ctx_axc_sts0_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_AXC_STS0_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_AXC_STS0_LNX(a,b,c) "CPRIX_CN4IPX_CTX_AXC_STS0_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_AXC_STS0_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_AXC_STS0_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_axc_sts1_ln#
 *
 * CPRI CONN4 IP CPRI TX AXC Status 1 Register
 */
union cavm_cprix_cn4ipx_ctx_axc_sts1_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_axc_sts1_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t axc_capture_63        : 1;  /**< [ 31: 31](RO/H) Status of request from AxC 63 at collision instant.
                                                                   0 = no request.
                                                                   1 = request active. */
        uint32_t axc_capture_62        : 1;  /**< [ 30: 30](RO/H) Status of request from AxC 62. */
        uint32_t axc_capture_61        : 1;  /**< [ 29: 29](RO/H) Status of request from AxC 61. */
        uint32_t axc_capture_60        : 1;  /**< [ 28: 28](RO/H) Status of request from AxC 60. */
        uint32_t axc_capture_59        : 1;  /**< [ 27: 27](RO/H) Status of request from AxC 59. */
        uint32_t axc_capture_58        : 1;  /**< [ 26: 26](RO/H) Status of request from AxC 58. */
        uint32_t axc_capture_57        : 1;  /**< [ 25: 25](RO/H) Status of request from AxC 57. */
        uint32_t axc_capture_56        : 1;  /**< [ 24: 24](RO/H) Status of request from AxC 56. */
        uint32_t axc_capture_55        : 1;  /**< [ 23: 23](RO/H) Status of request from AxC 55. */
        uint32_t axc_capture_54        : 1;  /**< [ 22: 22](RO/H) Status of request from AxC 54. */
        uint32_t axc_capture_53        : 1;  /**< [ 21: 21](RO/H) Status of request from AxC 53. */
        uint32_t axc_capture_52        : 1;  /**< [ 20: 20](RO/H) Status of request from AxC 52. */
        uint32_t axc_capture_51        : 1;  /**< [ 19: 19](RO/H) Status of request from AxC 51. */
        uint32_t axc_capture_50        : 1;  /**< [ 18: 18](RO/H) Status of request from AxC 50. */
        uint32_t axc_capture_49        : 1;  /**< [ 17: 17](RO/H) Status of request from AxC 49. */
        uint32_t axc_capture_48        : 1;  /**< [ 16: 16](RO/H) Status of request from AxC 48. */
        uint32_t axc_capture_47        : 1;  /**< [ 15: 15](RO/H) Status of request from AxC 47. */
        uint32_t axc_capture_46        : 1;  /**< [ 14: 14](RO/H) Status of request from AxC 46. */
        uint32_t axc_capture_45        : 1;  /**< [ 13: 13](RO/H) Status of request from AxC 45. */
        uint32_t axc_capture_44        : 1;  /**< [ 12: 12](RO/H) Status of request from AxC 44. */
        uint32_t axc_capture_43        : 1;  /**< [ 11: 11](RO/H) Status of request from AxC 43. */
        uint32_t axc_capture_42        : 1;  /**< [ 10: 10](RO/H) Status of request from AxC 42. */
        uint32_t axc_capture_41        : 1;  /**< [  9:  9](RO/H) Status of request from AxC 41. */
        uint32_t axc_capture_40        : 1;  /**< [  8:  8](RO/H) Status of request from AxC 40. */
        uint32_t axc_capture_39        : 1;  /**< [  7:  7](RO/H) Status of request from AxC 39. */
        uint32_t axc_capture_38        : 1;  /**< [  6:  6](RO/H) Status of request from AxC 38. */
        uint32_t axc_capture_37        : 1;  /**< [  5:  5](RO/H) Status of request from AxC 37. */
        uint32_t axc_capture_36        : 1;  /**< [  4:  4](RO/H) Status of request from AxC 36. */
        uint32_t axc_capture_35        : 1;  /**< [  3:  3](RO/H) Status of request from AxC 35. */
        uint32_t axc_capture_34        : 1;  /**< [  2:  2](RO/H) Status of request from AxC 34. */
        uint32_t axc_capture_33        : 1;  /**< [  1:  1](RO/H) Status of request from AxC 33. */
        uint32_t axc_capture_32        : 1;  /**< [  0:  0](RO/H) Status of request from AxC 32 at collision instant.
                                                                   0 = no request.
                                                                   1 = request active. */
#else /* Word 0 - Little Endian */
        uint32_t axc_capture_32        : 1;  /**< [  0:  0](RO/H) Status of request from AxC 32 at collision instant.
                                                                   0 = no request.
                                                                   1 = request active. */
        uint32_t axc_capture_33        : 1;  /**< [  1:  1](RO/H) Status of request from AxC 33. */
        uint32_t axc_capture_34        : 1;  /**< [  2:  2](RO/H) Status of request from AxC 34. */
        uint32_t axc_capture_35        : 1;  /**< [  3:  3](RO/H) Status of request from AxC 35. */
        uint32_t axc_capture_36        : 1;  /**< [  4:  4](RO/H) Status of request from AxC 36. */
        uint32_t axc_capture_37        : 1;  /**< [  5:  5](RO/H) Status of request from AxC 37. */
        uint32_t axc_capture_38        : 1;  /**< [  6:  6](RO/H) Status of request from AxC 38. */
        uint32_t axc_capture_39        : 1;  /**< [  7:  7](RO/H) Status of request from AxC 39. */
        uint32_t axc_capture_40        : 1;  /**< [  8:  8](RO/H) Status of request from AxC 40. */
        uint32_t axc_capture_41        : 1;  /**< [  9:  9](RO/H) Status of request from AxC 41. */
        uint32_t axc_capture_42        : 1;  /**< [ 10: 10](RO/H) Status of request from AxC 42. */
        uint32_t axc_capture_43        : 1;  /**< [ 11: 11](RO/H) Status of request from AxC 43. */
        uint32_t axc_capture_44        : 1;  /**< [ 12: 12](RO/H) Status of request from AxC 44. */
        uint32_t axc_capture_45        : 1;  /**< [ 13: 13](RO/H) Status of request from AxC 45. */
        uint32_t axc_capture_46        : 1;  /**< [ 14: 14](RO/H) Status of request from AxC 46. */
        uint32_t axc_capture_47        : 1;  /**< [ 15: 15](RO/H) Status of request from AxC 47. */
        uint32_t axc_capture_48        : 1;  /**< [ 16: 16](RO/H) Status of request from AxC 48. */
        uint32_t axc_capture_49        : 1;  /**< [ 17: 17](RO/H) Status of request from AxC 49. */
        uint32_t axc_capture_50        : 1;  /**< [ 18: 18](RO/H) Status of request from AxC 50. */
        uint32_t axc_capture_51        : 1;  /**< [ 19: 19](RO/H) Status of request from AxC 51. */
        uint32_t axc_capture_52        : 1;  /**< [ 20: 20](RO/H) Status of request from AxC 52. */
        uint32_t axc_capture_53        : 1;  /**< [ 21: 21](RO/H) Status of request from AxC 53. */
        uint32_t axc_capture_54        : 1;  /**< [ 22: 22](RO/H) Status of request from AxC 54. */
        uint32_t axc_capture_55        : 1;  /**< [ 23: 23](RO/H) Status of request from AxC 55. */
        uint32_t axc_capture_56        : 1;  /**< [ 24: 24](RO/H) Status of request from AxC 56. */
        uint32_t axc_capture_57        : 1;  /**< [ 25: 25](RO/H) Status of request from AxC 57. */
        uint32_t axc_capture_58        : 1;  /**< [ 26: 26](RO/H) Status of request from AxC 58. */
        uint32_t axc_capture_59        : 1;  /**< [ 27: 27](RO/H) Status of request from AxC 59. */
        uint32_t axc_capture_60        : 1;  /**< [ 28: 28](RO/H) Status of request from AxC 60. */
        uint32_t axc_capture_61        : 1;  /**< [ 29: 29](RO/H) Status of request from AxC 61. */
        uint32_t axc_capture_62        : 1;  /**< [ 30: 30](RO/H) Status of request from AxC 62. */
        uint32_t axc_capture_63        : 1;  /**< [ 31: 31](RO/H) Status of request from AxC 63 at collision instant.
                                                                   0 = no request.
                                                                   1 = request active. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_axc_sts1_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_axc_sts1_lnx cavm_cprix_cn4ipx_ctx_axc_sts1_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_AXC_STS1_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_AXC_STS1_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x8640008281f4ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_AXC_STS1_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_AXC_STS1_LNX(a,b,c) cavm_cprix_cn4ipx_ctx_axc_sts1_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_AXC_STS1_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_AXC_STS1_LNX(a,b,c) "CPRIX_CN4IPX_CTX_AXC_STS1_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_AXC_STS1_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_AXC_STS1_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_bank_bfn_0_ln#
 *
 * CPRI CONN4 IP CPRI TX Register Bank BFN Match Configuration 0 Register
 */
union cavm_cprix_cn4ipx_ctx_bank_bfn_0_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_bank_bfn_0_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t mask_0                : 16; /**< [ 31: 16](R/W) Mask for comparing each bit BFN of the current CTX frame against corresponding bit of BFN_0.
                                                                   bit with value 0 = compare.
                                                                   bit with value 1 = do not compare.
                                                                 Note: If mask bits are all ones, result of the comparison is always true. */
        uint32_t bfn_0                 : 16; /**< [ 15:  0](R/W) BFN compare value. When BFN bits [WIDTH_0 - 1_0:0] match the value of
                                                                 BFN_0[WIDTH_0 - 1_0:0], internal flag BFN_MATCH_0 is high and can be used for
                                                                 enabling individual bank boxes if so enabled in their configuration. */
#else /* Word 0 - Little Endian */
        uint32_t bfn_0                 : 16; /**< [ 15:  0](R/W) BFN compare value. When BFN bits [WIDTH_0 - 1_0:0] match the value of
                                                                 BFN_0[WIDTH_0 - 1_0:0], internal flag BFN_MATCH_0 is high and can be used for
                                                                 enabling individual bank boxes if so enabled in their configuration. */
        uint32_t mask_0                : 16; /**< [ 31: 16](R/W) Mask for comparing each bit BFN of the current CTX frame against corresponding bit of BFN_0.
                                                                   bit with value 0 = compare.
                                                                   bit with value 1 = do not compare.
                                                                 Note: If mask bits are all ones, result of the comparison is always true. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_bank_bfn_0_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_bank_bfn_0_lnx cavm_cprix_cn4ipx_ctx_bank_bfn_0_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_BANK_BFN_0_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_BANK_BFN_0_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x8640008281f8ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_BANK_BFN_0_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_BANK_BFN_0_LNX(a,b,c) cavm_cprix_cn4ipx_ctx_bank_bfn_0_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_BANK_BFN_0_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_BANK_BFN_0_LNX(a,b,c) "CPRIX_CN4IPX_CTX_BANK_BFN_0_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_BANK_BFN_0_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_BANK_BFN_0_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_bank_bfn_1_ln#
 *
 * CPRI CONN4 IP CPRI TX Register Bank BFN Match Configuration 1 Register
 */
union cavm_cprix_cn4ipx_ctx_bank_bfn_1_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_bank_bfn_1_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t mask_1                : 16; /**< [ 31: 16](R/W) Mask for comparing each bit BFN of the current CTX frame against corresponding bit of BFN_1.
                                                                   bit with value 0 = compare.
                                                                   bit with value 1 = do not compare.
                                                                 Note: If mask bits are all ones, result of the comparison is always true. */
        uint32_t bfn_1                 : 16; /**< [ 15:  0](R/W) BFN compare value. When BFN bits [WIDTH_0 - 1_0:0] match the value of
                                                                 BFN_1[WIDTH_0 - 1_0:0], internal flag BFN_MATCH_1 is high and can be used for
                                                                 enabling individual bank boxes if so enabled in their configuration. */
#else /* Word 0 - Little Endian */
        uint32_t bfn_1                 : 16; /**< [ 15:  0](R/W) BFN compare value. When BFN bits [WIDTH_0 - 1_0:0] match the value of
                                                                 BFN_1[WIDTH_0 - 1_0:0], internal flag BFN_MATCH_1 is high and can be used for
                                                                 enabling individual bank boxes if so enabled in their configuration. */
        uint32_t mask_1                : 16; /**< [ 31: 16](R/W) Mask for comparing each bit BFN of the current CTX frame against corresponding bit of BFN_1.
                                                                   bit with value 0 = compare.
                                                                   bit with value 1 = do not compare.
                                                                 Note: If mask bits are all ones, result of the comparison is always true. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_bank_bfn_1_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_bank_bfn_1_lnx cavm_cprix_cn4ipx_ctx_bank_bfn_1_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_BANK_BFN_1_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_BANK_BFN_1_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x8640008281fcll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_BANK_BFN_1_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_BANK_BFN_1_LNX(a,b,c) cavm_cprix_cn4ipx_ctx_bank_bfn_1_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_BANK_BFN_1_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_BANK_BFN_1_LNX(a,b,c) "CPRIX_CN4IPX_CTX_BANK_BFN_1_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_BANK_BFN_1_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_BANK_BFN_1_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_bank_ctrl#_ln#
 *
 * CPRI CONN4 IP CPRI TX Register Bank Configuration 0 to 15 Register
 */
union cavm_cprix_cn4ipx_ctx_bank_ctrlx_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_bank_ctrlx_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_26_31        : 6;
        uint32_t bank_enable_high      : 1;  /**< [ 25: 25](R/W) Transmit enable for high byte.
                                                                   0 = disabled.
                                                                   1 = enabled. */
        uint32_t bank_enable_low       : 1;  /**< [ 24: 24](R/W) Transmit enable for low byte.
                                                                   0 = disabled.
                                                                   1 = enabled. */
        uint32_t reserved_22_23        : 2;
        uint32_t bfn_enable_1          : 1;  /**< [ 21: 21](R/W) BFN trigger 1. If value of this field is one, it is required the flag
                                                                 BFN_MATCH_1 must be high in order for transmission to occur. The flag is set
                                                                 when BFN of the current CTX frame matches the condition configured in register
                                                                 CTX_BANK_BFN_1.
                                                                   0 = disabled.
                                                                   1 = enabled, BFN is checked. */
        uint32_t bfn_enable_0          : 1;  /**< [ 20: 20](R/W) BFN trigger 0. If value of this field is one, it is required the flag
                                                                 BFN_MATCH_0 must be high in order for transmission to occur. The flag is set
                                                                 when BFN of the current CTX frame matches the condition configured in register
                                                                 CTX_BANK_BFN_0.
                                                                   0 = disabled.
                                                                   1 = enabled, BFN is checked. */
        uint32_t reserved_19           : 1;
        uint32_t bank_y                : 3;  /**< [ 18: 16](R/W) Transmit in the part of the CPRI word matching this coordinate.
                                                                   0 = bytes 1 and 0.
                                                                   1 = bytes 3 and 2.
                                                                   2 = bytes 5 and 4.
                                                                   3 = bytes 7 and 6.
                                                                   4 = bytes 9 and 8.
                                                                   5 = bytes 11 and 10.
                                                                   6 = bytes 13 and 12.
                                                                   7 = bytes 15 and 14.

                                                                 Note: If the bytes do not exist on selected line rate, the data is never transmitted. */
        uint32_t bank_x                : 8;  /**< [ 15:  8](R/W) Transmit in the Basic Frame with this X coordinate.
                                                                       0..0xff = valid. */
        uint32_t bank_z                : 8;  /**< [  7:  0](R/W) Transmit in the Hyperframe with this Z coordinate.
                                                                 Value 255 disregards comparison and matches any hyperframe.
                                                                        0..0x95 = matches the hyperframe.
                                                                      0x96..0xFE = no match.
                                                                           0xFF  = matches any hyperframe. */
#else /* Word 0 - Little Endian */
        uint32_t bank_z                : 8;  /**< [  7:  0](R/W) Transmit in the Hyperframe with this Z coordinate.
                                                                 Value 255 disregards comparison and matches any hyperframe.
                                                                        0..0x95 = matches the hyperframe.
                                                                      0x96..0xFE = no match.
                                                                           0xFF  = matches any hyperframe. */
        uint32_t bank_x                : 8;  /**< [ 15:  8](R/W) Transmit in the Basic Frame with this X coordinate.
                                                                       0..0xff = valid. */
        uint32_t bank_y                : 3;  /**< [ 18: 16](R/W) Transmit in the part of the CPRI word matching this coordinate.
                                                                   0 = bytes 1 and 0.
                                                                   1 = bytes 3 and 2.
                                                                   2 = bytes 5 and 4.
                                                                   3 = bytes 7 and 6.
                                                                   4 = bytes 9 and 8.
                                                                   5 = bytes 11 and 10.
                                                                   6 = bytes 13 and 12.
                                                                   7 = bytes 15 and 14.

                                                                 Note: If the bytes do not exist on selected line rate, the data is never transmitted. */
        uint32_t reserved_19           : 1;
        uint32_t bfn_enable_0          : 1;  /**< [ 20: 20](R/W) BFN trigger 0. If value of this field is one, it is required the flag
                                                                 BFN_MATCH_0 must be high in order for transmission to occur. The flag is set
                                                                 when BFN of the current CTX frame matches the condition configured in register
                                                                 CTX_BANK_BFN_0.
                                                                   0 = disabled.
                                                                   1 = enabled, BFN is checked. */
        uint32_t bfn_enable_1          : 1;  /**< [ 21: 21](R/W) BFN trigger 1. If value of this field is one, it is required the flag
                                                                 BFN_MATCH_1 must be high in order for transmission to occur. The flag is set
                                                                 when BFN of the current CTX frame matches the condition configured in register
                                                                 CTX_BANK_BFN_1.
                                                                   0 = disabled.
                                                                   1 = enabled, BFN is checked. */
        uint32_t reserved_22_23        : 2;
        uint32_t bank_enable_low       : 1;  /**< [ 24: 24](R/W) Transmit enable for low byte.
                                                                   0 = disabled.
                                                                   1 = enabled. */
        uint32_t bank_enable_high      : 1;  /**< [ 25: 25](R/W) Transmit enable for high byte.
                                                                   0 = disabled.
                                                                   1 = enabled. */
        uint32_t reserved_26_31        : 6;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_bank_ctrlx_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_bank_ctrlx_lnx cavm_cprix_cn4ipx_ctx_bank_ctrlx_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_BANK_CTRLX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_BANK_CTRLX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=15) && (d<=1)))
        return 0x864000828080ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 8ll * ((c) & 0xf) + 0x10000ll * ((d) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_BANK_CTRLX_LNX", 4, a, b, c, d, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_BANK_CTRLX_LNX(a,b,c,d) cavm_cprix_cn4ipx_ctx_bank_ctrlx_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_BANK_CTRLX_LNX(a,b,c,d) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_BANK_CTRLX_LNX(a,b,c,d) "CPRIX_CN4IPX_CTX_BANK_CTRLX_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_BANK_CTRLX_LNX(a,b,c,d) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_BANK_CTRLX_LNX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_bank_data#_ln#
 *
 * CPRI CONN4 IP CPRI TX Register Bank Data 0 to 15 Register
 */
union cavm_cprix_cn4ipx_ctx_bank_datax_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_bank_datax_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t bank_data             : 16; /**< [ 15:  0](R/W) Payload to be transmitted. When transmission is enabled, this data will be
                                                                 transmitted onto the CPRI line at the coordinates configured in
                                                                 CTX_BANK_CONTROL. */
#else /* Word 0 - Little Endian */
        uint32_t bank_data             : 16; /**< [ 15:  0](R/W) Payload to be transmitted. When transmission is enabled, this data will be
                                                                 transmitted onto the CPRI line at the coordinates configured in
                                                                 CTX_BANK_CONTROL. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_bank_datax_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_bank_datax_lnx cavm_cprix_cn4ipx_ctx_bank_datax_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_BANK_DATAX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_BANK_DATAX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=15) && (d<=1)))
        return 0x864000828084ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 8ll * ((c) & 0xf) + 0x10000ll * ((d) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_BANK_DATAX_LNX", 4, a, b, c, d, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_BANK_DATAX_LNX(a,b,c,d) cavm_cprix_cn4ipx_ctx_bank_datax_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_BANK_DATAX_LNX(a,b,c,d) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_BANK_DATAX_LNX(a,b,c,d) "CPRIX_CN4IPX_CTX_BANK_DATAX_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_BANK_DATAX_LNX(a,b,c,d) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_BANK_DATAX_LNX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_bcn_n1_0_ln#
 *
 * CPRI CONN4 IP CPRI TX BCN N1 Timing 0 Register
 */
union cavm_cprix_cn4ipx_ctx_bcn_n1_0_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_bcn_n1_0_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_12_31        : 20;
        uint32_t bcn_n1_0              : 12; /**< [ 11:  0](R/W) BCN N1 LSB bits 11:0. CPRI Tx begins transmission when global BCN matches this
                                                                 value and BCN_N1_1 and BCN_N2. */
#else /* Word 0 - Little Endian */
        uint32_t bcn_n1_0              : 12; /**< [ 11:  0](R/W) BCN N1 LSB bits 11:0. CPRI Tx begins transmission when global BCN matches this
                                                                 value and BCN_N1_1 and BCN_N2. */
        uint32_t reserved_12_31        : 20;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_bcn_n1_0_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_bcn_n1_0_lnx cavm_cprix_cn4ipx_ctx_bcn_n1_0_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_BCN_N1_0_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_BCN_N1_0_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000828008ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_BCN_N1_0_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_BCN_N1_0_LNX(a,b,c) cavm_cprix_cn4ipx_ctx_bcn_n1_0_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_BCN_N1_0_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_BCN_N1_0_LNX(a,b,c) "CPRIX_CN4IPX_CTX_BCN_N1_0_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_BCN_N1_0_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_BCN_N1_0_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_bcn_n1_1_ln#
 *
 * CPRI CONN4 IP CPRI TX BCN N1 Timing 1 Register
 */
union cavm_cprix_cn4ipx_ctx_bcn_n1_1_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_bcn_n1_1_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t bcn_n1_1              : 28; /**< [ 27:  0](R/W) BCN N1 MSB bits 39:12. CPRI Tx begins transmission when global BCN matches this
                                                                 value and BCN_N1_0 and BCN_N2. */
#else /* Word 0 - Little Endian */
        uint32_t bcn_n1_1              : 28; /**< [ 27:  0](R/W) BCN N1 MSB bits 39:12. CPRI Tx begins transmission when global BCN matches this
                                                                 value and BCN_N1_0 and BCN_N2. */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_bcn_n1_1_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_bcn_n1_1_lnx cavm_cprix_cn4ipx_ctx_bcn_n1_1_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_BCN_N1_1_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_BCN_N1_1_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x86400082800cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_BCN_N1_1_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_BCN_N1_1_LNX(a,b,c) cavm_cprix_cn4ipx_ctx_bcn_n1_1_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_BCN_N1_1_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_BCN_N1_1_LNX(a,b,c) "CPRIX_CN4IPX_CTX_BCN_N1_1_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_BCN_N1_1_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_BCN_N1_1_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_bcn_n2_ln#
 *
 * CPRI CONN4 IP CPRI TX BCN N2 Timing Register
 */
union cavm_cprix_cn4ipx_ctx_bcn_n2_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_bcn_n2_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t bcn_n2                : 22; /**< [ 23:  2](R/W) BCN timer N2 value. CPRI Tx begins transmission when global BCN matches this
                                                                 value and BCN_N1_0 and BCN_N1_1. */
        uint32_t reserved_0_1          : 2;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0_1          : 2;
        uint32_t bcn_n2                : 22; /**< [ 23:  2](R/W) BCN timer N2 value. CPRI Tx begins transmission when global BCN matches this
                                                                 value and BCN_N1_0 and BCN_N1_1. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_bcn_n2_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_bcn_n2_lnx cavm_cprix_cn4ipx_ctx_bcn_n2_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_BCN_N2_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_BCN_N2_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000828010ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_BCN_N2_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_BCN_N2_LNX(a,b,c) cavm_cprix_cn4ipx_ctx_bcn_n2_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_BCN_N2_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_BCN_N2_LNX(a,b,c) "CPRIX_CN4IPX_CTX_BCN_N2_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_BCN_N2_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_BCN_N2_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_bfn_ln#
 *
 * CPRI CONN4 IP CPRI TX nodeB Frame Number Register
 */
union cavm_cprix_cn4ipx_ctx_bfn_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_bfn_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t bcn_n2_r              : 16; /**< [ 15:  0](R/W) Initial BFN value. Bits(11:0) contains the initial BFN value sent in the first CPRI Tx frame. */
#else /* Word 0 - Little Endian */
        uint32_t bcn_n2_r              : 16; /**< [ 15:  0](R/W) Initial BFN value. Bits(11:0) contains the initial BFN value sent in the first CPRI Tx frame. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_bfn_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_bfn_lnx cavm_cprix_cn4ipx_ctx_bfn_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_BFN_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_BFN_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000828014ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_BFN_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_BFN_LNX(a,b,c) cavm_cprix_cn4ipx_ctx_bfn_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_BFN_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_BFN_LNX(a,b,c) "CPRIX_CN4IPX_CTX_BFN_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_BFN_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_BFN_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_crc_status_ln#
 *
 * CPRI CONN4 IP CPRI TX CRC Status Register
 */
union cavm_cprix_cn4ipx_ctx_crc_status_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_crc_status_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_19_31        : 13;
        uint32_t crc_error_tunnel      : 1;  /**< [ 18: 18](RO/H) CRC error detected by a CTX Tunnel Channel. Index of the channel is visible in
                                                                 field CRC_INDEX_Tunnel.
                                                                   0 = no error.
                                                                   1 = CRC error detected. */
        uint32_t crc_error_rtwp        : 1;  /**< [ 17: 17](RO/H) CRC error detected by a CTX RTWP Channel. Index of the channel is visible in field CRC_INDEX_RTWP. */
        uint32_t crc_error_sdvm        : 1;  /**< [ 16: 16](RO/H) CRC error detected by a CTX SDVM Channel. Index of the channel is visible in field CRC_INDEX_SDVM. */
        uint32_t reserved_12_15        : 4;
        uint32_t crc_index_tunnel      : 4;  /**< [ 11:  8](RO/H) Index of the CTX SDVM Channel that received a message with a CRC error. Valid
                                                                 only if CRC_ERROR_TUNNEL is high. */
        uint32_t crc_index_rtwp        : 4;  /**< [  7:  4](RO/H) Index of the CTX SDVM Channel that received a message with a CRC error. Valid
                                                                 only if CRC_ERROR_RTWP is high. */
        uint32_t crc_index_sdvm        : 4;  /**< [  3:  0](RO/H) Index of the CTX SDVM Channel that received a message with a CRC error. Valid
                                                                 only if CRC_ERROR_SDVM is high. */
#else /* Word 0 - Little Endian */
        uint32_t crc_index_sdvm        : 4;  /**< [  3:  0](RO/H) Index of the CTX SDVM Channel that received a message with a CRC error. Valid
                                                                 only if CRC_ERROR_SDVM is high. */
        uint32_t crc_index_rtwp        : 4;  /**< [  7:  4](RO/H) Index of the CTX SDVM Channel that received a message with a CRC error. Valid
                                                                 only if CRC_ERROR_RTWP is high. */
        uint32_t crc_index_tunnel      : 4;  /**< [ 11:  8](RO/H) Index of the CTX SDVM Channel that received a message with a CRC error. Valid
                                                                 only if CRC_ERROR_TUNNEL is high. */
        uint32_t reserved_12_15        : 4;
        uint32_t crc_error_sdvm        : 1;  /**< [ 16: 16](RO/H) CRC error detected by a CTX SDVM Channel. Index of the channel is visible in field CRC_INDEX_SDVM. */
        uint32_t crc_error_rtwp        : 1;  /**< [ 17: 17](RO/H) CRC error detected by a CTX RTWP Channel. Index of the channel is visible in field CRC_INDEX_RTWP. */
        uint32_t crc_error_tunnel      : 1;  /**< [ 18: 18](RO/H) CRC error detected by a CTX Tunnel Channel. Index of the channel is visible in
                                                                 field CRC_INDEX_Tunnel.
                                                                   0 = no error.
                                                                   1 = CRC error detected. */
        uint32_t reserved_19_31        : 13;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_crc_status_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_crc_status_lnx cavm_cprix_cn4ipx_ctx_crc_status_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_CRC_STATUS_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_CRC_STATUS_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x8640008281e4ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_CRC_STATUS_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_CRC_STATUS_LNX(a,b,c) cavm_cprix_cn4ipx_ctx_crc_status_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_CRC_STATUS_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_CRC_STATUS_LNX(a,b,c) "CPRIX_CN4IPX_CTX_CRC_STATUS_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_CRC_STATUS_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_CRC_STATUS_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_ctrl_ln#
 *
 * CPRI CONN4 IP CPRI TX Control Register
 */
union cavm_cprix_cn4ipx_ctx_ctrl_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_ctrl_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t ctx_started           : 1;  /**< [  1:  1](RO/H) Status indicating CPRI TX framing has started as a result of a BCN match.
                                                                   0 = not started.
                                                                   1 = started. */
        uint32_t ctx_en                : 1;  /**< [  0:  0](R/W) Enable CPRI TX framer.
                                                                   0 = framer disabled.
                                                                   1 = framer enabled. */
#else /* Word 0 - Little Endian */
        uint32_t ctx_en                : 1;  /**< [  0:  0](R/W) Enable CPRI TX framer.
                                                                   0 = framer disabled.
                                                                   1 = framer enabled. */
        uint32_t ctx_started           : 1;  /**< [  1:  1](RO/H) Status indicating CPRI TX framing has started as a result of a BCN match.
                                                                   0 = not started.
                                                                   1 = started. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_ctrl_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_ctrl_lnx cavm_cprix_cn4ipx_ctx_ctrl_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_CTRL_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_CTRL_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000828000ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_CTRL_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_CTRL_LNX(a,b,c) cavm_cprix_cn4ipx_ctx_ctrl_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_CTRL_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_CTRL_LNX(a,b,c) "CPRIX_CN4IPX_CTX_CTRL_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_CTRL_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_CTRL_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_hdlc_c0_ln#
 *
 * CPRI CONN4 IP CPRI TX HDLC Buffer Configuration Register
 */
union cavm_cprix_cn4ipx_ctx_hdlc_c0_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_hdlc_c0_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t crc_bit               : 1;  /**< [ 27: 27](R/W) Reverse bits within FCS byte.
                                                                   0 = Bits reversed.
                                                                   1 = Bits not reversed. */
        uint32_t crc_ord               : 1;  /**< [ 26: 26](R/W) FCS field byte order.
                                                                   0 = CRC byte order not reversed.
                                                                   1 = CRC byte order reversed. */
        uint32_t crc_inv               : 1;  /**< [ 25: 25](R/W) FCS field  bit inversion.
                                                                   0 = CRC bits not inverted.
                                                                   1 = CRC bits inverted. */
        uint32_t crc_pre               : 1;  /**< [ 24: 24](R/W) FCS field CRC preset value.
                                                                   0 = 0xFFFF.
                                                                   1 = 0x0000. */
        uint32_t reserved_17_23        : 7;
        uint32_t enable                : 1;  /**< [ 16: 16](R/W) CTX HDLC buffer enable.
                                                                   0 = disabled.
                                                                   1 = enabled.

                                                                 Before enabling, at least one HDLC subframe containing a header and payload data
                                                                 should be written into buffer. The 32-bit word following the last HDLC subframe
                                                                 in the buffer must be 0x00000000. */
        uint32_t reserved_10_15        : 6;
        uint32_t length                : 10; /**< [  9:  0](R/W) Pointer to the last location allocated for the buffer in CTX VSB RAM.
                                                                 Unit of the pointer is a 32-bit word. */
#else /* Word 0 - Little Endian */
        uint32_t length                : 10; /**< [  9:  0](R/W) Pointer to the last location allocated for the buffer in CTX VSB RAM.
                                                                 Unit of the pointer is a 32-bit word. */
        uint32_t reserved_10_15        : 6;
        uint32_t enable                : 1;  /**< [ 16: 16](R/W) CTX HDLC buffer enable.
                                                                   0 = disabled.
                                                                   1 = enabled.

                                                                 Before enabling, at least one HDLC subframe containing a header and payload data
                                                                 should be written into buffer. The 32-bit word following the last HDLC subframe
                                                                 in the buffer must be 0x00000000. */
        uint32_t reserved_17_23        : 7;
        uint32_t crc_pre               : 1;  /**< [ 24: 24](R/W) FCS field CRC preset value.
                                                                   0 = 0xFFFF.
                                                                   1 = 0x0000. */
        uint32_t crc_inv               : 1;  /**< [ 25: 25](R/W) FCS field  bit inversion.
                                                                   0 = CRC bits not inverted.
                                                                   1 = CRC bits inverted. */
        uint32_t crc_ord               : 1;  /**< [ 26: 26](R/W) FCS field byte order.
                                                                   0 = CRC byte order not reversed.
                                                                   1 = CRC byte order reversed. */
        uint32_t crc_bit               : 1;  /**< [ 27: 27](R/W) Reverse bits within FCS byte.
                                                                   0 = Bits reversed.
                                                                   1 = Bits not reversed. */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_hdlc_c0_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_hdlc_c0_lnx cavm_cprix_cn4ipx_ctx_hdlc_c0_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_HDLC_C0_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_HDLC_C0_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000828120ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_HDLC_C0_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_HDLC_C0_LNX(a,b,c) cavm_cprix_cn4ipx_ctx_hdlc_c0_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_HDLC_C0_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_HDLC_C0_LNX(a,b,c) "CPRIX_CN4IPX_CTX_HDLC_C0_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_HDLC_C0_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_HDLC_C0_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_hdlc_c1_ln#
 *
 * CPRI CONN4 IP CPRI TX HDLC Flag Configuration Register
 */
union cavm_cprix_cn4ipx_ctx_hdlc_c1_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_hdlc_c1_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t off_flag              : 8;  /**< [ 31: 24](R/W) Configurable inactive HDLC transmitted byte. Byte is sent out when
                                                                 CTX_L1_HDLC_BR = 0 or CTX_L1_HDLC_BR = 7. */
        uint32_t reserved_18_23        : 6;
        uint32_t flag                  : 2;  /**< [ 17: 16](R/W) HDLC Interframe filling control.
                                                                   0 = 0x7E.
                                                                   1 = 0x7F.
                                                                   2 = 0xFF.
                                                                   3 = 0x7E. */
        uint32_t reserved_10_15        : 6;
        uint32_t write_pointer         : 10; /**< [  9:  0](R/W) Pointer to the header of the first HDLC subframe in the buffer.
                                                                 This pointer is only written before HDLC buffer is enabled. It is not updated during operation.
                                                                 Unit of the pointer is a 32-bit word. */
#else /* Word 0 - Little Endian */
        uint32_t write_pointer         : 10; /**< [  9:  0](R/W) Pointer to the header of the first HDLC subframe in the buffer.
                                                                 This pointer is only written before HDLC buffer is enabled. It is not updated during operation.
                                                                 Unit of the pointer is a 32-bit word. */
        uint32_t reserved_10_15        : 6;
        uint32_t flag                  : 2;  /**< [ 17: 16](R/W) HDLC Interframe filling control.
                                                                   0 = 0x7E.
                                                                   1 = 0x7F.
                                                                   2 = 0xFF.
                                                                   3 = 0x7E. */
        uint32_t reserved_18_23        : 6;
        uint32_t off_flag              : 8;  /**< [ 31: 24](R/W) Configurable inactive HDLC transmitted byte. Byte is sent out when
                                                                 CTX_L1_HDLC_BR = 0 or CTX_L1_HDLC_BR = 7. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_hdlc_c1_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_hdlc_c1_lnx cavm_cprix_cn4ipx_ctx_hdlc_c1_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_HDLC_C1_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_HDLC_C1_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000828124ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_HDLC_C1_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_HDLC_C1_LNX(a,b,c) cavm_cprix_cn4ipx_ctx_hdlc_c1_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_HDLC_C1_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_HDLC_C1_LNX(a,b,c) "CPRIX_CN4IPX_CTX_HDLC_C1_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_HDLC_C1_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_HDLC_C1_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_hdlc_mon_ln#
 *
 * CPRI CONN4 IP CPRI TX HDLC Monitor Control Register
 */
union cavm_cprix_cn4ipx_ctx_hdlc_mon_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_hdlc_mon_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t hdlc_ck               : 1;  /**< [  1:  1](R/W) Enable output of HDLC clock to HDLC_CK.
                                                                   0 = disabled.
                                                                   1 = enabled. */
        uint32_t hdlc_tx               : 1;  /**< [  0:  0](R/W) Enable output of HDLC data to HDLC_TX.
                                                                   0 = disabled.
                                                                   1 = enabled. */
#else /* Word 0 - Little Endian */
        uint32_t hdlc_tx               : 1;  /**< [  0:  0](R/W) Enable output of HDLC data to HDLC_TX.
                                                                   0 = disabled.
                                                                   1 = enabled. */
        uint32_t hdlc_ck               : 1;  /**< [  1:  1](R/W) Enable output of HDLC clock to HDLC_CK.
                                                                   0 = disabled.
                                                                   1 = enabled. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_hdlc_mon_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_hdlc_mon_lnx cavm_cprix_cn4ipx_ctx_hdlc_mon_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_HDLC_MON_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_HDLC_MON_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x86400082812cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_HDLC_MON_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_HDLC_MON_LNX(a,b,c) cavm_cprix_cn4ipx_ctx_hdlc_mon_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_HDLC_MON_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_HDLC_MON_LNX(a,b,c) "CPRIX_CN4IPX_CTX_HDLC_MON_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_HDLC_MON_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_HDLC_MON_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_hdlc_sts_ln#
 *
 * CPRI CONN4 IP CPRI TX HDLC Status Register
 */
union cavm_cprix_cn4ipx_ctx_hdlc_sts_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_hdlc_sts_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_10_31        : 22;
        uint32_t transmit_pointer      : 10; /**< [  9:  0](RO/H) Pointer to the most recently transmitted HDLC data in buffer.
                                                                 Unit of the pointer is a 32-bit word. */
#else /* Word 0 - Little Endian */
        uint32_t transmit_pointer      : 10; /**< [  9:  0](RO/H) Pointer to the most recently transmitted HDLC data in buffer.
                                                                 Unit of the pointer is a 32-bit word. */
        uint32_t reserved_10_31        : 22;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_hdlc_sts_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_hdlc_sts_lnx cavm_cprix_cn4ipx_ctx_hdlc_sts_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_HDLC_STS_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_HDLC_STS_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000828128ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_HDLC_STS_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_HDLC_STS_LNX(a,b,c) cavm_cprix_cn4ipx_ctx_hdlc_sts_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_HDLC_STS_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_HDLC_STS_LNX(a,b,c) "CPRIX_CN4IPX_CTX_HDLC_STS_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_HDLC_STS_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_HDLC_STS_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_int_clr_ln#
 *
 * CPRI CONN4 IP CPRI TX Interrupt Event Clear Register
 */
union cavm_cprix_cn4ipx_ctx_int_clr_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_int_clr_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_17_31        : 15;
        uint32_t crc_error             : 1;  /**< [ 16: 16](R/W1C/H) Clear for CRC_ERROR interrupt.
                                                                   0 = No effect.
                                                                   1 = Clear interrupt. */
        uint32_t ctx_collision         : 1;  /**< [ 15: 15](R/W1C/H) Clear for CTX_COLLISION interrupt. */
        uint32_t tunnel_collision      : 1;  /**< [ 14: 14](R/W1C/H) Clear for TUNNEL_COLLISION interrupt. */
        uint32_t axc_collision         : 1;  /**< [ 13: 13](R/W1C/H) Clear for AXC_COLLISION interrupt. */
        uint32_t axc_overlap           : 1;  /**< [ 12: 12](R/W1C/H) Clear for AXC_OVERLAP interrupt. */
        uint32_t hdlc_disconnect       : 1;  /**< [ 11: 11](R/W1C/H) Clear for HDLC_DISCONNECT interrupt. */
        uint32_t vsbx_overlap          : 1;  /**< [ 10: 10](R/W1C/H) Clear for VSBX_OVERLAP interrupt. */
        uint32_t hdlc_underflow        : 1;  /**< [  9:  9](R/W1C/H) Clear for HDLC_UNDERFLOW interrupt. */
        uint32_t vsbd_underflow        : 1;  /**< [  8:  8](R/W1C/H) Clear for VSBD_UNDERFLOW interrupt. */
        uint32_t vsbc_underflow        : 1;  /**< [  7:  7](R/W1C/H) Clear for VSBC_UNDERFLOW interrupt. */
        uint32_t vsbb_underflow        : 1;  /**< [  6:  6](R/W1C/H) Clear for VSBB_UNDERFLOW interrupt. */
        uint32_t vsba_underflow        : 1;  /**< [  5:  5](R/W1C/H) Clear for VSBA_UNDERFLOW interrupt. */
        uint32_t hdlc_subframe_sent    : 1;  /**< [  4:  4](R/W1C/H) Clear for HDLC_SUBFRAME_SENT interrupt. */
        uint32_t vsbd_done             : 1;  /**< [  3:  3](R/W1C/H) Clear for VSBD_DONE interrupt. */
        uint32_t vsbc_done             : 1;  /**< [  2:  2](R/W1C/H) Clear for VSBC_DONE interrupt. */
        uint32_t vsbb_done             : 1;  /**< [  1:  1](R/W1C/H) Clear for VSBB_DONE interrupt. */
        uint32_t vsba_done             : 1;  /**< [  0:  0](R/W1C/H) Clear for VSBA_DONE interrupt. */
#else /* Word 0 - Little Endian */
        uint32_t vsba_done             : 1;  /**< [  0:  0](R/W1C/H) Clear for VSBA_DONE interrupt. */
        uint32_t vsbb_done             : 1;  /**< [  1:  1](R/W1C/H) Clear for VSBB_DONE interrupt. */
        uint32_t vsbc_done             : 1;  /**< [  2:  2](R/W1C/H) Clear for VSBC_DONE interrupt. */
        uint32_t vsbd_done             : 1;  /**< [  3:  3](R/W1C/H) Clear for VSBD_DONE interrupt. */
        uint32_t hdlc_subframe_sent    : 1;  /**< [  4:  4](R/W1C/H) Clear for HDLC_SUBFRAME_SENT interrupt. */
        uint32_t vsba_underflow        : 1;  /**< [  5:  5](R/W1C/H) Clear for VSBA_UNDERFLOW interrupt. */
        uint32_t vsbb_underflow        : 1;  /**< [  6:  6](R/W1C/H) Clear for VSBB_UNDERFLOW interrupt. */
        uint32_t vsbc_underflow        : 1;  /**< [  7:  7](R/W1C/H) Clear for VSBC_UNDERFLOW interrupt. */
        uint32_t vsbd_underflow        : 1;  /**< [  8:  8](R/W1C/H) Clear for VSBD_UNDERFLOW interrupt. */
        uint32_t hdlc_underflow        : 1;  /**< [  9:  9](R/W1C/H) Clear for HDLC_UNDERFLOW interrupt. */
        uint32_t vsbx_overlap          : 1;  /**< [ 10: 10](R/W1C/H) Clear for VSBX_OVERLAP interrupt. */
        uint32_t hdlc_disconnect       : 1;  /**< [ 11: 11](R/W1C/H) Clear for HDLC_DISCONNECT interrupt. */
        uint32_t axc_overlap           : 1;  /**< [ 12: 12](R/W1C/H) Clear for AXC_OVERLAP interrupt. */
        uint32_t axc_collision         : 1;  /**< [ 13: 13](R/W1C/H) Clear for AXC_COLLISION interrupt. */
        uint32_t tunnel_collision      : 1;  /**< [ 14: 14](R/W1C/H) Clear for TUNNEL_COLLISION interrupt. */
        uint32_t ctx_collision         : 1;  /**< [ 15: 15](R/W1C/H) Clear for CTX_COLLISION interrupt. */
        uint32_t crc_error             : 1;  /**< [ 16: 16](R/W1C/H) Clear for CRC_ERROR interrupt.
                                                                   0 = No effect.
                                                                   1 = Clear interrupt. */
        uint32_t reserved_17_31        : 15;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_int_clr_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_int_clr_lnx cavm_cprix_cn4ipx_ctx_int_clr_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_INT_CLR_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_INT_CLR_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x8640008282c4ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_INT_CLR_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_INT_CLR_LNX(a,b,c) cavm_cprix_cn4ipx_ctx_int_clr_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_INT_CLR_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_INT_CLR_LNX(a,b,c) "CPRIX_CN4IPX_CTX_INT_CLR_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_INT_CLR_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_INT_CLR_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_int_mask_ln#
 *
 * CPRI CONN4 IP CPRI TX Interrupt Event Mask Register
 */
union cavm_cprix_cn4ipx_ctx_int_mask_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_int_mask_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_17_31        : 15;
        uint32_t crc_error             : 1;  /**< [ 16: 16](R/W) Mask for CRC_ERROR interrupt:
                                                                   0 = Interrupt enables.
                                                                   1 = Interrupt disabled. */
        uint32_t ctx_collision         : 1;  /**< [ 15: 15](R/W) Mask for CTX_COLLISION interrupt. */
        uint32_t tunnel_collision      : 1;  /**< [ 14: 14](R/W) Mask for TUNNEL_COLLISION interrupt. */
        uint32_t axc_collision         : 1;  /**< [ 13: 13](R/W) Mask for AXC_COLLISION interrupt. */
        uint32_t axc_overlap           : 1;  /**< [ 12: 12](R/W) Mask for AXC_OVERLAP interrupt. */
        uint32_t hdlc_disconnect       : 1;  /**< [ 11: 11](R/W) Mask for HDLC_DISCONNECT interrupt. */
        uint32_t vsbx_overlap          : 1;  /**< [ 10: 10](R/W) Mask for VSBX_OVERLAP interrupt. */
        uint32_t hdlc_underflow        : 1;  /**< [  9:  9](R/W) Mask for HDLC_UNDERFLOW interrupt. */
        uint32_t vsbd_underflow        : 1;  /**< [  8:  8](R/W) Mask for VSBD_UNDERFLOW interrupt. */
        uint32_t vsbc_underflow        : 1;  /**< [  7:  7](R/W) Mask for VSBC_UNDERFLOW interrupt. */
        uint32_t vsbb_underflow        : 1;  /**< [  6:  6](R/W) Mask for VSBB_UNDERFLOW interrupt. */
        uint32_t vsba_underflow        : 1;  /**< [  5:  5](R/W) Mask for VSBA_UNDERFLOW interrupt. */
        uint32_t hdlc_subframe_sent    : 1;  /**< [  4:  4](R/W) Mask for HDLC_SUBFRAME_SENT interrupt. */
        uint32_t vsbd_done             : 1;  /**< [  3:  3](R/W) Mask for VSBD_DONE interrupt. */
        uint32_t vsbc_done             : 1;  /**< [  2:  2](R/W) Mask for VSBC_DONE interrupt. */
        uint32_t vsbb_done             : 1;  /**< [  1:  1](R/W) Mask for VSBB_DONE interrupt. */
        uint32_t vsba_done             : 1;  /**< [  0:  0](R/W) Mask for VSBA_DONE interrupt. */
#else /* Word 0 - Little Endian */
        uint32_t vsba_done             : 1;  /**< [  0:  0](R/W) Mask for VSBA_DONE interrupt. */
        uint32_t vsbb_done             : 1;  /**< [  1:  1](R/W) Mask for VSBB_DONE interrupt. */
        uint32_t vsbc_done             : 1;  /**< [  2:  2](R/W) Mask for VSBC_DONE interrupt. */
        uint32_t vsbd_done             : 1;  /**< [  3:  3](R/W) Mask for VSBD_DONE interrupt. */
        uint32_t hdlc_subframe_sent    : 1;  /**< [  4:  4](R/W) Mask for HDLC_SUBFRAME_SENT interrupt. */
        uint32_t vsba_underflow        : 1;  /**< [  5:  5](R/W) Mask for VSBA_UNDERFLOW interrupt. */
        uint32_t vsbb_underflow        : 1;  /**< [  6:  6](R/W) Mask for VSBB_UNDERFLOW interrupt. */
        uint32_t vsbc_underflow        : 1;  /**< [  7:  7](R/W) Mask for VSBC_UNDERFLOW interrupt. */
        uint32_t vsbd_underflow        : 1;  /**< [  8:  8](R/W) Mask for VSBD_UNDERFLOW interrupt. */
        uint32_t hdlc_underflow        : 1;  /**< [  9:  9](R/W) Mask for HDLC_UNDERFLOW interrupt. */
        uint32_t vsbx_overlap          : 1;  /**< [ 10: 10](R/W) Mask for VSBX_OVERLAP interrupt. */
        uint32_t hdlc_disconnect       : 1;  /**< [ 11: 11](R/W) Mask for HDLC_DISCONNECT interrupt. */
        uint32_t axc_overlap           : 1;  /**< [ 12: 12](R/W) Mask for AXC_OVERLAP interrupt. */
        uint32_t axc_collision         : 1;  /**< [ 13: 13](R/W) Mask for AXC_COLLISION interrupt. */
        uint32_t tunnel_collision      : 1;  /**< [ 14: 14](R/W) Mask for TUNNEL_COLLISION interrupt. */
        uint32_t ctx_collision         : 1;  /**< [ 15: 15](R/W) Mask for CTX_COLLISION interrupt. */
        uint32_t crc_error             : 1;  /**< [ 16: 16](R/W) Mask for CRC_ERROR interrupt:
                                                                   0 = Interrupt enables.
                                                                   1 = Interrupt disabled. */
        uint32_t reserved_17_31        : 15;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_int_mask_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_int_mask_lnx cavm_cprix_cn4ipx_ctx_int_mask_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_INT_MASK_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_INT_MASK_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x8640008282d0ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_INT_MASK_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_INT_MASK_LNX(a,b,c) cavm_cprix_cn4ipx_ctx_int_mask_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_INT_MASK_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_INT_MASK_LNX(a,b,c) "CPRIX_CN4IPX_CTX_INT_MASK_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_INT_MASK_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_INT_MASK_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_int_mskclr_ln#
 *
 * CPRI CONN4 IP CPRI TX Interrupt Event Mask Clear Register
 */
union cavm_cprix_cn4ipx_ctx_int_mskclr_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_int_mskclr_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_17_31        : 15;
        uint32_t crc_error             : 1;  /**< [ 16: 16](R/W1C/H) Clear Mask for CRC_ERROR interrupt:
                                                                   0 = No effect.
                                                                   1 = Clear Mask interrupt. */
        uint32_t ctx_collision         : 1;  /**< [ 15: 15](R/W1C/H) Clear Mask for CTX_COLLISION interrupt. */
        uint32_t tunnel_collision      : 1;  /**< [ 14: 14](R/W1C/H) Clear Mask for TUNNEL_COLLISION interrupt. */
        uint32_t axc_collision         : 1;  /**< [ 13: 13](R/W1C/H) Clear Mask for AXC_COLLISION interrupt. */
        uint32_t axc_overlap           : 1;  /**< [ 12: 12](R/W1C/H) Clear Mask for AXC_OVERLAP interrupt. */
        uint32_t hdlc_disconnect       : 1;  /**< [ 11: 11](R/W1C/H) Clear Mask for HDLC_DISCONNECT interrupt. */
        uint32_t vsbx_overlap          : 1;  /**< [ 10: 10](R/W1C/H) Clear Mask for VSBX_OVERLAP interrupt. */
        uint32_t hdlc_underflow        : 1;  /**< [  9:  9](R/W1C/H) Clear Mask for HDLC_UNDERFLOW interrupt. */
        uint32_t vsbd_underflow        : 1;  /**< [  8:  8](R/W1C/H) Clear Mask for VSBD_UNDERFLOW interrupt. */
        uint32_t vsbc_underflow        : 1;  /**< [  7:  7](R/W1C/H) Clear Mask for VSBC_UNDERFLOW interrupt. */
        uint32_t vsbb_underflow        : 1;  /**< [  6:  6](R/W1C/H) Clear Mask for VSBB_UNDERFLOW interrupt. */
        uint32_t vsba_underflow        : 1;  /**< [  5:  5](R/W1C/H) Clear Mask for VSBA_UNDERFLOW interrupt. */
        uint32_t hdlc_subframe_sent    : 1;  /**< [  4:  4](R/W1C/H) Clear Mask for HDLC_SUBFRAME_SENT interrupt. */
        uint32_t vsbd_done             : 1;  /**< [  3:  3](R/W1C/H) Clear Mask for VSBD_DONE interrupt. */
        uint32_t vsbc_done             : 1;  /**< [  2:  2](R/W1C/H) Clear Mask for VSBC_DONE interrupt. */
        uint32_t vsbb_done             : 1;  /**< [  1:  1](R/W1C/H) Clear Mask for VSBB_DONE interrupt. */
        uint32_t vsba_done             : 1;  /**< [  0:  0](R/W1C/H) Clear Mask for VSBA_DONE interrupt. */
#else /* Word 0 - Little Endian */
        uint32_t vsba_done             : 1;  /**< [  0:  0](R/W1C/H) Clear Mask for VSBA_DONE interrupt. */
        uint32_t vsbb_done             : 1;  /**< [  1:  1](R/W1C/H) Clear Mask for VSBB_DONE interrupt. */
        uint32_t vsbc_done             : 1;  /**< [  2:  2](R/W1C/H) Clear Mask for VSBC_DONE interrupt. */
        uint32_t vsbd_done             : 1;  /**< [  3:  3](R/W1C/H) Clear Mask for VSBD_DONE interrupt. */
        uint32_t hdlc_subframe_sent    : 1;  /**< [  4:  4](R/W1C/H) Clear Mask for HDLC_SUBFRAME_SENT interrupt. */
        uint32_t vsba_underflow        : 1;  /**< [  5:  5](R/W1C/H) Clear Mask for VSBA_UNDERFLOW interrupt. */
        uint32_t vsbb_underflow        : 1;  /**< [  6:  6](R/W1C/H) Clear Mask for VSBB_UNDERFLOW interrupt. */
        uint32_t vsbc_underflow        : 1;  /**< [  7:  7](R/W1C/H) Clear Mask for VSBC_UNDERFLOW interrupt. */
        uint32_t vsbd_underflow        : 1;  /**< [  8:  8](R/W1C/H) Clear Mask for VSBD_UNDERFLOW interrupt. */
        uint32_t hdlc_underflow        : 1;  /**< [  9:  9](R/W1C/H) Clear Mask for HDLC_UNDERFLOW interrupt. */
        uint32_t vsbx_overlap          : 1;  /**< [ 10: 10](R/W1C/H) Clear Mask for VSBX_OVERLAP interrupt. */
        uint32_t hdlc_disconnect       : 1;  /**< [ 11: 11](R/W1C/H) Clear Mask for HDLC_DISCONNECT interrupt. */
        uint32_t axc_overlap           : 1;  /**< [ 12: 12](R/W1C/H) Clear Mask for AXC_OVERLAP interrupt. */
        uint32_t axc_collision         : 1;  /**< [ 13: 13](R/W1C/H) Clear Mask for AXC_COLLISION interrupt. */
        uint32_t tunnel_collision      : 1;  /**< [ 14: 14](R/W1C/H) Clear Mask for TUNNEL_COLLISION interrupt. */
        uint32_t ctx_collision         : 1;  /**< [ 15: 15](R/W1C/H) Clear Mask for CTX_COLLISION interrupt. */
        uint32_t crc_error             : 1;  /**< [ 16: 16](R/W1C/H) Clear Mask for CRC_ERROR interrupt:
                                                                   0 = No effect.
                                                                   1 = Clear Mask interrupt. */
        uint32_t reserved_17_31        : 15;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_int_mskclr_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_int_mskclr_lnx cavm_cprix_cn4ipx_ctx_int_mskclr_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_INT_MSKCLR_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_INT_MSKCLR_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x8640008282d4ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_INT_MSKCLR_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_INT_MSKCLR_LNX(a,b,c) cavm_cprix_cn4ipx_ctx_int_mskclr_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_INT_MSKCLR_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_INT_MSKCLR_LNX(a,b,c) "CPRIX_CN4IPX_CTX_INT_MSKCLR_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_INT_MSKCLR_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_INT_MSKCLR_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_int_mskset_ln#
 *
 * CPRI CONN4 IP CPRI TX Interrupt Event Mask Set Register
 */
union cavm_cprix_cn4ipx_ctx_int_mskset_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_int_mskset_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_17_31        : 15;
        uint32_t crc_error             : 1;  /**< [ 16: 16](R/W1S/H) Set Mask for CRC_ERROR interrupt:
                                                                   0 = No effect.
                                                                   1 = Set Mask interrupt. */
        uint32_t ctx_collision         : 1;  /**< [ 15: 15](R/W1S/H) Set Mask for CTX_COLLISION interrupt. */
        uint32_t tunnel_collision      : 1;  /**< [ 14: 14](R/W1S/H) Set Mask for TUNNEL_COLLISION interrupt. */
        uint32_t axc_collision         : 1;  /**< [ 13: 13](R/W1S/H) Set Mask for AXC_COLLISION interrupt. */
        uint32_t axc_overlap           : 1;  /**< [ 12: 12](R/W1S/H) Set Mask for AXC_OVERLAP interrupt. */
        uint32_t hdlc_disconnect       : 1;  /**< [ 11: 11](R/W1S/H) Set Mask for HDLC_DISCONNECT interrupt. */
        uint32_t vsbx_overlap          : 1;  /**< [ 10: 10](R/W1S/H) Set Mask for VSBX_OVERLAP interrupt. */
        uint32_t hdlc_underflow        : 1;  /**< [  9:  9](R/W1S/H) Set Mask for HDLC_UNDERFLOW interrupt. */
        uint32_t vsbd_underflow        : 1;  /**< [  8:  8](R/W1S/H) Set Mask for VSBD_UNDERFLOW interrupt. */
        uint32_t vsbc_underflow        : 1;  /**< [  7:  7](R/W1S/H) Set Mask for VSBC_UNDERFLOW interrupt. */
        uint32_t vsbb_underflow        : 1;  /**< [  6:  6](R/W1S/H) Set Mask for VSBB_UNDERFLOW interrupt. */
        uint32_t vsba_underflow        : 1;  /**< [  5:  5](R/W1S/H) Set Mask for VSBA_UNDERFLOW interrupt. */
        uint32_t hdlc_subframe_sent    : 1;  /**< [  4:  4](R/W1S/H) Set Mask for HDLC_SUBFRAME_SENT interrupt. */
        uint32_t vsbd_done             : 1;  /**< [  3:  3](R/W1S/H) Set Mask for VSBD_DONE interrupt. */
        uint32_t vsbc_done             : 1;  /**< [  2:  2](R/W1S/H) Set Mask for VSBC_DONE interrupt. */
        uint32_t vsbb_done             : 1;  /**< [  1:  1](R/W1S/H) Set Mask for VSBB_DONE interrupt. */
        uint32_t vsba_done             : 1;  /**< [  0:  0](R/W1S/H) Set Mask for VSBA_DONE interrupt. */
#else /* Word 0 - Little Endian */
        uint32_t vsba_done             : 1;  /**< [  0:  0](R/W1S/H) Set Mask for VSBA_DONE interrupt. */
        uint32_t vsbb_done             : 1;  /**< [  1:  1](R/W1S/H) Set Mask for VSBB_DONE interrupt. */
        uint32_t vsbc_done             : 1;  /**< [  2:  2](R/W1S/H) Set Mask for VSBC_DONE interrupt. */
        uint32_t vsbd_done             : 1;  /**< [  3:  3](R/W1S/H) Set Mask for VSBD_DONE interrupt. */
        uint32_t hdlc_subframe_sent    : 1;  /**< [  4:  4](R/W1S/H) Set Mask for HDLC_SUBFRAME_SENT interrupt. */
        uint32_t vsba_underflow        : 1;  /**< [  5:  5](R/W1S/H) Set Mask for VSBA_UNDERFLOW interrupt. */
        uint32_t vsbb_underflow        : 1;  /**< [  6:  6](R/W1S/H) Set Mask for VSBB_UNDERFLOW interrupt. */
        uint32_t vsbc_underflow        : 1;  /**< [  7:  7](R/W1S/H) Set Mask for VSBC_UNDERFLOW interrupt. */
        uint32_t vsbd_underflow        : 1;  /**< [  8:  8](R/W1S/H) Set Mask for VSBD_UNDERFLOW interrupt. */
        uint32_t hdlc_underflow        : 1;  /**< [  9:  9](R/W1S/H) Set Mask for HDLC_UNDERFLOW interrupt. */
        uint32_t vsbx_overlap          : 1;  /**< [ 10: 10](R/W1S/H) Set Mask for VSBX_OVERLAP interrupt. */
        uint32_t hdlc_disconnect       : 1;  /**< [ 11: 11](R/W1S/H) Set Mask for HDLC_DISCONNECT interrupt. */
        uint32_t axc_overlap           : 1;  /**< [ 12: 12](R/W1S/H) Set Mask for AXC_OVERLAP interrupt. */
        uint32_t axc_collision         : 1;  /**< [ 13: 13](R/W1S/H) Set Mask for AXC_COLLISION interrupt. */
        uint32_t tunnel_collision      : 1;  /**< [ 14: 14](R/W1S/H) Set Mask for TUNNEL_COLLISION interrupt. */
        uint32_t ctx_collision         : 1;  /**< [ 15: 15](R/W1S/H) Set Mask for CTX_COLLISION interrupt. */
        uint32_t crc_error             : 1;  /**< [ 16: 16](R/W1S/H) Set Mask for CRC_ERROR interrupt:
                                                                   0 = No effect.
                                                                   1 = Set Mask interrupt. */
        uint32_t reserved_17_31        : 15;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_int_mskset_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_int_mskset_lnx cavm_cprix_cn4ipx_ctx_int_mskset_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_INT_MSKSET_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_INT_MSKSET_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x8640008282d8ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_INT_MSKSET_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_INT_MSKSET_LNX(a,b,c) cavm_cprix_cn4ipx_ctx_int_mskset_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_INT_MSKSET_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_INT_MSKSET_LNX(a,b,c) "CPRIX_CN4IPX_CTX_INT_MSKSET_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_INT_MSKSET_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_INT_MSKSET_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_int_set_ln#
 *
 * CPRI CONN4 IP CPRI TX Interrupt Event Set Register
 */
union cavm_cprix_cn4ipx_ctx_int_set_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_int_set_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_17_31        : 15;
        uint32_t crc_error             : 1;  /**< [ 16: 16](R/W1S/H) Set for CRC_ERROR interrupt.
                                                                   0 = No effect.
                                                                   1 = Set interrupt. */
        uint32_t ctx_collision         : 1;  /**< [ 15: 15](R/W1S/H) Set for CTX_COLLISION interrupt. */
        uint32_t tunnel_collision      : 1;  /**< [ 14: 14](R/W1S/H) Set for TUNNEL_COLLISION interrupt. */
        uint32_t axc_collision         : 1;  /**< [ 13: 13](R/W1S/H) Set for AXC_COLLISION interrupt. */
        uint32_t axc_overlap           : 1;  /**< [ 12: 12](R/W1S/H) Set for AXC_OVERLAP interrupt. */
        uint32_t hdlc_disconnect       : 1;  /**< [ 11: 11](R/W1S/H) Set for HDLC_DISCONNECT interrupt. */
        uint32_t vsbx_overlap          : 1;  /**< [ 10: 10](R/W1S/H) Set for VSBX_OVERLAP interrupt. */
        uint32_t hdlc_underflow        : 1;  /**< [  9:  9](R/W1S/H) Set for HDLC_UNDERFLOW interrupt. */
        uint32_t vsbd_underflow        : 1;  /**< [  8:  8](R/W1S/H) Set for VSBD_UNDERFLOW interrupt. */
        uint32_t vsbc_underflow        : 1;  /**< [  7:  7](R/W1S/H) Set for VSBC_UNDERFLOW interrupt. */
        uint32_t vsbb_underflow        : 1;  /**< [  6:  6](R/W1S/H) Set for VSBB_UNDERFLOW interrupt. */
        uint32_t vsba_underflow        : 1;  /**< [  5:  5](R/W1S/H) Set for VSBA_UNDERFLOW interrupt. */
        uint32_t hdlc_subframe_sent    : 1;  /**< [  4:  4](R/W1S/H) Set for HDLC_SUBFRAME_SENT interrupt. */
        uint32_t vsbd_done             : 1;  /**< [  3:  3](R/W1S/H) Set for VSBD_DONE interrupt. */
        uint32_t vsbc_done             : 1;  /**< [  2:  2](R/W1S/H) Set for VSBC_DONE interrupt. */
        uint32_t vsbb_done             : 1;  /**< [  1:  1](R/W1S/H) Set for VSBB_DONE interrupt. */
        uint32_t vsba_done             : 1;  /**< [  0:  0](R/W1S/H) Set for VSBA_DONE interrupt. */
#else /* Word 0 - Little Endian */
        uint32_t vsba_done             : 1;  /**< [  0:  0](R/W1S/H) Set for VSBA_DONE interrupt. */
        uint32_t vsbb_done             : 1;  /**< [  1:  1](R/W1S/H) Set for VSBB_DONE interrupt. */
        uint32_t vsbc_done             : 1;  /**< [  2:  2](R/W1S/H) Set for VSBC_DONE interrupt. */
        uint32_t vsbd_done             : 1;  /**< [  3:  3](R/W1S/H) Set for VSBD_DONE interrupt. */
        uint32_t hdlc_subframe_sent    : 1;  /**< [  4:  4](R/W1S/H) Set for HDLC_SUBFRAME_SENT interrupt. */
        uint32_t vsba_underflow        : 1;  /**< [  5:  5](R/W1S/H) Set for VSBA_UNDERFLOW interrupt. */
        uint32_t vsbb_underflow        : 1;  /**< [  6:  6](R/W1S/H) Set for VSBB_UNDERFLOW interrupt. */
        uint32_t vsbc_underflow        : 1;  /**< [  7:  7](R/W1S/H) Set for VSBC_UNDERFLOW interrupt. */
        uint32_t vsbd_underflow        : 1;  /**< [  8:  8](R/W1S/H) Set for VSBD_UNDERFLOW interrupt. */
        uint32_t hdlc_underflow        : 1;  /**< [  9:  9](R/W1S/H) Set for HDLC_UNDERFLOW interrupt. */
        uint32_t vsbx_overlap          : 1;  /**< [ 10: 10](R/W1S/H) Set for VSBX_OVERLAP interrupt. */
        uint32_t hdlc_disconnect       : 1;  /**< [ 11: 11](R/W1S/H) Set for HDLC_DISCONNECT interrupt. */
        uint32_t axc_overlap           : 1;  /**< [ 12: 12](R/W1S/H) Set for AXC_OVERLAP interrupt. */
        uint32_t axc_collision         : 1;  /**< [ 13: 13](R/W1S/H) Set for AXC_COLLISION interrupt. */
        uint32_t tunnel_collision      : 1;  /**< [ 14: 14](R/W1S/H) Set for TUNNEL_COLLISION interrupt. */
        uint32_t ctx_collision         : 1;  /**< [ 15: 15](R/W1S/H) Set for CTX_COLLISION interrupt. */
        uint32_t crc_error             : 1;  /**< [ 16: 16](R/W1S/H) Set for CRC_ERROR interrupt.
                                                                   0 = No effect.
                                                                   1 = Set interrupt. */
        uint32_t reserved_17_31        : 15;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_int_set_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_int_set_lnx cavm_cprix_cn4ipx_ctx_int_set_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_INT_SET_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_INT_SET_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x8640008282c8ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_INT_SET_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_INT_SET_LNX(a,b,c) cavm_cprix_cn4ipx_ctx_int_set_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_INT_SET_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_INT_SET_LNX(a,b,c) "CPRIX_CN4IPX_CTX_INT_SET_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_INT_SET_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_INT_SET_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_int_sts_ln#
 *
 * CPRI CONN4 IP CPRI TX Interrupt Status Register
 */
union cavm_cprix_cn4ipx_ctx_int_sts_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_int_sts_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_17_31        : 15;
        uint32_t crc_error             : 1;  /**< [ 16: 16](RO/H) CRC error has been detected in an SDVM, RTWP or Tunnel message.
                                                                   0 = no error.
                                                                   1 = CRC error has been detected.
                                                                 Register CTX_CRC_STATUS provides more information. */
        uint32_t ctx_collision         : 1;  /**< [ 15: 15](RO/H) At least two CTX sub-blocks are transmitting to same frame location.
                                                                   0 = no collision.
                                                                   1 = collision detected.
                                                                 Register CTX_STATUS provides more information. */
        uint32_t tunnel_collision      : 1;  /**< [ 14: 14](RO/H) At least two tunnel channels are transmitting to same frame location.
                                                                   0 = no collision.
                                                                   1 = collision detected.
                                                                 Registers CTX_TUNNEL_STATUS_0 and CTX_TUNNEL_STATUS_1 provide more information. */
        uint32_t axc_collision         : 1;  /**< [ 13: 13](RO/H) AxC collision detected. More information is in registers CTX_STATUS_0/_1.
                                                                   0 = no collision.
                                                                   1 = collision detected. */
        uint32_t axc_overlap           : 1;  /**< [ 12: 12](RO/H) AxC overlap detected. More information is in CTX_STATUS_0: VSBA/B/C/D_CAPTURE.
                                                                   0 = no overlap.
                                                                   1 = overlap detected. */
        uint32_t hdlc_disconnect       : 1;  /**< [ 11: 11](RO/H) HDLC stream from MCU has been disconnected. */
        uint32_t vsbx_overlap          : 1;  /**< [ 10: 10](RO/H) Overlap detected between two of the regions VSBA, VSBB, VSBC or VSBD. More
                                                                 information is in register CTX_VSBX_OVERLAP.
                                                                   0 = no region overlap.
                                                                   1 = region overlap detected. */
        uint32_t hdlc_underflow        : 1;  /**< [  9:  9](RO/H) Last subframe from HDLC buffer has been transmitted. */
        uint32_t vsbd_underflow        : 1;  /**< [  8:  8](RO/H) Underflow in VSB buffer D. */
        uint32_t vsbc_underflow        : 1;  /**< [  7:  7](RO/H) Underflow in VSB buffer C. */
        uint32_t vsbb_underflow        : 1;  /**< [  6:  6](RO/H) Underflow in VSB buffer B. */
        uint32_t vsba_underflow        : 1;  /**< [  5:  5](RO/H) Underflow in VSB buffer A. */
        uint32_t hdlc_subframe_sent    : 1;  /**< [  4:  4](RO/H) A subframe from HDLC buffer has been transmitted. */
        uint32_t vsbd_done             : 1;  /**< [  3:  3](RO/H) A slice in VSB buffer D has been transmitted. */
        uint32_t vsbc_done             : 1;  /**< [  2:  2](RO/H) A slice in VSB buffer C has been transmitted. */
        uint32_t vsbb_done             : 1;  /**< [  1:  1](RO/H) A slice in VSB buffer B has been transmitted. */
        uint32_t vsba_done             : 1;  /**< [  0:  0](RO/H) A slice in VSB buffer A has been transmitted.
                                                                   0 = not transmitted.
                                                                   1 = transmitted. */
#else /* Word 0 - Little Endian */
        uint32_t vsba_done             : 1;  /**< [  0:  0](RO/H) A slice in VSB buffer A has been transmitted.
                                                                   0 = not transmitted.
                                                                   1 = transmitted. */
        uint32_t vsbb_done             : 1;  /**< [  1:  1](RO/H) A slice in VSB buffer B has been transmitted. */
        uint32_t vsbc_done             : 1;  /**< [  2:  2](RO/H) A slice in VSB buffer C has been transmitted. */
        uint32_t vsbd_done             : 1;  /**< [  3:  3](RO/H) A slice in VSB buffer D has been transmitted. */
        uint32_t hdlc_subframe_sent    : 1;  /**< [  4:  4](RO/H) A subframe from HDLC buffer has been transmitted. */
        uint32_t vsba_underflow        : 1;  /**< [  5:  5](RO/H) Underflow in VSB buffer A. */
        uint32_t vsbb_underflow        : 1;  /**< [  6:  6](RO/H) Underflow in VSB buffer B. */
        uint32_t vsbc_underflow        : 1;  /**< [  7:  7](RO/H) Underflow in VSB buffer C. */
        uint32_t vsbd_underflow        : 1;  /**< [  8:  8](RO/H) Underflow in VSB buffer D. */
        uint32_t hdlc_underflow        : 1;  /**< [  9:  9](RO/H) Last subframe from HDLC buffer has been transmitted. */
        uint32_t vsbx_overlap          : 1;  /**< [ 10: 10](RO/H) Overlap detected between two of the regions VSBA, VSBB, VSBC or VSBD. More
                                                                 information is in register CTX_VSBX_OVERLAP.
                                                                   0 = no region overlap.
                                                                   1 = region overlap detected. */
        uint32_t hdlc_disconnect       : 1;  /**< [ 11: 11](RO/H) HDLC stream from MCU has been disconnected. */
        uint32_t axc_overlap           : 1;  /**< [ 12: 12](RO/H) AxC overlap detected. More information is in CTX_STATUS_0: VSBA/B/C/D_CAPTURE.
                                                                   0 = no overlap.
                                                                   1 = overlap detected. */
        uint32_t axc_collision         : 1;  /**< [ 13: 13](RO/H) AxC collision detected. More information is in registers CTX_STATUS_0/_1.
                                                                   0 = no collision.
                                                                   1 = collision detected. */
        uint32_t tunnel_collision      : 1;  /**< [ 14: 14](RO/H) At least two tunnel channels are transmitting to same frame location.
                                                                   0 = no collision.
                                                                   1 = collision detected.
                                                                 Registers CTX_TUNNEL_STATUS_0 and CTX_TUNNEL_STATUS_1 provide more information. */
        uint32_t ctx_collision         : 1;  /**< [ 15: 15](RO/H) At least two CTX sub-blocks are transmitting to same frame location.
                                                                   0 = no collision.
                                                                   1 = collision detected.
                                                                 Register CTX_STATUS provides more information. */
        uint32_t crc_error             : 1;  /**< [ 16: 16](RO/H) CRC error has been detected in an SDVM, RTWP or Tunnel message.
                                                                   0 = no error.
                                                                   1 = CRC error has been detected.
                                                                 Register CTX_CRC_STATUS provides more information. */
        uint32_t reserved_17_31        : 15;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_int_sts_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_int_sts_lnx cavm_cprix_cn4ipx_ctx_int_sts_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_INT_STS_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_INT_STS_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x8640008282c0ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_INT_STS_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_INT_STS_LNX(a,b,c) cavm_cprix_cn4ipx_ctx_int_sts_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_INT_STS_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_INT_STS_LNX(a,b,c) "CPRIX_CN4IPX_CTX_INT_STS_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_INT_STS_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_INT_STS_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_l1_ln#
 *
 * CPRI CONN4 IP CPRI TX L1 Inband Protocol Register
 */
union cavm_cprix_cn4ipx_ctx_l1_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_l1_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_17_31        : 15;
        uint32_t ctx_l1_protocol_ver   : 1;  /**< [ 16: 16](R/W) CPRI TX protocol version selection.
                                                                   0 = version 1. Value "00000001" sent to Z.2.0 byte.
                                                                   1 = version 2. (scrambling enabled) Value "00000010" sent to Z.2.0 byte. */
        uint32_t reserved_14_15        : 2;
        uint32_t ctx_l1_eth_p          : 6;  /**< [ 13:  8](R/W) Ethernet subchannel pointer p to the start of Ethernet frame.
                                                                   0x0 = no Ethernet.
                                                                   0x13-0x1 = invalid.
                                                                   0x3F-0x14 = start of Ethernet channel. */
        uint32_t ctx_l1_hdlc_br        : 3;  /**< [  7:  5](R/W) HDLC bit rate selection.
                                                                   0x0 = no HDLC.
                                                                   0x1 = 240kbit/s.
                                                                   0x2 = 480kbit/s.
                                                                   0x3 = 960kbit/s.
                                                                   0x4 = 1920kbit/s.
                                                                   0x5 = 2400kbit/s.
                                                                   0x6 = 3840kbit/s for RATE = 0x2.
                                                                         4800kbit/s for RATE = 0x3.
                                                                         7680kbit/s for RATE = 0x4.
                                                                   0x7 = HDLC negotiated at higher level (no HDLC transmitted ). */
        uint32_t ctx_l1_func           : 5;  /**< [  4:  0](R/W) Basic layer 1 functions.
                                                                   0:Reset.
                                                                   1:RAI.
                                                                   2:SDI.
                                                                   3:LOS.
                                                                   4:LOF. */
#else /* Word 0 - Little Endian */
        uint32_t ctx_l1_func           : 5;  /**< [  4:  0](R/W) Basic layer 1 functions.
                                                                   0:Reset.
                                                                   1:RAI.
                                                                   2:SDI.
                                                                   3:LOS.
                                                                   4:LOF. */
        uint32_t ctx_l1_hdlc_br        : 3;  /**< [  7:  5](R/W) HDLC bit rate selection.
                                                                   0x0 = no HDLC.
                                                                   0x1 = 240kbit/s.
                                                                   0x2 = 480kbit/s.
                                                                   0x3 = 960kbit/s.
                                                                   0x4 = 1920kbit/s.
                                                                   0x5 = 2400kbit/s.
                                                                   0x6 = 3840kbit/s for RATE = 0x2.
                                                                         4800kbit/s for RATE = 0x3.
                                                                         7680kbit/s for RATE = 0x4.
                                                                   0x7 = HDLC negotiated at higher level (no HDLC transmitted ). */
        uint32_t ctx_l1_eth_p          : 6;  /**< [ 13:  8](R/W) Ethernet subchannel pointer p to the start of Ethernet frame.
                                                                   0x0 = no Ethernet.
                                                                   0x13-0x1 = invalid.
                                                                   0x3F-0x14 = start of Ethernet channel. */
        uint32_t reserved_14_15        : 2;
        uint32_t ctx_l1_protocol_ver   : 1;  /**< [ 16: 16](R/W) CPRI TX protocol version selection.
                                                                   0 = version 1. Value "00000001" sent to Z.2.0 byte.
                                                                   1 = version 2. (scrambling enabled) Value "00000010" sent to Z.2.0 byte. */
        uint32_t reserved_17_31        : 15;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_l1_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_l1_lnx cavm_cprix_cn4ipx_ctx_l1_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_L1_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_L1_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000828018ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_L1_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_L1_LNX(a,b,c) cavm_cprix_cn4ipx_ctx_l1_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_L1_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_L1_LNX(a,b,c) "CPRIX_CN4IPX_CTX_L1_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_L1_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_L1_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_loopback_ln#
 *
 * CPRI CONN4 IP CPRI TX Loopback Enable Register
 */
union cavm_cprix_cn4ipx_ctx_loopback_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_loopback_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t crxctx_loop           : 1;  /**< [  0:  0](R/W) Enable loopback from CRX to CTX.
                                                                   0 = Loopback disabled.
                                                                   1 = Loopback enabled. */
#else /* Word 0 - Little Endian */
        uint32_t crxctx_loop           : 1;  /**< [  0:  0](R/W) Enable loopback from CRX to CTX.
                                                                   0 = Loopback disabled.
                                                                   1 = Loopback enabled. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_loopback_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_loopback_lnx cavm_cprix_cn4ipx_ctx_loopback_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_LOOPBACK_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_LOOPBACK_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x86400082803cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_LOOPBACK_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_LOOPBACK_LNX(a,b,c) cavm_cprix_cn4ipx_ctx_loopback_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_LOOPBACK_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_LOOPBACK_LNX(a,b,c) "CPRIX_CN4IPX_CTX_LOOPBACK_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_LOOPBACK_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_LOOPBACK_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_pattern_ln#
 *
 * CPRI CONN4 IP CPRI TX Test Mode Control Register
 */
union cavm_cprix_cn4ipx_ctx_pattern_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_pattern_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t tx_pat_type           : 4;  /**< [  3:  0](R/W) Selects the test pattern type.
                                                                   0x0 = Normal mode, no test pattern.
                                                                   0x1 = Functional BER.
                                                                   0x2 = CJPAT
                                                                   0x3 = not used
                                                                   0x4 = JSPAT
                                                                   0x5 = JTSPAT
                                                                   0x8 = PRBS7
                                                                   0x9 = PRBS7 inverted
                                                                   0xA = PRBS23
                                                                   0xB = PRBS23 inverted
                                                                   0xC = PRBS9
                                                                   0xD = PRBS9 inverted Only functional BER mode can be used during normal operation */
#else /* Word 0 - Little Endian */
        uint32_t tx_pat_type           : 4;  /**< [  3:  0](R/W) Selects the test pattern type.
                                                                   0x0 = Normal mode, no test pattern.
                                                                   0x1 = Functional BER.
                                                                   0x2 = CJPAT
                                                                   0x3 = not used
                                                                   0x4 = JSPAT
                                                                   0x5 = JTSPAT
                                                                   0x8 = PRBS7
                                                                   0x9 = PRBS7 inverted
                                                                   0xA = PRBS23
                                                                   0xB = PRBS23 inverted
                                                                   0xC = PRBS9
                                                                   0xD = PRBS9 inverted Only functional BER mode can be used during normal operation */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_pattern_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_pattern_lnx cavm_cprix_cn4ipx_ctx_pattern_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_PATTERN_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_PATTERN_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000828024ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_PATTERN_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_PATTERN_LNX(a,b,c) cavm_cprix_cn4ipx_ctx_pattern_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_PATTERN_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_PATTERN_LNX(a,b,c) "CPRIX_CN4IPX_CTX_PATTERN_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_PATTERN_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_PATTERN_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_psua_ln#
 *
 * CPRI CONN4 IP CPRI TX Power Supply Alarm Configuration Register
 */
union cavm_cprix_cn4ipx_ctx_psua_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_psua_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t enable                : 1;  /**< [ 31: 31](R/W) Enable transmission of PSU alarm bit. */
        uint32_t reserved_16_30        : 15;
        uint32_t x                     : 8;  /**< [ 15:  8](R/W) CPRI basic frame number X where PSU alarm bit is transmitted.
                                                                   0..0xFF = valid.
                                                                 Alarm bit should never be sent in  reserved subchannels such as 0 and 2. */
        uint32_t reserved_7            : 1;
        uint32_t y2                    : 3;  /**< [  6:  4](R/W) Index of 16-bit word within CPRI word where PSU alarm bit is transmitted.
                                                                   0..7 = valid. */
        uint32_t b_s                   : 4;  /**< [  3:  0](R/W) Index of a bit within a 16-bit word where PSU alarm bit is transmitted.
                                                                   0..0xF = valid. */
#else /* Word 0 - Little Endian */
        uint32_t b_s                   : 4;  /**< [  3:  0](R/W) Index of a bit within a 16-bit word where PSU alarm bit is transmitted.
                                                                   0..0xF = valid. */
        uint32_t y2                    : 3;  /**< [  6:  4](R/W) Index of 16-bit word within CPRI word where PSU alarm bit is transmitted.
                                                                   0..7 = valid. */
        uint32_t reserved_7            : 1;
        uint32_t x                     : 8;  /**< [ 15:  8](R/W) CPRI basic frame number X where PSU alarm bit is transmitted.
                                                                   0..0xFF = valid.
                                                                 Alarm bit should never be sent in  reserved subchannels such as 0 and 2. */
        uint32_t reserved_16_30        : 15;
        uint32_t enable                : 1;  /**< [ 31: 31](R/W) Enable transmission of PSU alarm bit. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_psua_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_psua_lnx cavm_cprix_cn4ipx_ctx_psua_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_PSUA_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_PSUA_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000828280ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_PSUA_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_PSUA_LNX(a,b,c) cavm_cprix_cn4ipx_ctx_psua_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_PSUA_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_PSUA_LNX(a,b,c) "CPRIX_CN4IPX_CTX_PSUA_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_PSUA_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_PSUA_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_rt_ch#_crx_ln#
 *
 * CPRI CONN4 IP CPRI CPRI Route CRX Route Channel Register
 */
union cavm_cprix_cn4ipx_ctx_rt_chx_crx_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_rt_chx_crx_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_27_31        : 5;
        uint32_t crx_link              : 3;  /**< [ 26: 24](R/W) CPRI Rx reception link number.
                                                                   0 to 5 = valid.
                                                                   6 to 7 = invalid, no reception. */
        uint32_t reserved_19_23        : 5;
        uint32_t crx_y                 : 3;  /**< [ 18: 16](R/W) CPRI Rx reception coordinate Y/2.
                                                                   0, 1    = valid.
                                                                   2, 3    = valid for CPRI 8x and faster.
                                                                   4       = valid for CPRI 10x and faster.
                                                                   5, 6, 7 = valid for CPRI 16x. */
        uint32_t crx_x                 : 8;  /**< [ 15:  8](R/W) CPRI Rx reception coordinate X.
                                                                   0 to 0xFF = valid. */
        uint32_t crx_z                 : 8;  /**< [  7:  0](R/W) CPRI Rx reception coordinate Z.
                                                                   0 to 0x95   = valid.
                                                                   0x96 to 0xFE = invalid, no reception.
                                                                   0xFF         = always receive. */
#else /* Word 0 - Little Endian */
        uint32_t crx_z                 : 8;  /**< [  7:  0](R/W) CPRI Rx reception coordinate Z.
                                                                   0 to 0x95   = valid.
                                                                   0x96 to 0xFE = invalid, no reception.
                                                                   0xFF         = always receive. */
        uint32_t crx_x                 : 8;  /**< [ 15:  8](R/W) CPRI Rx reception coordinate X.
                                                                   0 to 0xFF = valid. */
        uint32_t crx_y                 : 3;  /**< [ 18: 16](R/W) CPRI Rx reception coordinate Y/2.
                                                                   0, 1    = valid.
                                                                   2, 3    = valid for CPRI 8x and faster.
                                                                   4       = valid for CPRI 10x and faster.
                                                                   5, 6, 7 = valid for CPRI 16x. */
        uint32_t reserved_19_23        : 5;
        uint32_t crx_link              : 3;  /**< [ 26: 24](R/W) CPRI Rx reception link number.
                                                                   0 to 5 = valid.
                                                                   6 to 7 = invalid, no reception. */
        uint32_t reserved_27_31        : 5;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_rt_chx_crx_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_rt_chx_crx_lnx cavm_cprix_cn4ipx_ctx_rt_chx_crx_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_RT_CHX_CRX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_RT_CHX_CRX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=63) && (d<=1)))
        return 0x86400082b000ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 8ll * ((c) & 0x3f) + 0x10000ll * ((d) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_RT_CHX_CRX_LNX", 4, a, b, c, d, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_RT_CHX_CRX_LNX(a,b,c,d) cavm_cprix_cn4ipx_ctx_rt_chx_crx_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_RT_CHX_CRX_LNX(a,b,c,d) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_RT_CHX_CRX_LNX(a,b,c,d) "CPRIX_CN4IPX_CTX_RT_CHX_CRX_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_RT_CHX_CRX_LNX(a,b,c,d) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_RT_CHX_CRX_LNX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_rt_ch#_ctx_ln#
 *
 * CPRI CONN4 IP CPRI CPRI Route CTX Route Channel Register
 */
union cavm_cprix_cn4ipx_ctx_rt_chx_ctx_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_rt_chx_ctx_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_29_31        : 3;
        uint32_t enable                : 1;  /**< [ 28: 28](R/W) CTX Route channel enable. When enabled, the configured data word of 16 bits is
                                                                 received from configured CPRI Rx line and transmitted onto this CPRI Tx line.
                                                                   0 = disable.
                                                                   1 = enable. */
        uint32_t reserved_19_27        : 9;
        uint32_t ctx_y                 : 3;  /**< [ 18: 16](R/W) CPRI Tx transmission  coordinate Y.
                                                                   0, 1    = valid
                                                                   2, 3    = valid for CPRI 8x and faster
                                                                   4       = valid for CPRI 10x and faster
                                                                   5, 6, 7 = valid for CPRI 16x */
        uint32_t ctx_x                 : 8;  /**< [ 15:  8](R/W) CPRI Tx transmission coordinate X.
                                                                   0 to 0xFF = valid. */
        uint32_t ctx_z                 : 8;  /**< [  7:  0](R/W) CPRI Tx transmission coordinate Z.
                                                                   0 to 0x95   = valid.
                                                                   0x96 to 0xFE = invalid, no transmission.
                                                                   0xFF         = always transmit. */
#else /* Word 0 - Little Endian */
        uint32_t ctx_z                 : 8;  /**< [  7:  0](R/W) CPRI Tx transmission coordinate Z.
                                                                   0 to 0x95   = valid.
                                                                   0x96 to 0xFE = invalid, no transmission.
                                                                   0xFF         = always transmit. */
        uint32_t ctx_x                 : 8;  /**< [ 15:  8](R/W) CPRI Tx transmission coordinate X.
                                                                   0 to 0xFF = valid. */
        uint32_t ctx_y                 : 3;  /**< [ 18: 16](R/W) CPRI Tx transmission  coordinate Y.
                                                                   0, 1    = valid
                                                                   2, 3    = valid for CPRI 8x and faster
                                                                   4       = valid for CPRI 10x and faster
                                                                   5, 6, 7 = valid for CPRI 16x */
        uint32_t reserved_19_27        : 9;
        uint32_t enable                : 1;  /**< [ 28: 28](R/W) CTX Route channel enable. When enabled, the configured data word of 16 bits is
                                                                 received from configured CPRI Rx line and transmitted onto this CPRI Tx line.
                                                                   0 = disable.
                                                                   1 = enable. */
        uint32_t reserved_29_31        : 3;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_rt_chx_ctx_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_rt_chx_ctx_lnx cavm_cprix_cn4ipx_ctx_rt_chx_ctx_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_RT_CHX_CTX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_RT_CHX_CTX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=63) && (d<=1)))
        return 0x86400082b004ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 8ll * ((c) & 0x3f) + 0x10000ll * ((d) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_RT_CHX_CTX_LNX", 4, a, b, c, d, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_RT_CHX_CTX_LNX(a,b,c,d) cavm_cprix_cn4ipx_ctx_rt_chx_ctx_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_RT_CHX_CTX_LNX(a,b,c,d) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_RT_CHX_CTX_LNX(a,b,c,d) "CPRIX_CN4IPX_CTX_RT_CHX_CTX_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_RT_CHX_CTX_LNX(a,b,c,d) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_RT_CHX_CTX_LNX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_rtwp_strm#_ln#
 *
 * CPRI CONN4 IP CPRI TX RTWP Stream Configuration Register
 */
union cavm_cprix_cn4ipx_ctx_rtwp_strmx_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_rtwp_strmx_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t stream_id             : 8;  /**< [  7:  0](R/W) Stream ID for this measurement channel. */
#else /* Word 0 - Little Endian */
        uint32_t stream_id             : 8;  /**< [  7:  0](R/W) Stream ID for this measurement channel. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_rtwp_strmx_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_rtwp_strmx_lnx cavm_cprix_cn4ipx_ctx_rtwp_strmx_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_RTWP_STRMX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_RTWP_STRMX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=15) && (d<=1)))
        return 0x864000828200ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 8ll * ((c) & 0xf) + 0x10000ll * ((d) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_RTWP_STRMX_LNX", 4, a, b, c, d, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_RTWP_STRMX_LNX(a,b,c,d) cavm_cprix_cn4ipx_ctx_rtwp_strmx_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_RTWP_STRMX_LNX(a,b,c,d) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_RTWP_STRMX_LNX(a,b,c,d) "CPRIX_CN4IPX_CTX_RTWP_STRMX_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_RTWP_STRMX_LNX(a,b,c,d) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_RTWP_STRMX_LNX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_rtwp_word#_ln#
 *
 * CPRI CONN4 IP CPRI TX RTWP CPRI Word Configuration Register
 */
union cavm_cprix_cn4ipx_ctx_rtwp_wordx_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_rtwp_wordx_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t enable                : 1;  /**< [ 31: 31](R/W) RTWP Channel enable.
                                                                   0 = disable.
                                                                   1 = enable. */
        uint32_t y2                    : 3;  /**< [ 30: 28](R/W) Position of the 16-bit measurement word in CPRI word.
                                                                   0 = Bytes 1 and 0.
                                                                   1 = Bytes 3 and 2.
                                                                   2 = Bytes 5 and 4.
                                                                   3 = Bytes 7 and 6.
                                                                   4 = Bytes 9 and 8.
                                                                   5 = Bytes 11 and 10.
                                                                   6 = Bytes 13 and 12.
                                                                   7 = Bytes 15 and 14. */
        uint32_t reserved_26_27        : 2;
        uint32_t ns_s                  : 6;  /**< [ 25: 20](R/W) Index of base CPRI subchannel within range 0 to 63. */
        uint32_t mask_3                : 1;  /**< [ 19: 19](R/W) Mask of measurement word C2 Br1.
                                                                   0 = Not masked.
                                                                   1 = Masked. Zero will be transmitted to CPRI line instead of the corresponding
                                                                 value in the message. */
        uint32_t mask_2                : 1;  /**< [ 18: 18](R/W) Mask of measurement word C2 Br0. */
        uint32_t mask_1                : 1;  /**< [ 17: 17](R/W) Mask of measurement word C1 Br1. */
        uint32_t mask_0                : 1;  /**< [ 16: 16](R/W) Mask of measurement word C1 Br0. */
        uint32_t index                 : 8;  /**< [ 15:  8](R/W) Index for Hyperframe number. */
        uint32_t modulo                : 8;  /**< [  7:  0](R/W) Modulo for Hyperframe number. */
#else /* Word 0 - Little Endian */
        uint32_t modulo                : 8;  /**< [  7:  0](R/W) Modulo for Hyperframe number. */
        uint32_t index                 : 8;  /**< [ 15:  8](R/W) Index for Hyperframe number. */
        uint32_t mask_0                : 1;  /**< [ 16: 16](R/W) Mask of measurement word C1 Br0. */
        uint32_t mask_1                : 1;  /**< [ 17: 17](R/W) Mask of measurement word C1 Br1. */
        uint32_t mask_2                : 1;  /**< [ 18: 18](R/W) Mask of measurement word C2 Br0. */
        uint32_t mask_3                : 1;  /**< [ 19: 19](R/W) Mask of measurement word C2 Br1.
                                                                   0 = Not masked.
                                                                   1 = Masked. Zero will be transmitted to CPRI line instead of the corresponding
                                                                 value in the message. */
        uint32_t ns_s                  : 6;  /**< [ 25: 20](R/W) Index of base CPRI subchannel within range 0 to 63. */
        uint32_t reserved_26_27        : 2;
        uint32_t y2                    : 3;  /**< [ 30: 28](R/W) Position of the 16-bit measurement word in CPRI word.
                                                                   0 = Bytes 1 and 0.
                                                                   1 = Bytes 3 and 2.
                                                                   2 = Bytes 5 and 4.
                                                                   3 = Bytes 7 and 6.
                                                                   4 = Bytes 9 and 8.
                                                                   5 = Bytes 11 and 10.
                                                                   6 = Bytes 13 and 12.
                                                                   7 = Bytes 15 and 14. */
        uint32_t enable                : 1;  /**< [ 31: 31](R/W) RTWP Channel enable.
                                                                   0 = disable.
                                                                   1 = enable. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_rtwp_wordx_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_rtwp_wordx_lnx cavm_cprix_cn4ipx_ctx_rtwp_wordx_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_RTWP_WORDX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_RTWP_WORDX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=15) && (d<=1)))
        return 0x864000828204ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 8ll * ((c) & 0xf) + 0x10000ll * ((d) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_RTWP_WORDX_LNX", 4, a, b, c, d, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_RTWP_WORDX_LNX(a,b,c,d) cavm_cprix_cn4ipx_ctx_rtwp_wordx_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_RTWP_WORDX_LNX(a,b,c,d) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_RTWP_WORDX_LNX(a,b,c,d) "CPRIX_CN4IPX_CTX_RTWP_WORDX_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_RTWP_WORDX_LNX(a,b,c,d) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_RTWP_WORDX_LNX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_sdvm_chnl#_ln#
 *
 * CPRI CONN4 IP CPRI TX SDVM Channel Register
 */
union cavm_cprix_cn4ipx_ctx_sdvm_chnlx_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_sdvm_chnlx_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_17_31        : 15;
        uint32_t enable                : 1;  /**< [ 16: 16](R/W) Enable for this channel.
                                                                   0 = disable.
                                                                   1 = enable. */
        uint32_t reserved_8_15         : 8;
        uint32_t stream_id             : 8;  /**< [  7:  0](R/W) Stream ID of this channel. Stream should be configured to FIFO mode. */
#else /* Word 0 - Little Endian */
        uint32_t stream_id             : 8;  /**< [  7:  0](R/W) Stream ID of this channel. Stream should be configured to FIFO mode. */
        uint32_t reserved_8_15         : 8;
        uint32_t enable                : 1;  /**< [ 16: 16](R/W) Enable for this channel.
                                                                   0 = disable.
                                                                   1 = enable. */
        uint32_t reserved_17_31        : 15;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_sdvm_chnlx_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_sdvm_chnlx_lnx cavm_cprix_cn4ipx_ctx_sdvm_chnlx_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_SDVM_CHNLX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_SDVM_CHNLX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=15) && (d<=1)))
        return 0x864000828040ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 4ll * ((c) & 0xf) + 0x10000ll * ((d) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_SDVM_CHNLX_LNX", 4, a, b, c, d, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_SDVM_CHNLX_LNX(a,b,c,d) cavm_cprix_cn4ipx_ctx_sdvm_chnlx_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_SDVM_CHNLX_LNX(a,b,c,d) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_SDVM_CHNLX_LNX(a,b,c,d) "CPRIX_CN4IPX_CTX_SDVM_CHNLX_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_SDVM_CHNLX_LNX(a,b,c,d) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_SDVM_CHNLX_LNX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_sdvm_ns_ln#
 *
 * CPRI CONN4 IP CPRI TX SDVM Tunnel Subchannel Register
 */
union cavm_cprix_cn4ipx_ctx_sdvm_ns_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_sdvm_ns_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_17_31        : 15;
        uint32_t enable                : 1;  /**< [ 16: 16](R/W) Tunneling enable.
                                                                   0 = disabled.
                                                                   1 = enabled. */
        uint32_t reserved_10_15        : 6;
        uint32_t rate                  : 2;  /**< [  9:  8](R/W) Tunneling rate.
                                                                   0 = Quarter i.e. NS.
                                                                   1 = Half i.e. NS, NS+1.
                                                                   2 = Full i.e. NS, NS+1, NS+2, NS+3.
                                                                   3 = reserved.

                                                                 Note: Quarter rate is not supported at CPRI 10x line rate. */
        uint32_t reserved_6_7          : 2;
        uint32_t ns_s                  : 6;  /**< [  5:  0](R/W) Index of base CPRI subchannel within range 0 to 63. */
#else /* Word 0 - Little Endian */
        uint32_t ns_s                  : 6;  /**< [  5:  0](R/W) Index of base CPRI subchannel within range 0 to 63. */
        uint32_t reserved_6_7          : 2;
        uint32_t rate                  : 2;  /**< [  9:  8](R/W) Tunneling rate.
                                                                   0 = Quarter i.e. NS.
                                                                   1 = Half i.e. NS, NS+1.
                                                                   2 = Full i.e. NS, NS+1, NS+2, NS+3.
                                                                   3 = reserved.

                                                                 Note: Quarter rate is not supported at CPRI 10x line rate. */
        uint32_t reserved_10_15        : 6;
        uint32_t enable                : 1;  /**< [ 16: 16](R/W) Tunneling enable.
                                                                   0 = disabled.
                                                                   1 = enabled. */
        uint32_t reserved_17_31        : 15;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_sdvm_ns_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_sdvm_ns_lnx cavm_cprix_cn4ipx_ctx_sdvm_ns_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_SDVM_NS_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_SDVM_NS_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x86400082801cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_SDVM_NS_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_SDVM_NS_LNX(a,b,c) cavm_cprix_cn4ipx_ctx_sdvm_ns_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_SDVM_NS_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_SDVM_NS_LNX(a,b,c) "CPRIX_CN4IPX_CTX_SDVM_NS_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_SDVM_NS_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_SDVM_NS_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_seed_ln#
 *
 * CPRI CONN4 IP CPRI TX Scrambling Seed Register
 */
union cavm_cprix_cn4ipx_ctx_seed_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_seed_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_31           : 1;
        uint32_t ctx_seed              : 31; /**< [ 30:  0](R/W) Seed for Scrambler. */
#else /* Word 0 - Little Endian */
        uint32_t ctx_seed              : 31; /**< [ 30:  0](R/W) Seed for Scrambler. */
        uint32_t reserved_31           : 1;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_seed_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_seed_lnx cavm_cprix_cn4ipx_ctx_seed_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_SEED_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_SEED_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000828004ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_SEED_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_SEED_LNX(a,b,c) cavm_cprix_cn4ipx_ctx_seed_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_SEED_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_SEED_LNX(a,b,c) "CPRIX_CN4IPX_CTX_SEED_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_SEED_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_SEED_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_status_ln#
 *
 * CPRI CONN4 IP CPRI TX Status Register
 */
union cavm_cprix_cn4ipx_ctx_status_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_status_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t collision_bank        : 1;  /**< [ 23: 23](RO/H) CTX Bank transmitted at time of CTX collision.
                                                                   0 = no.
                                                                   1 = yes. */
        uint32_t collision_tunnel      : 1;  /**< [ 22: 22](RO/H) CTX Tunnel transmitted at time of CTX collision. */
        uint32_t collision_rtwp        : 1;  /**< [ 21: 21](RO/H) CTX RTWP transmitted at time of CTX collision. */
        uint32_t collision_sdvm        : 1;  /**< [ 20: 20](RO/H) CTX SDVM transmitted at time of CTX collision. */
        uint32_t collision_vsb         : 1;  /**< [ 19: 19](RO/H) CTX VSB transmitted at time of CTX collision. */
        uint32_t collision_hdlc        : 1;  /**< [ 18: 18](RO/H) CTX HDLC transmitted at time of CTX collision. */
        uint32_t collision_eth         : 1;  /**< [ 17: 17](RO/H) CTX Ethernet transmitted at time of CTX collision. */
        uint32_t collision_l1          : 1;  /**< [ 16: 16](RO/H) CTX L1 transmitted at time of CTX collision. */
        uint32_t reserved_15           : 1;
        uint32_t axc_overlap_y         : 3;  /**< [ 14: 12](RO/H) Frame coordinate Y before overlap instant. Please see usage description chapter for offset values. */
        uint32_t axc_overlap_w         : 4;  /**< [ 11:  8](RO/H) Frame coordinate W before overlap instant. Please see usage description chapter for offset values. */
        uint32_t vsbd_capture          : 1;  /**< [  7:  7](RO/H) Status of request from VSB buffer D at overlap instant. */
        uint32_t vsbc_capture          : 1;  /**< [  6:  6](RO/H) Status of request from VSB buffer C at overlap instant. */
        uint32_t vsbb_capture          : 1;  /**< [  5:  5](RO/H) Status of request from VSB buffer B at overlap instant. */
        uint32_t vsba_capture          : 1;  /**< [  4:  4](RO/H) Status of request from VSB buffer A at overlap instant. */
        uint32_t reserved_3            : 1;
        uint32_t axc_collision         : 1;  /**< [  2:  2](RO/H) Collision status of AxC.
                                                                   0 = no collision detected.
                                                                   1 = collision has been detected. */
        uint32_t axc_overlap           : 1;  /**< [  1:  1](RO/H) Overlap status of AxC.
                                                                   0 = no overlap detected.
                                                                   1 = overlap has been detected. */
        uint32_t vsbx_overlap          : 1;  /**< [  0:  0](RO/H) Overlap of VSB buffer A, B, C or D.
                                                                   0 = no overlap detected.
                                                                   1 = overlap has been detected. */
#else /* Word 0 - Little Endian */
        uint32_t vsbx_overlap          : 1;  /**< [  0:  0](RO/H) Overlap of VSB buffer A, B, C or D.
                                                                   0 = no overlap detected.
                                                                   1 = overlap has been detected. */
        uint32_t axc_overlap           : 1;  /**< [  1:  1](RO/H) Overlap status of AxC.
                                                                   0 = no overlap detected.
                                                                   1 = overlap has been detected. */
        uint32_t axc_collision         : 1;  /**< [  2:  2](RO/H) Collision status of AxC.
                                                                   0 = no collision detected.
                                                                   1 = collision has been detected. */
        uint32_t reserved_3            : 1;
        uint32_t vsba_capture          : 1;  /**< [  4:  4](RO/H) Status of request from VSB buffer A at overlap instant. */
        uint32_t vsbb_capture          : 1;  /**< [  5:  5](RO/H) Status of request from VSB buffer B at overlap instant. */
        uint32_t vsbc_capture          : 1;  /**< [  6:  6](RO/H) Status of request from VSB buffer C at overlap instant. */
        uint32_t vsbd_capture          : 1;  /**< [  7:  7](RO/H) Status of request from VSB buffer D at overlap instant. */
        uint32_t axc_overlap_w         : 4;  /**< [ 11:  8](RO/H) Frame coordinate W before overlap instant. Please see usage description chapter for offset values. */
        uint32_t axc_overlap_y         : 3;  /**< [ 14: 12](RO/H) Frame coordinate Y before overlap instant. Please see usage description chapter for offset values. */
        uint32_t reserved_15           : 1;
        uint32_t collision_l1          : 1;  /**< [ 16: 16](RO/H) CTX L1 transmitted at time of CTX collision. */
        uint32_t collision_eth         : 1;  /**< [ 17: 17](RO/H) CTX Ethernet transmitted at time of CTX collision. */
        uint32_t collision_hdlc        : 1;  /**< [ 18: 18](RO/H) CTX HDLC transmitted at time of CTX collision. */
        uint32_t collision_vsb         : 1;  /**< [ 19: 19](RO/H) CTX VSB transmitted at time of CTX collision. */
        uint32_t collision_sdvm        : 1;  /**< [ 20: 20](RO/H) CTX SDVM transmitted at time of CTX collision. */
        uint32_t collision_rtwp        : 1;  /**< [ 21: 21](RO/H) CTX RTWP transmitted at time of CTX collision. */
        uint32_t collision_tunnel      : 1;  /**< [ 22: 22](RO/H) CTX Tunnel transmitted at time of CTX collision. */
        uint32_t collision_bank        : 1;  /**< [ 23: 23](RO/H) CTX Bank transmitted at time of CTX collision.
                                                                   0 = no.
                                                                   1 = yes. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_status_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_status_lnx cavm_cprix_cn4ipx_ctx_status_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_STATUS_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_STATUS_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x8640008281e0ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_STATUS_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_STATUS_LNX(a,b,c) cavm_cprix_cn4ipx_ctx_status_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_STATUS_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_STATUS_LNX(a,b,c) "CPRIX_CN4IPX_CTX_STATUS_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_STATUS_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_STATUS_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_trace_ln#
 *
 * CPRI CONN4 IP CPRI TX Trace Control Register
 */
union cavm_cprix_cn4ipx_ctx_trace_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_trace_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t select                : 1;  /**< [  1:  1](R/W) Select whether trace data is before or after descrambling.
                                                                   0 = After scrambling.
                                                                   1 = Before scrambling. */
        uint32_t enable                : 1;  /**< [  0:  0](R/W) Enable transport of trace data to RP3 UL interface.
                                                                   0 = disable.
                                                                   1 = enable.

                                                                 Please note: only one test port source can be enabled at a time. */
#else /* Word 0 - Little Endian */
        uint32_t enable                : 1;  /**< [  0:  0](R/W) Enable transport of trace data to RP3 UL interface.
                                                                   0 = disable.
                                                                   1 = enable.

                                                                 Please note: only one test port source can be enabled at a time. */
        uint32_t select                : 1;  /**< [  1:  1](R/W) Select whether trace data is before or after descrambling.
                                                                   0 = After scrambling.
                                                                   1 = Before scrambling. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_trace_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_trace_lnx cavm_cprix_cn4ipx_ctx_trace_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_TRACE_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_TRACE_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000828038ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_TRACE_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_TRACE_LNX(a,b,c) cavm_cprix_cn4ipx_ctx_trace_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_TRACE_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_TRACE_LNX(a,b,c) "CPRIX_CN4IPX_CTX_TRACE_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_TRACE_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_TRACE_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_tunn#_cfg_ln#
 *
 * CPRI CONN4 IP CPRI TX Tunnel Channel Configuration Register
 */
union cavm_cprix_cn4ipx_ctx_tunnx_cfg_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_tunnx_cfg_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_17_31        : 15;
        uint32_t enable                : 1;  /**< [ 16: 16](R/W) Enable for this channel.
                                                                   0 = disable.
                                                                   1 = enable. */
        uint32_t reserved_8_15         : 8;
        uint32_t stream_id             : 8;  /**< [  7:  0](R/W) Stream ID of this channel. Stream Buffer should be configured to FIFO mode. */
#else /* Word 0 - Little Endian */
        uint32_t stream_id             : 8;  /**< [  7:  0](R/W) Stream ID of this channel. Stream Buffer should be configured to FIFO mode. */
        uint32_t reserved_8_15         : 8;
        uint32_t enable                : 1;  /**< [ 16: 16](R/W) Enable for this channel.
                                                                   0 = disable.
                                                                   1 = enable. */
        uint32_t reserved_17_31        : 15;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_tunnx_cfg_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_tunnx_cfg_lnx cavm_cprix_cn4ipx_ctx_tunnx_cfg_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_TUNNX_CFG_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_TUNNX_CFG_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=15) && (d<=1)))
        return 0x864000828180ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 4ll * ((c) & 0xf) + 0x10000ll * ((d) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_TUNNX_CFG_LNX", 4, a, b, c, d, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_TUNNX_CFG_LNX(a,b,c,d) cavm_cprix_cn4ipx_ctx_tunnx_cfg_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_TUNNX_CFG_LNX(a,b,c,d) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_TUNNX_CFG_LNX(a,b,c,d) "CPRIX_CN4IPX_CTX_TUNNX_CFG_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_TUNNX_CFG_LNX(a,b,c,d) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_TUNNX_CFG_LNX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_tunn_sts0_ln#
 *
 * CPRI CONN4 IP CPRI TX Tunnel Status 0 Register
 */
union cavm_cprix_cn4ipx_ctx_tunn_sts0_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_tunn_sts0_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_17_31        : 15;
        uint32_t frame_y               : 1;  /**< [ 16: 16](RO/H) Most significant bit of Frame Y coordinate at time of collision. */
        uint32_t frame_x               : 8;  /**< [ 15:  8](RO/H) Frame X coordinate at time of collision. */
        uint32_t frame_z               : 8;  /**< [  7:  0](RO/H) Frame Z coordinate at time of collision. */
#else /* Word 0 - Little Endian */
        uint32_t frame_z               : 8;  /**< [  7:  0](RO/H) Frame Z coordinate at time of collision. */
        uint32_t frame_x               : 8;  /**< [ 15:  8](RO/H) Frame X coordinate at time of collision. */
        uint32_t frame_y               : 1;  /**< [ 16: 16](RO/H) Most significant bit of Frame Y coordinate at time of collision. */
        uint32_t reserved_17_31        : 15;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_tunn_sts0_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_tunn_sts0_lnx cavm_cprix_cn4ipx_ctx_tunn_sts0_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_TUNN_STS0_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_TUNN_STS0_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x8640008281e8ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_TUNN_STS0_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_TUNN_STS0_LNX(a,b,c) cavm_cprix_cn4ipx_ctx_tunn_sts0_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_TUNN_STS0_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_TUNN_STS0_LNX(a,b,c) "CPRIX_CN4IPX_CTX_TUNN_STS0_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_TUNN_STS0_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_TUNN_STS0_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_tunn_sts1_ln#
 *
 * CPRI CONN4 IP CPRI TX Tunnel Status 1 Register
 */
union cavm_cprix_cn4ipx_ctx_tunn_sts1_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_tunn_sts1_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t byte_15_high          : 1;  /**< [ 31: 31](RO/H) Channel 15, high byte. */
        uint32_t byte_15_low           : 1;  /**< [ 30: 30](RO/H) Channel 15, low byte. */
        uint32_t byte_14_high          : 1;  /**< [ 29: 29](RO/H) Channel 14, high byte. */
        uint32_t byte_14_low           : 1;  /**< [ 28: 28](RO/H) Channel 14, low byte. */
        uint32_t byte_13_high          : 1;  /**< [ 27: 27](RO/H) Channel 13, high byte. */
        uint32_t byte_13_low           : 1;  /**< [ 26: 26](RO/H) Channel 13, low byte. */
        uint32_t byte_12_high          : 1;  /**< [ 25: 25](RO/H) Channel 12, high byte. */
        uint32_t byte_12_low           : 1;  /**< [ 24: 24](RO/H) Channel 12, low byte. */
        uint32_t byte_11_high          : 1;  /**< [ 23: 23](RO/H) Channel 11, high byte. */
        uint32_t byte_11_low           : 1;  /**< [ 22: 22](RO/H) Channel 11, low byte. */
        uint32_t byte_10_high          : 1;  /**< [ 21: 21](RO/H) Channel 10, high byte. */
        uint32_t byte_10_low           : 1;  /**< [ 20: 20](RO/H) Channel 10, low byte. */
        uint32_t byte_9_high           : 1;  /**< [ 19: 19](RO/H) Channel 9, high byte. */
        uint32_t byte_9_low            : 1;  /**< [ 18: 18](RO/H) Channel 9, low byte. */
        uint32_t byte_8_high           : 1;  /**< [ 17: 17](RO/H) Channel 8, high byte. */
        uint32_t byte_8_low            : 1;  /**< [ 16: 16](RO/H) Channel 8, low byte. */
        uint32_t byte_7_high           : 1;  /**< [ 15: 15](RO/H) Channel 7, high byte. */
        uint32_t byte_7_low            : 1;  /**< [ 14: 14](RO/H) Channel 7, low byte. */
        uint32_t byte_6_high           : 1;  /**< [ 13: 13](RO/H) Channel 6, high byte. */
        uint32_t byte_6_low            : 1;  /**< [ 12: 12](RO/H) Channel 6, low byte. */
        uint32_t byte_5_high           : 1;  /**< [ 11: 11](RO/H) Channel 5, high byte. */
        uint32_t byte_5_low            : 1;  /**< [ 10: 10](RO/H) Channel 5, low byte. */
        uint32_t byte_4_high           : 1;  /**< [  9:  9](RO/H) Channel 4, high byte. */
        uint32_t byte_4_low            : 1;  /**< [  8:  8](RO/H) Channel 4, low byte. */
        uint32_t byte_3_high           : 1;  /**< [  7:  7](RO/H) Channel 3, high byte. */
        uint32_t byte_3_low            : 1;  /**< [  6:  6](RO/H) Channel 3, low byte. */
        uint32_t byte_2_high           : 1;  /**< [  5:  5](RO/H) Channel 2, high byte. */
        uint32_t byte_2_low            : 1;  /**< [  4:  4](RO/H) Channel 2, low byte. */
        uint32_t byte_1_high           : 1;  /**< [  3:  3](RO/H) Channel 1 transmitted high byte at time of collision. */
        uint32_t byte_1_low            : 1;  /**< [  2:  2](RO/H) Channel 1 transmitted low byte at time of collision. */
        uint32_t byte_0_high           : 1;  /**< [  1:  1](RO/H) Channel 0 transmitted high byte at time of collision. */
        uint32_t byte_0_low            : 1;  /**< [  0:  0](RO/H) Channel 0 transmitted low byte at time of collision.
                                                                   0 = not transmitted.
                                                                   1 = transmitted. */
#else /* Word 0 - Little Endian */
        uint32_t byte_0_low            : 1;  /**< [  0:  0](RO/H) Channel 0 transmitted low byte at time of collision.
                                                                   0 = not transmitted.
                                                                   1 = transmitted. */
        uint32_t byte_0_high           : 1;  /**< [  1:  1](RO/H) Channel 0 transmitted high byte at time of collision. */
        uint32_t byte_1_low            : 1;  /**< [  2:  2](RO/H) Channel 1 transmitted low byte at time of collision. */
        uint32_t byte_1_high           : 1;  /**< [  3:  3](RO/H) Channel 1 transmitted high byte at time of collision. */
        uint32_t byte_2_low            : 1;  /**< [  4:  4](RO/H) Channel 2, low byte. */
        uint32_t byte_2_high           : 1;  /**< [  5:  5](RO/H) Channel 2, high byte. */
        uint32_t byte_3_low            : 1;  /**< [  6:  6](RO/H) Channel 3, low byte. */
        uint32_t byte_3_high           : 1;  /**< [  7:  7](RO/H) Channel 3, high byte. */
        uint32_t byte_4_low            : 1;  /**< [  8:  8](RO/H) Channel 4, low byte. */
        uint32_t byte_4_high           : 1;  /**< [  9:  9](RO/H) Channel 4, high byte. */
        uint32_t byte_5_low            : 1;  /**< [ 10: 10](RO/H) Channel 5, low byte. */
        uint32_t byte_5_high           : 1;  /**< [ 11: 11](RO/H) Channel 5, high byte. */
        uint32_t byte_6_low            : 1;  /**< [ 12: 12](RO/H) Channel 6, low byte. */
        uint32_t byte_6_high           : 1;  /**< [ 13: 13](RO/H) Channel 6, high byte. */
        uint32_t byte_7_low            : 1;  /**< [ 14: 14](RO/H) Channel 7, low byte. */
        uint32_t byte_7_high           : 1;  /**< [ 15: 15](RO/H) Channel 7, high byte. */
        uint32_t byte_8_low            : 1;  /**< [ 16: 16](RO/H) Channel 8, low byte. */
        uint32_t byte_8_high           : 1;  /**< [ 17: 17](RO/H) Channel 8, high byte. */
        uint32_t byte_9_low            : 1;  /**< [ 18: 18](RO/H) Channel 9, low byte. */
        uint32_t byte_9_high           : 1;  /**< [ 19: 19](RO/H) Channel 9, high byte. */
        uint32_t byte_10_low           : 1;  /**< [ 20: 20](RO/H) Channel 10, low byte. */
        uint32_t byte_10_high          : 1;  /**< [ 21: 21](RO/H) Channel 10, high byte. */
        uint32_t byte_11_low           : 1;  /**< [ 22: 22](RO/H) Channel 11, low byte. */
        uint32_t byte_11_high          : 1;  /**< [ 23: 23](RO/H) Channel 11, high byte. */
        uint32_t byte_12_low           : 1;  /**< [ 24: 24](RO/H) Channel 12, low byte. */
        uint32_t byte_12_high          : 1;  /**< [ 25: 25](RO/H) Channel 12, high byte. */
        uint32_t byte_13_low           : 1;  /**< [ 26: 26](RO/H) Channel 13, low byte. */
        uint32_t byte_13_high          : 1;  /**< [ 27: 27](RO/H) Channel 13, high byte. */
        uint32_t byte_14_low           : 1;  /**< [ 28: 28](RO/H) Channel 14, low byte. */
        uint32_t byte_14_high          : 1;  /**< [ 29: 29](RO/H) Channel 14, high byte. */
        uint32_t byte_15_low           : 1;  /**< [ 30: 30](RO/H) Channel 15, low byte. */
        uint32_t byte_15_high          : 1;  /**< [ 31: 31](RO/H) Channel 15, high byte. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_tunn_sts1_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_tunn_sts1_lnx cavm_cprix_cn4ipx_ctx_tunn_sts1_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_TUNN_STS1_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_TUNN_STS1_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x8640008281ecll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_TUNN_STS1_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_TUNN_STS1_LNX(a,b,c) cavm_cprix_cn4ipx_ctx_tunn_sts1_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_TUNN_STS1_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_TUNN_STS1_LNX(a,b,c) "CPRIX_CN4IPX_CTX_TUNN_STS1_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_TUNN_STS1_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_TUNN_STS1_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_ulaw_gen_ln#
 *
 * CPRI CONN4 IP CPRI TX uLaw General Configuration Register
 */
union cavm_cprix_cn4ipx_ctx_ulaw_gen_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_ulaw_gen_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t page                  : 4;  /**< [  7:  4](R/W) RAM page selection. Selects the page of Law lookup RAM that is accessible via CTX_ULAW_DATA.
                                                                   0x0 = RAM locations 0 to 511.
                                                                   0x1 = RAM locations 512 to 1023.
                                                                   0x2 = RAM locations 1024 to 1535.
                                                                   0x3 = RAM locations 1536 to 2047.
                                                                   0x4 = RAM locations 2048 to 2559.
                                                                   0x5 = RAM locations 2560 to 3071.
                                                                   0x6 = RAM locations 3072 to 3583.
                                                                   0x7 = RAM locations 3584 to 4095.
                                                                   0x8 = RAM locations 4096 to 4607.
                                                                   0x9 = RAM locations 4608 to 5119.
                                                                   0xA to 0xF = not used.
                                                                 CTX Law lookup table can only be read by software when compression is disabled
                                                                 by CTX_ULAW_GEN: COMPRESS. */
        uint32_t reserved_3            : 1;
        uint32_t alignment             : 1;  /**< [  2:  2](R/W) Alignment of IQ samples when converting from RP3 to CPRI. The following is true
                                                                 for a sample after a conversion from RP3:
                                                                   0 = LSb discarded (as in Murkku2).
                                                                   1 = MSb discarded. */
        uint32_t dual                  : 1;  /**< [  1:  1](RO/H) Enable use of primary and secondary Stream Router interface. Constantly enabled. */
        uint32_t compress              : 1;  /**< [  0:  0](R/W) Enable status of IQ compressor. Compressor should be enabled when any AxC has
                                                                 compression enabled. When high, compressed samples are available for each
                                                                 antenna carrier. Each antenna carrier still has individual control for selecting
                                                                 uncompressed or compressed samples.
                                                                   0 = disabled.
                                                                   1 = enabled.
                                                                 CTX Law lookup table can only be read by software when compression is disabled. */
#else /* Word 0 - Little Endian */
        uint32_t compress              : 1;  /**< [  0:  0](R/W) Enable status of IQ compressor. Compressor should be enabled when any AxC has
                                                                 compression enabled. When high, compressed samples are available for each
                                                                 antenna carrier. Each antenna carrier still has individual control for selecting
                                                                 uncompressed or compressed samples.
                                                                   0 = disabled.
                                                                   1 = enabled.
                                                                 CTX Law lookup table can only be read by software when compression is disabled. */
        uint32_t dual                  : 1;  /**< [  1:  1](RO/H) Enable use of primary and secondary Stream Router interface. Constantly enabled. */
        uint32_t alignment             : 1;  /**< [  2:  2](R/W) Alignment of IQ samples when converting from RP3 to CPRI. The following is true
                                                                 for a sample after a conversion from RP3:
                                                                   0 = LSb discarded (as in Murkku2).
                                                                   1 = MSb discarded. */
        uint32_t reserved_3            : 1;
        uint32_t page                  : 4;  /**< [  7:  4](R/W) RAM page selection. Selects the page of Law lookup RAM that is accessible via CTX_ULAW_DATA.
                                                                   0x0 = RAM locations 0 to 511.
                                                                   0x1 = RAM locations 512 to 1023.
                                                                   0x2 = RAM locations 1024 to 1535.
                                                                   0x3 = RAM locations 1536 to 2047.
                                                                   0x4 = RAM locations 2048 to 2559.
                                                                   0x5 = RAM locations 2560 to 3071.
                                                                   0x6 = RAM locations 3072 to 3583.
                                                                   0x7 = RAM locations 3584 to 4095.
                                                                   0x8 = RAM locations 4096 to 4607.
                                                                   0x9 = RAM locations 4608 to 5119.
                                                                   0xA to 0xF = not used.
                                                                 CTX Law lookup table can only be read by software when compression is disabled
                                                                 by CTX_ULAW_GEN: COMPRESS. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_ulaw_gen_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_ulaw_gen_lnx cavm_cprix_cn4ipx_ctx_ulaw_gen_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_ULAW_GEN_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_ULAW_GEN_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000828020ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_ULAW_GEN_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_ULAW_GEN_LNX(a,b,c) cavm_cprix_cn4ipx_ctx_ulaw_gen_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_ULAW_GEN_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_ULAW_GEN_LNX(a,b,c) "CPRIX_CN4IPX_CTX_ULAW_GEN_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_ULAW_GEN_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_ULAW_GEN_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_ulaw_ram#_ln#
 *
 * CPRI CONN4 IP CPRI TX uLAW Lookup Ram Access Data Register
 */
union cavm_cprix_cn4ipx_ctx_ulaw_ramx_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_ulaw_ramx_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_11_31        : 21;
        uint32_t data                  : 11; /**< [ 10:  0](R/W) Lookup RAM data word. Write and read accesses to this address are performed on
                                                                 the lookup RAM to the page of RAM set in register field CTX_ULAW_GEN:PAGE.
                                                                 CTX Law lookup table can only be read by software when compression is disabled
                                                                 by CTX_ULAW_GEN:COMPRESS. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 11; /**< [ 10:  0](R/W) Lookup RAM data word. Write and read accesses to this address are performed on
                                                                 the lookup RAM to the page of RAM set in register field CTX_ULAW_GEN:PAGE.
                                                                 CTX Law lookup table can only be read by software when compression is disabled
                                                                 by CTX_ULAW_GEN:COMPRESS. */
        uint32_t reserved_11_31        : 21;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_ulaw_ramx_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_ulaw_ramx_lnx cavm_cprix_cn4ipx_ctx_ulaw_ramx_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_ULAW_RAMX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_ULAW_RAMX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=511) && (d<=1)))
        return 0x86400082c000ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 4ll * ((c) & 0x1ff) + 0x10000ll * ((d) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_ULAW_RAMX_LNX", 4, a, b, c, d, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_ULAW_RAMX_LNX(a,b,c,d) cavm_cprix_cn4ipx_ctx_ulaw_ramx_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_ULAW_RAMX_LNX(a,b,c,d) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_ULAW_RAMX_LNX(a,b,c,d) "CPRIX_CN4IPX_CTX_ULAW_RAMX_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_ULAW_RAMX_LNX(a,b,c,d) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_ULAW_RAMX_LNX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) cpri#_cn4ip#_ctx_wdga_ln#
 *
 * CPRI CONN4 IP CPRI TX Watchdog Alarm Configuration Register
 */
union cavm_cprix_cn4ipx_ctx_wdga_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctx_wdga_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t enable                : 1;  /**< [ 31: 31](R/W) Enable transmission of WDGA alarm bit. */
        uint32_t reserved_16_30        : 15;
        uint32_t x                     : 8;  /**< [ 15:  8](R/W) CPRI basic frame number X where WDGA alarm bit is transmitted.
                                                                   0..0xFF = valid.
                                                                 Alarm bit should never be sent in reserved subchannels such as 0 and 2. */
        uint32_t reserved_7            : 1;
        uint32_t y2                    : 3;  /**< [  6:  4](R/W) Index of 16-bit word within CPRI word where WDGA alarm bit is transmitted.
                                                                   0..7 = valid. */
        uint32_t b_s                   : 4;  /**< [  3:  0](R/W) Index of a bit within a 16-bit word where WDGA alarm bit is transmitted.
                                                                   0..0xF = valid. */
#else /* Word 0 - Little Endian */
        uint32_t b_s                   : 4;  /**< [  3:  0](R/W) Index of a bit within a 16-bit word where WDGA alarm bit is transmitted.
                                                                   0..0xF = valid. */
        uint32_t y2                    : 3;  /**< [  6:  4](R/W) Index of 16-bit word within CPRI word where WDGA alarm bit is transmitted.
                                                                   0..7 = valid. */
        uint32_t reserved_7            : 1;
        uint32_t x                     : 8;  /**< [ 15:  8](R/W) CPRI basic frame number X where WDGA alarm bit is transmitted.
                                                                   0..0xFF = valid.
                                                                 Alarm bit should never be sent in reserved subchannels such as 0 and 2. */
        uint32_t reserved_16_30        : 15;
        uint32_t enable                : 1;  /**< [ 31: 31](R/W) Enable transmission of WDGA alarm bit. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctx_wdga_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctx_wdga_lnx cavm_cprix_cn4ipx_ctx_wdga_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_WDGA_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTX_WDGA_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000828284ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTX_WDGA_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTX_WDGA_LNX(a,b,c) cavm_cprix_cn4ipx_ctx_wdga_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTX_WDGA_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTX_WDGA_LNX(a,b,c) "CPRIX_CN4IPX_CTX_WDGA_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTX_WDGA_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTX_WDGA_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_ctxb_int_clr_ln#
 *
 * CPRI CONN4 IP CPRI TX Register Bank Interrupt Event Clear Register
 */
union cavm_cprix_cn4ipx_ctxb_int_clr_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctxb_int_clr_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t bank_sent_15          : 1;  /**< [ 15: 15](R/W1C/H) Clear for Interrupt BANK_SENT_15:
                                                                   0 = No effect.
                                                                   1 = Interrupt clear. */
        uint32_t bank_sent_14          : 1;  /**< [ 14: 14](R/W1C/H) Clear for Interrupt BANK_SENT_14. */
        uint32_t bank_sent_13          : 1;  /**< [ 13: 13](R/W1C/H) Clear for Interrupt BANK_SENT_13. */
        uint32_t bank_sent_12          : 1;  /**< [ 12: 12](R/W1C/H) Clear for Interrupt BANK_SENT_12. */
        uint32_t bank_sent_11          : 1;  /**< [ 11: 11](R/W1C/H) Clear for Interrupt BANK_SENT_11. */
        uint32_t bank_sent_10          : 1;  /**< [ 10: 10](R/W1C/H) Clear for Interrupt BANK_SENT_10. */
        uint32_t bank_sent_9           : 1;  /**< [  9:  9](R/W1C/H) Clear for Interrupt BANK_SENT_9. */
        uint32_t bank_sent_8           : 1;  /**< [  8:  8](R/W1C/H) Clear for Interrupt BANK_SENT_8. */
        uint32_t bank_sent_7           : 1;  /**< [  7:  7](R/W1C/H) Clear for Interrupt BANK_SENT_7. */
        uint32_t bank_sent_6           : 1;  /**< [  6:  6](R/W1C/H) Clear for Interrupt BANK_SENT_6. */
        uint32_t bank_sent_5           : 1;  /**< [  5:  5](R/W1C/H) Clear for Interrupt BANK_SENT_5. */
        uint32_t bank_sent_4           : 1;  /**< [  4:  4](R/W1C/H) Clear for Interrupt BANK_SENT_4. */
        uint32_t bank_sent_3           : 1;  /**< [  3:  3](R/W1C/H) Clear for Interrupt BANK_SENT_3. */
        uint32_t bank_sent_2           : 1;  /**< [  2:  2](R/W1C/H) Clear for Interrupt BANK_SENT_2. */
        uint32_t bank_sent_1           : 1;  /**< [  1:  1](R/W1C/H) Clear for Interrupt BANK_SENT_1. */
        uint32_t bank_sent_0           : 1;  /**< [  0:  0](R/W1C/H) Clear for Interrupt BANK_SENT_0. */
#else /* Word 0 - Little Endian */
        uint32_t bank_sent_0           : 1;  /**< [  0:  0](R/W1C/H) Clear for Interrupt BANK_SENT_0. */
        uint32_t bank_sent_1           : 1;  /**< [  1:  1](R/W1C/H) Clear for Interrupt BANK_SENT_1. */
        uint32_t bank_sent_2           : 1;  /**< [  2:  2](R/W1C/H) Clear for Interrupt BANK_SENT_2. */
        uint32_t bank_sent_3           : 1;  /**< [  3:  3](R/W1C/H) Clear for Interrupt BANK_SENT_3. */
        uint32_t bank_sent_4           : 1;  /**< [  4:  4](R/W1C/H) Clear for Interrupt BANK_SENT_4. */
        uint32_t bank_sent_5           : 1;  /**< [  5:  5](R/W1C/H) Clear for Interrupt BANK_SENT_5. */
        uint32_t bank_sent_6           : 1;  /**< [  6:  6](R/W1C/H) Clear for Interrupt BANK_SENT_6. */
        uint32_t bank_sent_7           : 1;  /**< [  7:  7](R/W1C/H) Clear for Interrupt BANK_SENT_7. */
        uint32_t bank_sent_8           : 1;  /**< [  8:  8](R/W1C/H) Clear for Interrupt BANK_SENT_8. */
        uint32_t bank_sent_9           : 1;  /**< [  9:  9](R/W1C/H) Clear for Interrupt BANK_SENT_9. */
        uint32_t bank_sent_10          : 1;  /**< [ 10: 10](R/W1C/H) Clear for Interrupt BANK_SENT_10. */
        uint32_t bank_sent_11          : 1;  /**< [ 11: 11](R/W1C/H) Clear for Interrupt BANK_SENT_11. */
        uint32_t bank_sent_12          : 1;  /**< [ 12: 12](R/W1C/H) Clear for Interrupt BANK_SENT_12. */
        uint32_t bank_sent_13          : 1;  /**< [ 13: 13](R/W1C/H) Clear for Interrupt BANK_SENT_13. */
        uint32_t bank_sent_14          : 1;  /**< [ 14: 14](R/W1C/H) Clear for Interrupt BANK_SENT_14. */
        uint32_t bank_sent_15          : 1;  /**< [ 15: 15](R/W1C/H) Clear for Interrupt BANK_SENT_15:
                                                                   0 = No effect.
                                                                   1 = Interrupt clear. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctxb_int_clr_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctxb_int_clr_lnx cavm_cprix_cn4ipx_ctxb_int_clr_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTXB_INT_CLR_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTXB_INT_CLR_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x8640008282e4ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTXB_INT_CLR_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTXB_INT_CLR_LNX(a,b,c) cavm_cprix_cn4ipx_ctxb_int_clr_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTXB_INT_CLR_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTXB_INT_CLR_LNX(a,b,c) "CPRIX_CN4IPX_CTXB_INT_CLR_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTXB_INT_CLR_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTXB_INT_CLR_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_ctxb_int_msk_ln#
 *
 * CPRI CONN4 IP CPRI TX Register Bank Interrupt Mask Register
 */
union cavm_cprix_cn4ipx_ctxb_int_msk_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctxb_int_msk_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t bank_sent_15          : 1;  /**< [ 15: 15](R/W) Mask for Interrupt BANK_SENT_15:
                                                                   0 = Not masked.
                                                                   1 = Masked. */
        uint32_t bank_sent_14          : 1;  /**< [ 14: 14](R/W) Mask for Interrupt BANK_SENT_14. */
        uint32_t bank_sent_13          : 1;  /**< [ 13: 13](R/W) Mask for Interrupt BANK_SENT_13. */
        uint32_t bank_sent_12          : 1;  /**< [ 12: 12](R/W) Mask for Interrupt BANK_SENT_12. */
        uint32_t bank_sent_11          : 1;  /**< [ 11: 11](R/W) Mask for Interrupt BANK_SENT_11. */
        uint32_t bank_sent_10          : 1;  /**< [ 10: 10](R/W) Mask for Interrupt BANK_SENT_10. */
        uint32_t bank_sent_9           : 1;  /**< [  9:  9](R/W) Mask for Interrupt BANK_SENT_9. */
        uint32_t bank_sent_8           : 1;  /**< [  8:  8](R/W) Mask for Interrupt BANK_SENT_8. */
        uint32_t bank_sent_7           : 1;  /**< [  7:  7](R/W) Mask for Interrupt BANK_SENT_7. */
        uint32_t bank_sent_6           : 1;  /**< [  6:  6](R/W) Mask for Interrupt BANK_SENT_6. */
        uint32_t bank_sent_5           : 1;  /**< [  5:  5](R/W) Mask for Interrupt BANK_SENT_5. */
        uint32_t bank_sent_4           : 1;  /**< [  4:  4](R/W) Mask for Interrupt BANK_SENT_4. */
        uint32_t bank_sent_3           : 1;  /**< [  3:  3](R/W) Mask for Interrupt BANK_SENT_3. */
        uint32_t bank_sent_2           : 1;  /**< [  2:  2](R/W) Mask for Interrupt BANK_SENT_2. */
        uint32_t bank_sent_1           : 1;  /**< [  1:  1](R/W) Mask for Interrupt BANK_SENT_1. */
        uint32_t bank_sent_0           : 1;  /**< [  0:  0](R/W) Mask for Interrupt BANK_SENT_0. */
#else /* Word 0 - Little Endian */
        uint32_t bank_sent_0           : 1;  /**< [  0:  0](R/W) Mask for Interrupt BANK_SENT_0. */
        uint32_t bank_sent_1           : 1;  /**< [  1:  1](R/W) Mask for Interrupt BANK_SENT_1. */
        uint32_t bank_sent_2           : 1;  /**< [  2:  2](R/W) Mask for Interrupt BANK_SENT_2. */
        uint32_t bank_sent_3           : 1;  /**< [  3:  3](R/W) Mask for Interrupt BANK_SENT_3. */
        uint32_t bank_sent_4           : 1;  /**< [  4:  4](R/W) Mask for Interrupt BANK_SENT_4. */
        uint32_t bank_sent_5           : 1;  /**< [  5:  5](R/W) Mask for Interrupt BANK_SENT_5. */
        uint32_t bank_sent_6           : 1;  /**< [  6:  6](R/W) Mask for Interrupt BANK_SENT_6. */
        uint32_t bank_sent_7           : 1;  /**< [  7:  7](R/W) Mask for Interrupt BANK_SENT_7. */
        uint32_t bank_sent_8           : 1;  /**< [  8:  8](R/W) Mask for Interrupt BANK_SENT_8. */
        uint32_t bank_sent_9           : 1;  /**< [  9:  9](R/W) Mask for Interrupt BANK_SENT_9. */
        uint32_t bank_sent_10          : 1;  /**< [ 10: 10](R/W) Mask for Interrupt BANK_SENT_10. */
        uint32_t bank_sent_11          : 1;  /**< [ 11: 11](R/W) Mask for Interrupt BANK_SENT_11. */
        uint32_t bank_sent_12          : 1;  /**< [ 12: 12](R/W) Mask for Interrupt BANK_SENT_12. */
        uint32_t bank_sent_13          : 1;  /**< [ 13: 13](R/W) Mask for Interrupt BANK_SENT_13. */
        uint32_t bank_sent_14          : 1;  /**< [ 14: 14](R/W) Mask for Interrupt BANK_SENT_14. */
        uint32_t bank_sent_15          : 1;  /**< [ 15: 15](R/W) Mask for Interrupt BANK_SENT_15:
                                                                   0 = Not masked.
                                                                   1 = Masked. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctxb_int_msk_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctxb_int_msk_lnx cavm_cprix_cn4ipx_ctxb_int_msk_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTXB_INT_MSK_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTXB_INT_MSK_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x8640008282f0ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTXB_INT_MSK_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTXB_INT_MSK_LNX(a,b,c) cavm_cprix_cn4ipx_ctxb_int_msk_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTXB_INT_MSK_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTXB_INT_MSK_LNX(a,b,c) "CPRIX_CN4IPX_CTXB_INT_MSK_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTXB_INT_MSK_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTXB_INT_MSK_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_ctxb_int_mskcl_ln#
 *
 * CPRI CONN4 IP CPRI TX Register Bank Interrupt Mask Clear Register
 */
union cavm_cprix_cn4ipx_ctxb_int_mskcl_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctxb_int_mskcl_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t bank_sent_15          : 1;  /**< [ 15: 15](R/W1C/H) Mask clear for Interrupt BANK_SENT_15:
                                                                   0 = No effect.
                                                                   1 = Mask clear. */
        uint32_t bank_sent_14          : 1;  /**< [ 14: 14](R/W1C/H) Mask clear for Interrupt BANK_SENT_14. */
        uint32_t bank_sent_13          : 1;  /**< [ 13: 13](R/W1C/H) Mask clear for Interrupt BANK_SENT_13. */
        uint32_t bank_sent_12          : 1;  /**< [ 12: 12](R/W1C/H) Mask clear for Interrupt BANK_SENT_12. */
        uint32_t bank_sent_11          : 1;  /**< [ 11: 11](R/W1C/H) Mask clear for Interrupt BANK_SENT_11. */
        uint32_t bank_sent_10          : 1;  /**< [ 10: 10](R/W1C/H) Mask clear for Interrupt BANK_SENT_10. */
        uint32_t bank_sent_9           : 1;  /**< [  9:  9](R/W1C/H) Mask clear for Interrupt BANK_SENT_9. */
        uint32_t bank_sent_8           : 1;  /**< [  8:  8](R/W1C/H) Mask clear for Interrupt BANK_SENT_8. */
        uint32_t bank_sent_7           : 1;  /**< [  7:  7](R/W1C/H) Mask clear for Interrupt BANK_SENT_7. */
        uint32_t bank_sent_6           : 1;  /**< [  6:  6](R/W1C/H) Mask clear for Interrupt BANK_SENT_6. */
        uint32_t bank_sent_5           : 1;  /**< [  5:  5](R/W1C/H) Mask clear for Interrupt BANK_SENT_5. */
        uint32_t bank_sent_4           : 1;  /**< [  4:  4](R/W1C/H) Mask clear for Interrupt BANK_SENT_4. */
        uint32_t bank_sent_3           : 1;  /**< [  3:  3](R/W1C/H) Mask clear for Interrupt BANK_SENT_3. */
        uint32_t bank_sent_2           : 1;  /**< [  2:  2](R/W1C/H) Mask clear for Interrupt BANK_SENT_2. */
        uint32_t bank_sent_1           : 1;  /**< [  1:  1](R/W1C/H) Mask clear for Interrupt BANK_SENT_1. */
        uint32_t bank_sent_0           : 1;  /**< [  0:  0](R/W1C/H) Mask clear for Interrupt BANK_SENT_0. */
#else /* Word 0 - Little Endian */
        uint32_t bank_sent_0           : 1;  /**< [  0:  0](R/W1C/H) Mask clear for Interrupt BANK_SENT_0. */
        uint32_t bank_sent_1           : 1;  /**< [  1:  1](R/W1C/H) Mask clear for Interrupt BANK_SENT_1. */
        uint32_t bank_sent_2           : 1;  /**< [  2:  2](R/W1C/H) Mask clear for Interrupt BANK_SENT_2. */
        uint32_t bank_sent_3           : 1;  /**< [  3:  3](R/W1C/H) Mask clear for Interrupt BANK_SENT_3. */
        uint32_t bank_sent_4           : 1;  /**< [  4:  4](R/W1C/H) Mask clear for Interrupt BANK_SENT_4. */
        uint32_t bank_sent_5           : 1;  /**< [  5:  5](R/W1C/H) Mask clear for Interrupt BANK_SENT_5. */
        uint32_t bank_sent_6           : 1;  /**< [  6:  6](R/W1C/H) Mask clear for Interrupt BANK_SENT_6. */
        uint32_t bank_sent_7           : 1;  /**< [  7:  7](R/W1C/H) Mask clear for Interrupt BANK_SENT_7. */
        uint32_t bank_sent_8           : 1;  /**< [  8:  8](R/W1C/H) Mask clear for Interrupt BANK_SENT_8. */
        uint32_t bank_sent_9           : 1;  /**< [  9:  9](R/W1C/H) Mask clear for Interrupt BANK_SENT_9. */
        uint32_t bank_sent_10          : 1;  /**< [ 10: 10](R/W1C/H) Mask clear for Interrupt BANK_SENT_10. */
        uint32_t bank_sent_11          : 1;  /**< [ 11: 11](R/W1C/H) Mask clear for Interrupt BANK_SENT_11. */
        uint32_t bank_sent_12          : 1;  /**< [ 12: 12](R/W1C/H) Mask clear for Interrupt BANK_SENT_12. */
        uint32_t bank_sent_13          : 1;  /**< [ 13: 13](R/W1C/H) Mask clear for Interrupt BANK_SENT_13. */
        uint32_t bank_sent_14          : 1;  /**< [ 14: 14](R/W1C/H) Mask clear for Interrupt BANK_SENT_14. */
        uint32_t bank_sent_15          : 1;  /**< [ 15: 15](R/W1C/H) Mask clear for Interrupt BANK_SENT_15:
                                                                   0 = No effect.
                                                                   1 = Mask clear. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctxb_int_mskcl_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctxb_int_mskcl_lnx cavm_cprix_cn4ipx_ctxb_int_mskcl_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTXB_INT_MSKCL_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTXB_INT_MSKCL_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x8640008282f4ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTXB_INT_MSKCL_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTXB_INT_MSKCL_LNX(a,b,c) cavm_cprix_cn4ipx_ctxb_int_mskcl_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTXB_INT_MSKCL_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTXB_INT_MSKCL_LNX(a,b,c) "CPRIX_CN4IPX_CTXB_INT_MSKCL_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTXB_INT_MSKCL_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTXB_INT_MSKCL_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_ctxb_int_mskst_ln#
 *
 * CPRI CONN4 IP CPRI TX Register Bank Interrupt Mask Set Register
 */
union cavm_cprix_cn4ipx_ctxb_int_mskst_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctxb_int_mskst_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t bank_sent_15          : 1;  /**< [ 15: 15](R/W1S/H) Mask set for Interrupt BANK_SENT_15:
                                                                   0 = No effect.
                                                                   1 = Mask set. */
        uint32_t bank_sent_14          : 1;  /**< [ 14: 14](R/W1S/H) Mask set for Interrupt BANK_SENT_14. */
        uint32_t bank_sent_13          : 1;  /**< [ 13: 13](R/W1S/H) Mask set for Interrupt BANK_SENT_13. */
        uint32_t bank_sent_12          : 1;  /**< [ 12: 12](R/W1S/H) Mask set for Interrupt BANK_SENT_12. */
        uint32_t bank_sent_11          : 1;  /**< [ 11: 11](R/W1S/H) Mask set for Interrupt BANK_SENT_11. */
        uint32_t bank_sent_10          : 1;  /**< [ 10: 10](R/W1S/H) Mask set for Interrupt BANK_SENT_10. */
        uint32_t bank_sent_9           : 1;  /**< [  9:  9](R/W1S/H) Mask set for Interrupt BANK_SENT_9. */
        uint32_t bank_sent_8           : 1;  /**< [  8:  8](R/W1S/H) Mask set for Interrupt BANK_SENT_8. */
        uint32_t bank_sent_7           : 1;  /**< [  7:  7](R/W1S/H) Mask set for Interrupt BANK_SENT_7. */
        uint32_t bank_sent_6           : 1;  /**< [  6:  6](R/W1S/H) Mask set for Interrupt BANK_SENT_6. */
        uint32_t bank_sent_5           : 1;  /**< [  5:  5](R/W1S/H) Mask set for Interrupt BANK_SENT_5. */
        uint32_t bank_sent_4           : 1;  /**< [  4:  4](R/W1S/H) Mask set for Interrupt BANK_SENT_4. */
        uint32_t bank_sent_3           : 1;  /**< [  3:  3](R/W1S/H) Mask set for Interrupt BANK_SENT_3. */
        uint32_t bank_sent_2           : 1;  /**< [  2:  2](R/W1S/H) Mask set for Interrupt BANK_SENT_2. */
        uint32_t bank_sent_1           : 1;  /**< [  1:  1](R/W1S/H) Mask set for Interrupt BANK_SENT_1. */
        uint32_t bank_sent_0           : 1;  /**< [  0:  0](R/W1S/H) Mask set for Interrupt BANK_SENT_0. */
#else /* Word 0 - Little Endian */
        uint32_t bank_sent_0           : 1;  /**< [  0:  0](R/W1S/H) Mask set for Interrupt BANK_SENT_0. */
        uint32_t bank_sent_1           : 1;  /**< [  1:  1](R/W1S/H) Mask set for Interrupt BANK_SENT_1. */
        uint32_t bank_sent_2           : 1;  /**< [  2:  2](R/W1S/H) Mask set for Interrupt BANK_SENT_2. */
        uint32_t bank_sent_3           : 1;  /**< [  3:  3](R/W1S/H) Mask set for Interrupt BANK_SENT_3. */
        uint32_t bank_sent_4           : 1;  /**< [  4:  4](R/W1S/H) Mask set for Interrupt BANK_SENT_4. */
        uint32_t bank_sent_5           : 1;  /**< [  5:  5](R/W1S/H) Mask set for Interrupt BANK_SENT_5. */
        uint32_t bank_sent_6           : 1;  /**< [  6:  6](R/W1S/H) Mask set for Interrupt BANK_SENT_6. */
        uint32_t bank_sent_7           : 1;  /**< [  7:  7](R/W1S/H) Mask set for Interrupt BANK_SENT_7. */
        uint32_t bank_sent_8           : 1;  /**< [  8:  8](R/W1S/H) Mask set for Interrupt BANK_SENT_8. */
        uint32_t bank_sent_9           : 1;  /**< [  9:  9](R/W1S/H) Mask set for Interrupt BANK_SENT_9. */
        uint32_t bank_sent_10          : 1;  /**< [ 10: 10](R/W1S/H) Mask set for Interrupt BANK_SENT_10. */
        uint32_t bank_sent_11          : 1;  /**< [ 11: 11](R/W1S/H) Mask set for Interrupt BANK_SENT_11. */
        uint32_t bank_sent_12          : 1;  /**< [ 12: 12](R/W1S/H) Mask set for Interrupt BANK_SENT_12. */
        uint32_t bank_sent_13          : 1;  /**< [ 13: 13](R/W1S/H) Mask set for Interrupt BANK_SENT_13. */
        uint32_t bank_sent_14          : 1;  /**< [ 14: 14](R/W1S/H) Mask set for Interrupt BANK_SENT_14. */
        uint32_t bank_sent_15          : 1;  /**< [ 15: 15](R/W1S/H) Mask set for Interrupt BANK_SENT_15:
                                                                   0 = No effect.
                                                                   1 = Mask set. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctxb_int_mskst_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctxb_int_mskst_lnx cavm_cprix_cn4ipx_ctxb_int_mskst_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTXB_INT_MSKST_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTXB_INT_MSKST_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x8640008282f8ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTXB_INT_MSKST_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTXB_INT_MSKST_LNX(a,b,c) cavm_cprix_cn4ipx_ctxb_int_mskst_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTXB_INT_MSKST_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTXB_INT_MSKST_LNX(a,b,c) "CPRIX_CN4IPX_CTXB_INT_MSKST_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTXB_INT_MSKST_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTXB_INT_MSKST_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_ctxb_int_set_ln#
 *
 * CPRI CONN4 IP CPRI TX Register Bank Interrupt Event Set Register
 */
union cavm_cprix_cn4ipx_ctxb_int_set_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctxb_int_set_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t bank_sent_15          : 1;  /**< [ 15: 15](R/W1S/H) Set for Interrupt BANK_SENT_15:
                                                                   0 = No effect.
                                                                   1 = Interrupt set. */
        uint32_t bank_sent_14          : 1;  /**< [ 14: 14](R/W1S/H) Set for Interrupt BANK_SENT_14. */
        uint32_t bank_sent_13          : 1;  /**< [ 13: 13](R/W1S/H) Set for Interrupt BANK_SENT_13. */
        uint32_t bank_sent_12          : 1;  /**< [ 12: 12](R/W1S/H) Set for Interrupt BANK_SENT_12. */
        uint32_t bank_sent_11          : 1;  /**< [ 11: 11](R/W1S/H) Set for Interrupt BANK_SENT_11. */
        uint32_t bank_sent_10          : 1;  /**< [ 10: 10](R/W1S/H) Set for Interrupt BANK_SENT_10. */
        uint32_t bank_sent_9           : 1;  /**< [  9:  9](R/W1S/H) Set for Interrupt BANK_SENT_9. */
        uint32_t bank_sent_8           : 1;  /**< [  8:  8](R/W1S/H) Set for Interrupt BANK_SENT_8. */
        uint32_t bank_sent_7           : 1;  /**< [  7:  7](R/W1S/H) Set for Interrupt BANK_SENT_7. */
        uint32_t bank_sent_6           : 1;  /**< [  6:  6](R/W1S/H) Set for Interrupt BANK_SENT_6. */
        uint32_t bank_sent_5           : 1;  /**< [  5:  5](R/W1S/H) Set for Interrupt BANK_SENT_5. */
        uint32_t bank_sent_4           : 1;  /**< [  4:  4](R/W1S/H) Set for Interrupt BANK_SENT_4. */
        uint32_t bank_sent_3           : 1;  /**< [  3:  3](R/W1S/H) Set for Interrupt BANK_SENT_3. */
        uint32_t bank_sent_2           : 1;  /**< [  2:  2](R/W1S/H) Set for Interrupt BANK_SENT_2. */
        uint32_t bank_sent_1           : 1;  /**< [  1:  1](R/W1S/H) Set for Interrupt BANK_SENT_1. */
        uint32_t bank_sent_0           : 1;  /**< [  0:  0](R/W1S/H) Set for Interrupt BANK_SENT_0. */
#else /* Word 0 - Little Endian */
        uint32_t bank_sent_0           : 1;  /**< [  0:  0](R/W1S/H) Set for Interrupt BANK_SENT_0. */
        uint32_t bank_sent_1           : 1;  /**< [  1:  1](R/W1S/H) Set for Interrupt BANK_SENT_1. */
        uint32_t bank_sent_2           : 1;  /**< [  2:  2](R/W1S/H) Set for Interrupt BANK_SENT_2. */
        uint32_t bank_sent_3           : 1;  /**< [  3:  3](R/W1S/H) Set for Interrupt BANK_SENT_3. */
        uint32_t bank_sent_4           : 1;  /**< [  4:  4](R/W1S/H) Set for Interrupt BANK_SENT_4. */
        uint32_t bank_sent_5           : 1;  /**< [  5:  5](R/W1S/H) Set for Interrupt BANK_SENT_5. */
        uint32_t bank_sent_6           : 1;  /**< [  6:  6](R/W1S/H) Set for Interrupt BANK_SENT_6. */
        uint32_t bank_sent_7           : 1;  /**< [  7:  7](R/W1S/H) Set for Interrupt BANK_SENT_7. */
        uint32_t bank_sent_8           : 1;  /**< [  8:  8](R/W1S/H) Set for Interrupt BANK_SENT_8. */
        uint32_t bank_sent_9           : 1;  /**< [  9:  9](R/W1S/H) Set for Interrupt BANK_SENT_9. */
        uint32_t bank_sent_10          : 1;  /**< [ 10: 10](R/W1S/H) Set for Interrupt BANK_SENT_10. */
        uint32_t bank_sent_11          : 1;  /**< [ 11: 11](R/W1S/H) Set for Interrupt BANK_SENT_11. */
        uint32_t bank_sent_12          : 1;  /**< [ 12: 12](R/W1S/H) Set for Interrupt BANK_SENT_12. */
        uint32_t bank_sent_13          : 1;  /**< [ 13: 13](R/W1S/H) Set for Interrupt BANK_SENT_13. */
        uint32_t bank_sent_14          : 1;  /**< [ 14: 14](R/W1S/H) Set for Interrupt BANK_SENT_14. */
        uint32_t bank_sent_15          : 1;  /**< [ 15: 15](R/W1S/H) Set for Interrupt BANK_SENT_15:
                                                                   0 = No effect.
                                                                   1 = Interrupt set. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctxb_int_set_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctxb_int_set_lnx cavm_cprix_cn4ipx_ctxb_int_set_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTXB_INT_SET_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTXB_INT_SET_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x8640008282e8ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTXB_INT_SET_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTXB_INT_SET_LNX(a,b,c) cavm_cprix_cn4ipx_ctxb_int_set_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTXB_INT_SET_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTXB_INT_SET_LNX(a,b,c) "CPRIX_CN4IPX_CTXB_INT_SET_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTXB_INT_SET_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTXB_INT_SET_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_ctxb_int_sts_ln#
 *
 * CPRI CONN4 IP CPRI TX Register Bank Interrupt Status Register
 */
union cavm_cprix_cn4ipx_ctxb_int_sts_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctxb_int_sts_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t bank_sent_15          : 1;  /**< [ 15: 15](RO/H) Transmission status of box 15.
                                                                   0 = not sent.
                                                                   1 = enabled bytes were sent. */
        uint32_t bank_sent_14          : 1;  /**< [ 14: 14](RO/H) Transmission status of box 14. */
        uint32_t bank_sent_13          : 1;  /**< [ 13: 13](RO/H) Transmission status of box 13. */
        uint32_t bank_sent_12          : 1;  /**< [ 12: 12](RO/H) Transmission status of box 12. */
        uint32_t bank_sent_11          : 1;  /**< [ 11: 11](RO/H) Transmission status of box 11. */
        uint32_t bank_sent_10          : 1;  /**< [ 10: 10](RO/H) Transmission status of box 10. */
        uint32_t bank_sent_9           : 1;  /**< [  9:  9](RO/H) Transmission status of box 9. */
        uint32_t bank_sent_8           : 1;  /**< [  8:  8](RO/H) Transmission status of box 8. */
        uint32_t bank_sent_7           : 1;  /**< [  7:  7](RO/H) Transmission status of box 7. */
        uint32_t bank_sent_6           : 1;  /**< [  6:  6](RO/H) Transmission status of box 6. */
        uint32_t bank_sent_5           : 1;  /**< [  5:  5](RO/H) Transmission status of box 5. */
        uint32_t bank_sent_4           : 1;  /**< [  4:  4](RO/H) Transmission status of box 4. */
        uint32_t bank_sent_3           : 1;  /**< [  3:  3](RO/H) Transmission status of box 3. */
        uint32_t bank_sent_2           : 1;  /**< [  2:  2](RO/H) Transmission status of box 2. */
        uint32_t bank_sent_1           : 1;  /**< [  1:  1](RO/H) Transmission status of box 1. */
        uint32_t bank_sent_0           : 1;  /**< [  0:  0](RO/H) Transmission status of box 0. */
#else /* Word 0 - Little Endian */
        uint32_t bank_sent_0           : 1;  /**< [  0:  0](RO/H) Transmission status of box 0. */
        uint32_t bank_sent_1           : 1;  /**< [  1:  1](RO/H) Transmission status of box 1. */
        uint32_t bank_sent_2           : 1;  /**< [  2:  2](RO/H) Transmission status of box 2. */
        uint32_t bank_sent_3           : 1;  /**< [  3:  3](RO/H) Transmission status of box 3. */
        uint32_t bank_sent_4           : 1;  /**< [  4:  4](RO/H) Transmission status of box 4. */
        uint32_t bank_sent_5           : 1;  /**< [  5:  5](RO/H) Transmission status of box 5. */
        uint32_t bank_sent_6           : 1;  /**< [  6:  6](RO/H) Transmission status of box 6. */
        uint32_t bank_sent_7           : 1;  /**< [  7:  7](RO/H) Transmission status of box 7. */
        uint32_t bank_sent_8           : 1;  /**< [  8:  8](RO/H) Transmission status of box 8. */
        uint32_t bank_sent_9           : 1;  /**< [  9:  9](RO/H) Transmission status of box 9. */
        uint32_t bank_sent_10          : 1;  /**< [ 10: 10](RO/H) Transmission status of box 10. */
        uint32_t bank_sent_11          : 1;  /**< [ 11: 11](RO/H) Transmission status of box 11. */
        uint32_t bank_sent_12          : 1;  /**< [ 12: 12](RO/H) Transmission status of box 12. */
        uint32_t bank_sent_13          : 1;  /**< [ 13: 13](RO/H) Transmission status of box 13. */
        uint32_t bank_sent_14          : 1;  /**< [ 14: 14](RO/H) Transmission status of box 14. */
        uint32_t bank_sent_15          : 1;  /**< [ 15: 15](RO/H) Transmission status of box 15.
                                                                   0 = not sent.
                                                                   1 = enabled bytes were sent. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctxb_int_sts_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctxb_int_sts_lnx cavm_cprix_cn4ipx_ctxb_int_sts_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTXB_INT_STS_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTXB_INT_STS_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x8640008282e0ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTXB_INT_STS_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTXB_INT_STS_LNX(a,b,c) cavm_cprix_cn4ipx_ctxb_int_sts_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTXB_INT_STS_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTXB_INT_STS_LNX(a,b,c) "CPRIX_CN4IPX_CTXB_INT_STS_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTXB_INT_STS_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTXB_INT_STS_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_ctxvsb#_bounds_ln#
 *
 * CPRI CONN4 IP CPRI TX VSB General Configuration Register
 */
union cavm_cprix_cn4ipx_ctxvsbx_bounds_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctxvsbx_bounds_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t index                 : 8;  /**< [ 31: 24](R/W) Index of hyperframe activation rule. Subchannel is active when modulo of the
                                                                 number of hyperframe matches this index.
                                                                       0 .. 0x95  = valid.
                                                                     0x96 .. 0xFF = not valid. */
        uint32_t modulo                : 8;  /**< [ 23: 16](R/W) Modulo of hyperframe activation rule. Value of this field is the actual modulo value minus one.
                                                                            0 = transmission disabled.
                                                                     1 .. 0x96 = valid.
                                                                   0x97 .. 0xFF = not valid. */
        uint32_t xs1                   : 2;  /**< [ 15: 14](R/W) Xs coordinate of bottom right corner of active subchannel region.
                                                                         0 .. 3 = valid. */
        uint32_t ns1                   : 6;  /**< [ 13:  8](R/W) Ns coordinate of bottom right corner of active subchannel region.
                                                                       0 ..   2 = not valid.
                                                                        3 .. 0x3F = valid. */
        uint32_t xs0                   : 2;  /**< [  7:  6](R/W) Xs coordinate of top left corner of active subchannel region.
                                                                         0 .. 3 = valid. */
        uint32_t ns0                   : 6;  /**< [  5:  0](R/W) Ns coordinate of top left corner of active subchannel region.
                                                                       0 ..   2 = not valid.
                                                                        3 .. 0x3F = valid. */
#else /* Word 0 - Little Endian */
        uint32_t ns0                   : 6;  /**< [  5:  0](R/W) Ns coordinate of top left corner of active subchannel region.
                                                                       0 ..   2 = not valid.
                                                                        3 .. 0x3F = valid. */
        uint32_t xs0                   : 2;  /**< [  7:  6](R/W) Xs coordinate of top left corner of active subchannel region.
                                                                         0 .. 3 = valid. */
        uint32_t ns1                   : 6;  /**< [ 13:  8](R/W) Ns coordinate of bottom right corner of active subchannel region.
                                                                       0 ..   2 = not valid.
                                                                        3 .. 0x3F = valid. */
        uint32_t xs1                   : 2;  /**< [ 15: 14](R/W) Xs coordinate of bottom right corner of active subchannel region.
                                                                         0 .. 3 = valid. */
        uint32_t modulo                : 8;  /**< [ 23: 16](R/W) Modulo of hyperframe activation rule. Value of this field is the actual modulo value minus one.
                                                                            0 = transmission disabled.
                                                                     1 .. 0x96 = valid.
                                                                   0x97 .. 0xFF = not valid. */
        uint32_t index                 : 8;  /**< [ 31: 24](R/W) Index of hyperframe activation rule. Subchannel is active when modulo of the
                                                                 number of hyperframe matches this index.
                                                                       0 .. 0x95  = valid.
                                                                     0x96 .. 0xFF = not valid. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctxvsbx_bounds_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctxvsbx_bounds_lnx cavm_cprix_cn4ipx_ctxvsbx_bounds_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTXVSBX_BOUNDS_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTXVSBX_BOUNDS_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=3) && (d<=1)))
        return 0x864000828110ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 4ll * ((c) & 0x3) + 0x10000ll * ((d) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTXVSBX_BOUNDS_LNX", 4, a, b, c, d, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTXVSBX_BOUNDS_LNX(a,b,c,d) cavm_cprix_cn4ipx_ctxvsbx_bounds_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTXVSBX_BOUNDS_LNX(a,b,c,d) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTXVSBX_BOUNDS_LNX(a,b,c,d) "CPRIX_CN4IPX_CTXVSBX_BOUNDS_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTXVSBX_BOUNDS_LNX(a,b,c,d) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTXVSBX_BOUNDS_LNX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) cpri#_cn4ip#_ctxvsb#_general_ln#
 *
 * CPRI CONN4 IP CPRI TX VSB General Configuration Register
 */
union cavm_cprix_cn4ipx_ctxvsbx_general_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctxvsbx_general_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_29_31        : 3;
        uint32_t enable                : 1;  /**< [ 28: 28](R/W) Buffer enable.
                                                                 When enabled after being disabled, transmission starts at HFN 0 from beginning of slice 0.
                                                                          0 = disabled.
                                                                          1 = enabled. */
        uint32_t yn                    : 4;  /**< [ 27: 24](R/W) Active bytes of CPRI word. Only the active bytes are included to the bit pipe
                                                                 defined by the region. Active bytes need to exist with the used CPRI line rate.
                                                                     0x0 = Y1 & Y0.
                                                                     0x1 = Y3 & Y2.
                                                                     0x2 = Y5 & Y4.
                                                                     0x3 = Y7 & Y6.
                                                                     0x4 = Y9 & Y8.
                                                                     0x5 = Y11 & Y10.
                                                                     0x6 = Y13 & Y12.
                                                                     0x7 = Y15 & Y14.
                                                                     0x8 = Y3...Y0.
                                                                     0x9 = Y7...Y4.
                                                                     0xA = Y11...Y8.
                                                                     0xB = Y15...Y12.
                                                                     0xC = Y7...Y0.
                                                                     0xD = Y15...Y8.
                                                                     0xE = Y9...Y0.
                                                                     0xF = Y15...Y0. */
        uint32_t start                 : 10; /**< [ 23: 14](R/W) Start address of the first buffer slice in 32-bit words.
                                                                 Start address has to be defined so that it does not overlap with other buffer areas. */
        uint32_t reserved_12_13        : 2;
        uint32_t length                : 10; /**< [ 11:  2](R/W) Length of one buffer slice in 32-bit words.
                                                                 Total size of buffer area is 4 times the value of this field. */
        uint32_t reserved_0_1          : 2;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0_1          : 2;
        uint32_t length                : 10; /**< [ 11:  2](R/W) Length of one buffer slice in 32-bit words.
                                                                 Total size of buffer area is 4 times the value of this field. */
        uint32_t reserved_12_13        : 2;
        uint32_t start                 : 10; /**< [ 23: 14](R/W) Start address of the first buffer slice in 32-bit words.
                                                                 Start address has to be defined so that it does not overlap with other buffer areas. */
        uint32_t yn                    : 4;  /**< [ 27: 24](R/W) Active bytes of CPRI word. Only the active bytes are included to the bit pipe
                                                                 defined by the region. Active bytes need to exist with the used CPRI line rate.
                                                                     0x0 = Y1 & Y0.
                                                                     0x1 = Y3 & Y2.
                                                                     0x2 = Y5 & Y4.
                                                                     0x3 = Y7 & Y6.
                                                                     0x4 = Y9 & Y8.
                                                                     0x5 = Y11 & Y10.
                                                                     0x6 = Y13 & Y12.
                                                                     0x7 = Y15 & Y14.
                                                                     0x8 = Y3...Y0.
                                                                     0x9 = Y7...Y4.
                                                                     0xA = Y11...Y8.
                                                                     0xB = Y15...Y12.
                                                                     0xC = Y7...Y0.
                                                                     0xD = Y15...Y8.
                                                                     0xE = Y9...Y0.
                                                                     0xF = Y15...Y0. */
        uint32_t enable                : 1;  /**< [ 28: 28](R/W) Buffer enable.
                                                                 When enabled after being disabled, transmission starts at HFN 0 from beginning of slice 0.
                                                                          0 = disabled.
                                                                          1 = enabled. */
        uint32_t reserved_29_31        : 3;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctxvsbx_general_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctxvsbx_general_lnx cavm_cprix_cn4ipx_ctxvsbx_general_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTXVSBX_GENERAL_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTXVSBX_GENERAL_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=3) && (d<=1)))
        return 0x864000828100ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 4ll * ((c) & 0x3) + 0x10000ll * ((d) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTXVSBX_GENERAL_LNX", 4, a, b, c, d, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTXVSBX_GENERAL_LNX(a,b,c,d) cavm_cprix_cn4ipx_ctxvsbx_general_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTXVSBX_GENERAL_LNX(a,b,c,d) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTXVSBX_GENERAL_LNX(a,b,c,d) "CPRIX_CN4IPX_CTXVSBX_GENERAL_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTXVSBX_GENERAL_LNX(a,b,c,d) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTXVSBX_GENERAL_LNX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) cpri#_cn4ip#_ctxvsb#_slice#_ln#
 *
 * CPRI CONN4 IP CPRI TX VSB Slice Configuration and Status Register
 */
union cavm_cprix_cn4ipx_ctxvsbx_slicex_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctxvsbx_slicex_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t underflow             : 1;  /**< [  3:  3](RO/H) Transmission underflow. Underflow status is asserted when content of the slice
                                                                 should be transmitted but transmission has not been enabled by writing one to
                                                                 field TRANSMIT. In that case, zero data is transmitted instead. Status of this
                                                                 field is cleared when corresponding interrupt status bit is cleared.
                                                                   0 = No underflow.
                                                                   1 = Underflow during transmission. */
        uint32_t done                  : 1;  /**< [  2:  2](RO/H) Done flag. This flag is set when slice has been transmitted at least once. The
                                                                 flag is cleared when TRANSMIT bit is set again.
                                                                   0 = Slice has not been transmitted.
                                                                   1 = Slice has been transmitted. */
        uint32_t repeat_s              : 1;  /**< [  1:  1](R/W) Repeat flag. If repeat is not enabled, slice is already sent at least once and
                                                                 slice would be transmitted again, zero is transmitted instead and transmission
                                                                 underflow condition is asserted.
                                                                   0 = Slice is not repeated.
                                                                   1 = Slice is repeated. */
        uint32_t transmit              : 1;  /**< [  0:  0](R/W/H) Transmit enable. One is written to this field when slice is ready for
                                                                 transmission. Writing of one to this field clears field DONE. Value of this
                                                                 field is always zero when read.
                                                                   0 = Do not transmit.
                                                                   1 = Transmit slice. */
#else /* Word 0 - Little Endian */
        uint32_t transmit              : 1;  /**< [  0:  0](R/W/H) Transmit enable. One is written to this field when slice is ready for
                                                                 transmission. Writing of one to this field clears field DONE. Value of this
                                                                 field is always zero when read.
                                                                   0 = Do not transmit.
                                                                   1 = Transmit slice. */
        uint32_t repeat_s              : 1;  /**< [  1:  1](R/W) Repeat flag. If repeat is not enabled, slice is already sent at least once and
                                                                 slice would be transmitted again, zero is transmitted instead and transmission
                                                                 underflow condition is asserted.
                                                                   0 = Slice is not repeated.
                                                                   1 = Slice is repeated. */
        uint32_t done                  : 1;  /**< [  2:  2](RO/H) Done flag. This flag is set when slice has been transmitted at least once. The
                                                                 flag is cleared when TRANSMIT bit is set again.
                                                                   0 = Slice has not been transmitted.
                                                                   1 = Slice has been transmitted. */
        uint32_t underflow             : 1;  /**< [  3:  3](RO/H) Transmission underflow. Underflow status is asserted when content of the slice
                                                                 should be transmitted but transmission has not been enabled by writing one to
                                                                 field TRANSMIT. In that case, zero data is transmitted instead. Status of this
                                                                 field is cleared when corresponding interrupt status bit is cleared.
                                                                   0 = No underflow.
                                                                   1 = Underflow during transmission. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctxvsbx_slicex_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctxvsbx_slicex_lnx cavm_cprix_cn4ipx_ctxvsbx_slicex_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTXVSBX_SLICEX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d, unsigned long e) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTXVSBX_SLICEX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d, unsigned long e)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=3) && (d<=3) && (e<=1)))
        return 0x864000828140ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10ll * ((c) & 0x3) + 4ll * ((d) & 0x3) + 0x10000ll * ((e) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTXVSBX_SLICEX_LNX", 5, a, b, c, d, e, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTXVSBX_SLICEX_LNX(a,b,c,d,e) cavm_cprix_cn4ipx_ctxvsbx_slicex_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTXVSBX_SLICEX_LNX(a,b,c,d,e) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTXVSBX_SLICEX_LNX(a,b,c,d,e) "CPRIX_CN4IPX_CTXVSBX_SLICEX_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTXVSBX_SLICEX_LNX(a,b,c,d,e) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTXVSBX_SLICEX_LNX(a,b,c,d,e) (a),(b),(c),(d),(e)

/**
 * Register (NCB32b) cpri#_cn4ip#_ctxvsb_bufram#_ln#
 *
 * CPRI CONN4 IP CPRI TX VSB Buffer RAM Registers
 */
union cavm_cprix_cn4ipx_ctxvsb_buframx_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_ctxvsb_buframx_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t byte3                 : 8;  /**< [ 31: 24](R/W) Byte three. Transmitted last. */
        uint32_t byte2                 : 8;  /**< [ 23: 16](R/W) Byte two. */
        uint32_t byte1                 : 8;  /**< [ 15:  8](R/W) Byte one. */
        uint32_t byte0                 : 8;  /**< [  7:  0](R/W) Byte zero. Transmitted first. */
#else /* Word 0 - Little Endian */
        uint32_t byte0                 : 8;  /**< [  7:  0](R/W) Byte zero. Transmitted first. */
        uint32_t byte1                 : 8;  /**< [ 15:  8](R/W) Byte one. */
        uint32_t byte2                 : 8;  /**< [ 23: 16](R/W) Byte two. */
        uint32_t byte3                 : 8;  /**< [ 31: 24](R/W) Byte three. Transmitted last. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_ctxvsb_buframx_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_ctxvsb_buframx_lnx cavm_cprix_cn4ipx_ctxvsb_buframx_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_CTXVSB_BUFRAMX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_CTXVSB_BUFRAMX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1023) && (d<=1)))
        return 0x86400082a000ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 4ll * ((c) & 0x3ff) + 0x10000ll * ((d) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_CTXVSB_BUFRAMX_LNX", 4, a, b, c, d, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_CTXVSB_BUFRAMX_LNX(a,b,c,d) cavm_cprix_cn4ipx_ctxvsb_buframx_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_CTXVSB_BUFRAMX_LNX(a,b,c,d) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_CTXVSB_BUFRAMX_LNX(a,b,c,d) "CPRIX_CN4IPX_CTXVSB_BUFRAMX_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_CTXVSB_BUFRAMX_LNX(a,b,c,d) (a)
#define arguments_CAVM_CPRIX_CN4IPX_CTXVSB_BUFRAMX_LNX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) cpri#_cn4ip#_eth_addr_0
 *
 * CPRI CONN4 IP RP3-01 link 0 Ethernet Message Target Address Register
 */
union cavm_cprix_cn4ipx_eth_addr_0
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_eth_addr_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_13_31        : 19;
        uint32_t addr                  : 13; /**< [ 12:  0](R/W) RP3 Address of the target node for RP3-01 Ethernet Messages. */
#else /* Word 0 - Little Endian */
        uint32_t addr                  : 13; /**< [ 12:  0](R/W) RP3 Address of the target node for RP3-01 Ethernet Messages. */
        uint32_t reserved_13_31        : 19;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_eth_addr_0_s cn; */
};
typedef union cavm_cprix_cn4ipx_eth_addr_0 cavm_cprix_cn4ipx_eth_addr_0_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_ETH_ADDR_0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_ETH_ADDR_0(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f280ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_ETH_ADDR_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_ETH_ADDR_0(a,b) cavm_cprix_cn4ipx_eth_addr_0_t
#define bustype_CAVM_CPRIX_CN4IPX_ETH_ADDR_0(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_ETH_ADDR_0(a,b) "CPRIX_CN4IPX_ETH_ADDR_0"
#define busnum_CAVM_CPRIX_CN4IPX_ETH_ADDR_0(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_ETH_ADDR_0(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_eth_addr_1
 *
 * CPRI CONN4 IP RP3-01 link 1 Ethernet Message Target Address Register
 */
union cavm_cprix_cn4ipx_eth_addr_1
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_eth_addr_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_13_31        : 19;
        uint32_t addr                  : 13; /**< [ 12:  0](R/W) RP3 Address of the target node for RP3-01 Ethernet Messages. */
#else /* Word 0 - Little Endian */
        uint32_t addr                  : 13; /**< [ 12:  0](R/W) RP3 Address of the target node for RP3-01 Ethernet Messages. */
        uint32_t reserved_13_31        : 19;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_eth_addr_1_s cn; */
};
typedef union cavm_cprix_cn4ipx_eth_addr_1 cavm_cprix_cn4ipx_eth_addr_1_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_ETH_ADDR_1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_ETH_ADDR_1(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f284ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_ETH_ADDR_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_ETH_ADDR_1(a,b) cavm_cprix_cn4ipx_eth_addr_1_t
#define bustype_CAVM_CPRIX_CN4IPX_ETH_ADDR_1(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_ETH_ADDR_1(a,b) "CPRIX_CN4IPX_ETH_ADDR_1"
#define busnum_CAVM_CPRIX_CN4IPX_ETH_ADDR_1(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_ETH_ADDR_1(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_eth_en
 *
 * CPRI CONN4 IP RP3-01 Ethernet Transfer Enable Register
 */
union cavm_cprix_cn4ipx_eth_en
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_eth_en_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t en                    : 3;  /**< [  2:  0](R/W) Enable for each RP3-01 link Ethernet transfer (Bit 0 = RP3-01 link 0).
                                                                   0 = Ethernet transfer disabled.
                                                                   1 = Ethernet transfer enabled. */
#else /* Word 0 - Little Endian */
        uint32_t en                    : 3;  /**< [  2:  0](R/W) Enable for each RP3-01 link Ethernet transfer (Bit 0 = RP3-01 link 0).
                                                                   0 = Ethernet transfer disabled.
                                                                   1 = Ethernet transfer enabled. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_eth_en_s cn; */
};
typedef union cavm_cprix_cn4ipx_eth_en cavm_cprix_cn4ipx_eth_en_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_ETH_EN(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_ETH_EN(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f27cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_ETH_EN", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_ETH_EN(a,b) cavm_cprix_cn4ipx_eth_en_t
#define bustype_CAVM_CPRIX_CN4IPX_ETH_EN(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_ETH_EN(a,b) "CPRIX_CN4IPX_ETH_EN"
#define busnum_CAVM_CPRIX_CN4IPX_ETH_EN(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_ETH_EN(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_fcb_crc_sel
 *
 * CPRI CONN4 IP RP1 Frame synchronization CRC selection  Register
 */
union cavm_cprix_cn4ipx_fcb_crc_sel
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_fcb_crc_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t bit_inv               : 1;  /**< [  2:  2](R/W) Inversion selection for RP1 synchronization burst CRC.
                                                                   0 = Not inverted.
                                                                   1 = Inverted. */
        uint32_t order                 : 1;  /**< [  1:  1](R/W) MSB/LSB order within RP1 synchronization burst CRC.
                                                                   0 = LSB sent first.
                                                                   1 = MSB sent first. */
        uint32_t init                  : 1;  /**< [  0:  0](R/W) Initial state of the CRC calculation.
                                                                   0 = CRC initialized to 0xFFFF.
                                                                   1 = CRC initialized to 0x0000.
                                                                 Note: OBSAI compatible value is 0x0000. */
#else /* Word 0 - Little Endian */
        uint32_t init                  : 1;  /**< [  0:  0](R/W) Initial state of the CRC calculation.
                                                                   0 = CRC initialized to 0xFFFF.
                                                                   1 = CRC initialized to 0x0000.
                                                                 Note: OBSAI compatible value is 0x0000. */
        uint32_t order                 : 1;  /**< [  1:  1](R/W) MSB/LSB order within RP1 synchronization burst CRC.
                                                                   0 = LSB sent first.
                                                                   1 = MSB sent first. */
        uint32_t bit_inv               : 1;  /**< [  2:  2](R/W) Inversion selection for RP1 synchronization burst CRC.
                                                                   0 = Not inverted.
                                                                   1 = Inverted. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_fcb_crc_sel_s cn; */
};
typedef union cavm_cprix_cn4ipx_fcb_crc_sel cavm_cprix_cn4ipx_fcb_crc_sel_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_FCB_CRC_SEL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_FCB_CRC_SEL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f004ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_FCB_CRC_SEL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_FCB_CRC_SEL(a,b) cavm_cprix_cn4ipx_fcb_crc_sel_t
#define bustype_CAVM_CPRIX_CN4IPX_FCB_CRC_SEL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_FCB_CRC_SEL(a,b) "CPRIX_CN4IPX_FCB_CRC_SEL"
#define busnum_CAVM_CPRIX_CN4IPX_FCB_CRC_SEL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_FCB_CRC_SEL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_fcb_head_0
 *
 * CPRI CONN4 IP RP3-01 Link 0 Frame Synchronization Message Header Register
 */
union cavm_cprix_cn4ipx_fcb_head_0
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_fcb_head_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t address               : 13; /**< [ 23: 11](R/W) Address for Target mode. */
        uint32_t type_s                : 5;  /**< [ 10:  6](R/W) Type. */
        uint32_t timestamp             : 6;  /**< [  5:  0](R/W) Timestamp. */
#else /* Word 0 - Little Endian */
        uint32_t timestamp             : 6;  /**< [  5:  0](R/W) Timestamp. */
        uint32_t type_s                : 5;  /**< [ 10:  6](R/W) Type. */
        uint32_t address               : 13; /**< [ 23: 11](R/W) Address for Target mode. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_fcb_head_0_s cn; */
};
typedef union cavm_cprix_cn4ipx_fcb_head_0 cavm_cprix_cn4ipx_fcb_head_0_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_FCB_HEAD_0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_FCB_HEAD_0(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f100ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_FCB_HEAD_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_FCB_HEAD_0(a,b) cavm_cprix_cn4ipx_fcb_head_0_t
#define bustype_CAVM_CPRIX_CN4IPX_FCB_HEAD_0(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_FCB_HEAD_0(a,b) "CPRIX_CN4IPX_FCB_HEAD_0"
#define busnum_CAVM_CPRIX_CN4IPX_FCB_HEAD_0(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_FCB_HEAD_0(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_fcb_head_1
 *
 * CPRI CONN4 IP RP3-01 Link 1 Frame Synchronization Message Header Register
 */
union cavm_cprix_cn4ipx_fcb_head_1
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_fcb_head_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t address               : 13; /**< [ 23: 11](R/W) Address for Target mode. */
        uint32_t type_s                : 5;  /**< [ 10:  6](R/W) Type. */
        uint32_t timestamp             : 6;  /**< [  5:  0](R/W) Timestamp. */
#else /* Word 0 - Little Endian */
        uint32_t timestamp             : 6;  /**< [  5:  0](R/W) Timestamp. */
        uint32_t type_s                : 5;  /**< [ 10:  6](R/W) Type. */
        uint32_t address               : 13; /**< [ 23: 11](R/W) Address for Target mode. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_fcb_head_1_s cn; */
};
typedef union cavm_cprix_cn4ipx_fcb_head_1 cavm_cprix_cn4ipx_fcb_head_1_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_FCB_HEAD_1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_FCB_HEAD_1(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f104ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_FCB_HEAD_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_FCB_HEAD_1(a,b) cavm_cprix_cn4ipx_fcb_head_1_t
#define bustype_CAVM_CPRIX_CN4IPX_FCB_HEAD_1(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_FCB_HEAD_1(a,b) "CPRIX_CN4IPX_FCB_HEAD_1"
#define busnum_CAVM_CPRIX_CN4IPX_FCB_HEAD_1(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_FCB_HEAD_1(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_fcb_oic_sel
 *
 * CPRI CONN4 IP FCB OIC Mode Selection Register
 */
union cavm_cprix_cn4ipx_fcb_oic_sel
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_fcb_oic_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t oic_mode              : 3;  /**< [  2:  0](R/W) OIC mode selection (C1 value rounding for RP3 and WCDMA type bursts). Separate
                                                                 bit for each RP3-01 link, bit 0 corresponds to RP3-01 link 0.
                                                                   0 = No rounding for C1.
                                                                   1 = C1 value rounded to nearest chip period. */
#else /* Word 0 - Little Endian */
        uint32_t oic_mode              : 3;  /**< [  2:  0](R/W) OIC mode selection (C1 value rounding for RP3 and WCDMA type bursts). Separate
                                                                 bit for each RP3-01 link, bit 0 corresponds to RP3-01 link 0.
                                                                   0 = No rounding for C1.
                                                                   1 = C1 value rounded to nearest chip period. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_fcb_oic_sel_s cn; */
};
typedef union cavm_cprix_cn4ipx_fcb_oic_sel cavm_cprix_cn4ipx_fcb_oic_sel_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_FCB_OIC_SEL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_FCB_OIC_SEL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f128ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_FCB_OIC_SEL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_FCB_OIC_SEL(a,b) cavm_cprix_cn4ipx_fcb_oic_sel_t
#define bustype_CAVM_CPRIX_CN4IPX_FCB_OIC_SEL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_FCB_OIC_SEL(a,b) "CPRIX_CN4IPX_FCB_OIC_SEL"
#define busnum_CAVM_CPRIX_CN4IPX_FCB_OIC_SEL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_FCB_OIC_SEL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_fcb_rec_en
 *
 * CPRI CONN4 IP RP3-01 FCB Message Reception Enable Register
 */
union cavm_cprix_cn4ipx_fcb_rec_en
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_fcb_rec_en_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t sel_1                 : 1;  /**< [  1:  1](R/W) Enable reception of frame synchronization messages from RP3-01 link 1. */
        uint32_t sel_0                 : 1;  /**< [  0:  0](R/W) Enable reception of frame synchronization messages from RP3-01 link 0. */
#else /* Word 0 - Little Endian */
        uint32_t sel_0                 : 1;  /**< [  0:  0](R/W) Enable reception of frame synchronization messages from RP3-01 link 0. */
        uint32_t sel_1                 : 1;  /**< [  1:  1](R/W) Enable reception of frame synchronization messages from RP3-01 link 1. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_fcb_rec_en_s cn; */
};
typedef union cavm_cprix_cn4ipx_fcb_rec_en cavm_cprix_cn4ipx_fcb_rec_en_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_FCB_REC_EN(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_FCB_REC_EN(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f030ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_FCB_REC_EN", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_FCB_REC_EN(a,b) cavm_cprix_cn4ipx_fcb_rec_en_t
#define bustype_CAVM_CPRIX_CN4IPX_FCB_REC_EN(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_FCB_REC_EN(a,b) "CPRIX_CN4IPX_FCB_REC_EN"
#define busnum_CAVM_CPRIX_CN4IPX_FCB_REC_EN(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_FCB_REC_EN(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_fcb_round
 *
 * CPRI CONN4 IP FCB RP3 Rounding Error Register
 */
union cavm_cprix_cn4ipx_fcb_round
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_fcb_round_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_9_31         : 23;
        uint32_t round_capt            : 1;  /**< [  8:  8](RO/H) New rounding error value has been captured after last write to FCB_ROUND_CTRL.
                                                                   0 = Waiting for new value capture.
                                                                   1 = New rounding error captured. */
        uint32_t reserved_7            : 1;
        uint32_t round_err             : 7;  /**< [  6:  0](RO/H) Rounding error in case C1 rounding is enabled. Value range 0-79. Values \> 40
                                                                 means rounding was done upwards. Unit is 307.2 MHz clock period. */
#else /* Word 0 - Little Endian */
        uint32_t round_err             : 7;  /**< [  6:  0](RO/H) Rounding error in case C1 rounding is enabled. Value range 0-79. Values \> 40
                                                                 means rounding was done upwards. Unit is 307.2 MHz clock period. */
        uint32_t reserved_7            : 1;
        uint32_t round_capt            : 1;  /**< [  8:  8](RO/H) New rounding error value has been captured after last write to FCB_ROUND_CTRL.
                                                                   0 = Waiting for new value capture.
                                                                   1 = New rounding error captured. */
        uint32_t reserved_9_31         : 23;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_fcb_round_s cn; */
};
typedef union cavm_cprix_cn4ipx_fcb_round cavm_cprix_cn4ipx_fcb_round_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_FCB_ROUND(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_FCB_ROUND(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f130ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_FCB_ROUND", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_FCB_ROUND(a,b) cavm_cprix_cn4ipx_fcb_round_t
#define bustype_CAVM_CPRIX_CN4IPX_FCB_ROUND(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_FCB_ROUND(a,b) "CPRIX_CN4IPX_FCB_ROUND"
#define busnum_CAVM_CPRIX_CN4IPX_FCB_ROUND(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_FCB_ROUND(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_fcb_round_ctrl
 *
 * CPRI CONN4 IP FCB RP3 Rounding Error Capture Control Register
 */
union cavm_cprix_cn4ipx_fcb_round_ctrl
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_fcb_round_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t round_type            : 1;  /**< [  4:  4](R/W) FCB type selection for rounding error capture.
                                                                   0 = RP3.
                                                                   1 = WCDMA. */
        uint32_t reserved_2_3          : 2;
        uint32_t round_link            : 2;  /**< [  1:  0](R/W) Link for capturing rounding error.
                                                                   0 = RP3-01 link 0.
                                                                   1 = RP3-01 link 1.
                                                                   2 = RP3-01 link 2.
                                                                   3 = Not used. */
#else /* Word 0 - Little Endian */
        uint32_t round_link            : 2;  /**< [  1:  0](R/W) Link for capturing rounding error.
                                                                   0 = RP3-01 link 0.
                                                                   1 = RP3-01 link 1.
                                                                   2 = RP3-01 link 2.
                                                                   3 = Not used. */
        uint32_t reserved_2_3          : 2;
        uint32_t round_type            : 1;  /**< [  4:  4](R/W) FCB type selection for rounding error capture.
                                                                   0 = RP3.
                                                                   1 = WCDMA. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_fcb_round_ctrl_s cn; */
};
typedef union cavm_cprix_cn4ipx_fcb_round_ctrl cavm_cprix_cn4ipx_fcb_round_ctrl_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_FCB_ROUND_CTRL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_FCB_ROUND_CTRL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f12cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_FCB_ROUND_CTRL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_FCB_ROUND_CTRL(a,b) cavm_cprix_cn4ipx_fcb_round_ctrl_t
#define bustype_CAVM_CPRIX_CN4IPX_FCB_ROUND_CTRL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_FCB_ROUND_CTRL(a,b) "CPRIX_CN4IPX_FCB_ROUND_CTRL"
#define busnum_CAVM_CPRIX_CN4IPX_FCB_ROUND_CTRL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_FCB_ROUND_CTRL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_fcb_rp1_buf_en
 *
 * CPRI CONN4 IP RP3-01 RP1 Output Buffer Enable Register
 */
union cavm_cprix_cn4ipx_fcb_rp1_buf_en
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_fcb_rp1_buf_en_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t sclk_oe               : 1;  /**< [  4:  4](R/W) Output enable for signals SCLK_OUT.
                                                                   0 = Output buffer three-stated.
                                                                   1 = Output buffer enabled. */
        uint32_t reserved_1_3          : 3;
        uint32_t fclk_oe               : 1;  /**< [  0:  0](R/W) Output enable for signals FCLK_OUT.
                                                                   0 = Output buffer three-stated.
                                                                   1 = Output buffer enabled. */
#else /* Word 0 - Little Endian */
        uint32_t fclk_oe               : 1;  /**< [  0:  0](R/W) Output enable for signals FCLK_OUT.
                                                                   0 = Output buffer three-stated.
                                                                   1 = Output buffer enabled. */
        uint32_t reserved_1_3          : 3;
        uint32_t sclk_oe               : 1;  /**< [  4:  4](R/W) Output enable for signals SCLK_OUT.
                                                                   0 = Output buffer three-stated.
                                                                   1 = Output buffer enabled. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_fcb_rp1_buf_en_s cn; */
};
typedef union cavm_cprix_cn4ipx_fcb_rp1_buf_en cavm_cprix_cn4ipx_fcb_rp1_buf_en_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_FCB_RP1_BUF_EN(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_FCB_RP1_BUF_EN(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f008ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_FCB_RP1_BUF_EN", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_FCB_RP1_BUF_EN(a,b) cavm_cprix_cn4ipx_fcb_rp1_buf_en_t
#define bustype_CAVM_CPRIX_CN4IPX_FCB_RP1_BUF_EN(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_FCB_RP1_BUF_EN(a,b) "CPRIX_CN4IPX_FCB_RP1_BUF_EN"
#define busnum_CAVM_CPRIX_CN4IPX_FCB_RP1_BUF_EN(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_FCB_RP1_BUF_EN(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_fcb_tr_en
 *
 * CPRI CONN4 IP RP3-01 FCB Message Transmit Enable Register
 */
union cavm_cprix_cn4ipx_fcb_tr_en
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_fcb_tr_en_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t sel_1                 : 1;  /**< [  1:  1](R/W) Enable transmitting generated frame synchronization messages to RP3-01 link 1. */
        uint32_t sel_0                 : 1;  /**< [  0:  0](R/W) Enable transmitting generated frame synchronization messages to RP3-01 link 0. */
#else /* Word 0 - Little Endian */
        uint32_t sel_0                 : 1;  /**< [  0:  0](R/W) Enable transmitting generated frame synchronization messages to RP3-01 link 0. */
        uint32_t sel_1                 : 1;  /**< [  1:  1](R/W) Enable transmitting generated frame synchronization messages to RP3-01 link 1. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_fcb_tr_en_s cn; */
};
typedef union cavm_cprix_cn4ipx_fcb_tr_en cavm_cprix_cn4ipx_fcb_tr_en_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_FCB_TR_EN(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_FCB_TR_EN(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f118ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_FCB_TR_EN", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_FCB_TR_EN(a,b) cavm_cprix_cn4ipx_fcb_tr_en_t
#define bustype_CAVM_CPRIX_CN4IPX_FCB_TR_EN(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_FCB_TR_EN(a,b) "CPRIX_CN4IPX_FCB_TR_EN"
#define busnum_CAVM_CPRIX_CN4IPX_FCB_TR_EN(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_FCB_TR_EN(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_hw_res_en
 *
 * CPRI CONN4 IP RP3-01 Virtual HW Reset Message Reception Enable Register
 */
union cavm_cprix_cn4ipx_hw_res_en
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_hw_res_en_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t sel_1                 : 1;  /**< [  1:  1](R/W) Enable reception of virtual HW reset  messages from RP3-01 link 1.
                                                                   0 = Virtual HW reset message reception disabled.
                                                                   1 = Virtual HW reset message reception enabled. */
        uint32_t sel_0                 : 1;  /**< [  0:  0](R/W) Enable reception of virtual HW reset  messages from RP3-01 link 0. */
#else /* Word 0 - Little Endian */
        uint32_t sel_0                 : 1;  /**< [  0:  0](R/W) Enable reception of virtual HW reset  messages from RP3-01 link 0. */
        uint32_t sel_1                 : 1;  /**< [  1:  1](R/W) Enable reception of virtual HW reset  messages from RP3-01 link 1.
                                                                   0 = Virtual HW reset message reception disabled.
                                                                   1 = Virtual HW reset message reception enabled. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_hw_res_en_s cn; */
};
typedef union cavm_cprix_cn4ipx_hw_res_en cavm_cprix_cn4ipx_hw_res_en_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_HW_RES_EN(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_HW_RES_EN(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f2f4ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_HW_RES_EN", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_HW_RES_EN(a,b) cavm_cprix_cn4ipx_hw_res_en_t
#define bustype_CAVM_CPRIX_CN4IPX_HW_RES_EN(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_HW_RES_EN(a,b) "CPRIX_CN4IPX_HW_RES_EN"
#define busnum_CAVM_CPRIX_CN4IPX_HW_RES_EN(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_HW_RES_EN(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_hw_rst_len
 *
 * CPRI CONN4 IP RP3-01 Virtual HW Reset Pulse Length Register
 */
union cavm_cprix_cn4ipx_hw_rst_len
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_hw_rst_len_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t hwres_len             : 16; /**< [ 15:  0](R/W) Reset pulse length, in 307.2 MHz clock cycles.
                                                                 Pulse length value 0 means HW reset functionality is disabled. */
#else /* Word 0 - Little Endian */
        uint32_t hwres_len             : 16; /**< [ 15:  0](R/W) Reset pulse length, in 307.2 MHz clock cycles.
                                                                 Pulse length value 0 means HW reset functionality is disabled. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_hw_rst_len_s cn; */
};
typedef union cavm_cprix_cn4ipx_hw_rst_len cavm_cprix_cn4ipx_hw_rst_len_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_HW_RST_LEN(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_HW_RST_LEN(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f2f0ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_HW_RST_LEN", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_HW_RST_LEN(a,b) cavm_cprix_cn4ipx_hw_rst_len_t
#define bustype_CAVM_CPRIX_CN4IPX_HW_RST_LEN(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_HW_RST_LEN(a,b) "CPRIX_CN4IPX_HW_RST_LEN"
#define busnum_CAVM_CPRIX_CN4IPX_HW_RST_LEN(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_HW_RST_LEN(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_link_dir
 *
 * CPRI CONN4 IP LINK DIRECTION Register
 */
union cavm_cprix_cn4ipx_link_dir
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_link_dir_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t link_dir_rx_1         : 1;  /**< [  1:  1](R/W) RX direction of RP3 link 1:
                                                                  0 = downlink.
                                                                  1 = uplink. */
        uint32_t link_dir_rx_0         : 1;  /**< [  0:  0](R/W) RX direction of RP3 link 0:
                                                                  0 = downlink.
                                                                  1 = uplink. */
#else /* Word 0 - Little Endian */
        uint32_t link_dir_rx_0         : 1;  /**< [  0:  0](R/W) RX direction of RP3 link 0:
                                                                  0 = downlink.
                                                                  1 = uplink. */
        uint32_t link_dir_rx_1         : 1;  /**< [  1:  1](R/W) RX direction of RP3 link 1:
                                                                  0 = downlink.
                                                                  1 = uplink. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_link_dir_s cn; */
};
typedef union cavm_cprix_cn4ipx_link_dir cavm_cprix_cn4ipx_link_dir_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_LINK_DIR(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_LINK_DIR(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000801000ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_LINK_DIR", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_LINK_DIR(a,b) cavm_cprix_cn4ipx_link_dir_t
#define bustype_CAVM_CPRIX_CN4IPX_LINK_DIR(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_LINK_DIR(a,b) "CPRIX_CN4IPX_LINK_DIR"
#define busnum_CAVM_CPRIX_CN4IPX_LINK_DIR(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_LINK_DIR(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_mcu_int_mskclr_dl
 *
 * CPRI CONN4 IP MCUB RX Interrupt Mask Clear DL Register
 */
union cavm_cprix_cn4ipx_mcu_int_mskclr_dl
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_mcu_int_mskclr_dl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t crc_err               : 1;  /**< [  2:  2](R/W1C/H) Mask Clear for CRC_ERR interrupt:
                                                                     0 = no effect.
                                                                     1 = clear interrupt status. */
        uint32_t msg_ovfl              : 1;  /**< [  1:  1](R/W1C/H) Mask Clear for MSG_OVFL interrupt. */
        uint32_t msg_rcv               : 1;  /**< [  0:  0](R/W1C/H) Mask Clear for MSG_RCV interrupt. */
#else /* Word 0 - Little Endian */
        uint32_t msg_rcv               : 1;  /**< [  0:  0](R/W1C/H) Mask Clear for MSG_RCV interrupt. */
        uint32_t msg_ovfl              : 1;  /**< [  1:  1](R/W1C/H) Mask Clear for MSG_OVFL interrupt. */
        uint32_t crc_err               : 1;  /**< [  2:  2](R/W1C/H) Mask Clear for CRC_ERR interrupt:
                                                                     0 = no effect.
                                                                     1 = clear interrupt status. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_mcu_int_mskclr_dl_s cn; */
};
typedef union cavm_cprix_cn4ipx_mcu_int_mskclr_dl cavm_cprix_cn4ipx_mcu_int_mskclr_dl_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MCU_INT_MSKCLR_DL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MCU_INT_MSKCLR_DL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000801110ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MCU_INT_MSKCLR_DL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MCU_INT_MSKCLR_DL(a,b) cavm_cprix_cn4ipx_mcu_int_mskclr_dl_t
#define bustype_CAVM_CPRIX_CN4IPX_MCU_INT_MSKCLR_DL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MCU_INT_MSKCLR_DL(a,b) "CPRIX_CN4IPX_MCU_INT_MSKCLR_DL"
#define busnum_CAVM_CPRIX_CN4IPX_MCU_INT_MSKCLR_DL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MCU_INT_MSKCLR_DL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_mcu_int_mskclr_ul
 *
 * CPRI CONN4 IP MCUB RX Interrupt Mask Clear UL Register
 */
union cavm_cprix_cn4ipx_mcu_int_mskclr_ul
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_mcu_int_mskclr_ul_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t crc_err               : 1;  /**< [  2:  2](R/W1C/H) Mask Clear for CRC_ERR interrupt:
                                                                     0 = no effect.
                                                                     1 = clear interrupt status. */
        uint32_t msg_ovfl              : 1;  /**< [  1:  1](R/W1C/H) Mask Clear for MSG_OVFL interrupt. */
        uint32_t msg_rcv               : 1;  /**< [  0:  0](R/W1C/H) Mask Clear for MSG_RCV interrupt. */
#else /* Word 0 - Little Endian */
        uint32_t msg_rcv               : 1;  /**< [  0:  0](R/W1C/H) Mask Clear for MSG_RCV interrupt. */
        uint32_t msg_ovfl              : 1;  /**< [  1:  1](R/W1C/H) Mask Clear for MSG_OVFL interrupt. */
        uint32_t crc_err               : 1;  /**< [  2:  2](R/W1C/H) Mask Clear for CRC_ERR interrupt:
                                                                     0 = no effect.
                                                                     1 = clear interrupt status. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_mcu_int_mskclr_ul_s cn; */
};
typedef union cavm_cprix_cn4ipx_mcu_int_mskclr_ul cavm_cprix_cn4ipx_mcu_int_mskclr_ul_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MCU_INT_MSKCLR_UL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MCU_INT_MSKCLR_UL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000801090ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MCU_INT_MSKCLR_UL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MCU_INT_MSKCLR_UL(a,b) cavm_cprix_cn4ipx_mcu_int_mskclr_ul_t
#define bustype_CAVM_CPRIX_CN4IPX_MCU_INT_MSKCLR_UL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MCU_INT_MSKCLR_UL(a,b) "CPRIX_CN4IPX_MCU_INT_MSKCLR_UL"
#define busnum_CAVM_CPRIX_CN4IPX_MCU_INT_MSKCLR_UL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MCU_INT_MSKCLR_UL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_mcu_int_mskset_dl
 *
 * CPRI CONN4 IP MCUB RX Interrupt Mask Set DL Register
 */
union cavm_cprix_cn4ipx_mcu_int_mskset_dl
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_mcu_int_mskset_dl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t crc_err               : 1;  /**< [  2:  2](R/W1S/H) Mask Set for CRC_ERR interrupt:
                                                                     0 = No effect.
                                                                     1 = Interrupt masked. */
        uint32_t msg_ovfl              : 1;  /**< [  1:  1](R/W1S/H) Mask Set for MSG_OVFL interrupt. */
        uint32_t msg_rcv               : 1;  /**< [  0:  0](R/W1S/H) Mask Set for MSG_RCV interrupt. */
#else /* Word 0 - Little Endian */
        uint32_t msg_rcv               : 1;  /**< [  0:  0](R/W1S/H) Mask Set for MSG_RCV interrupt. */
        uint32_t msg_ovfl              : 1;  /**< [  1:  1](R/W1S/H) Mask Set for MSG_OVFL interrupt. */
        uint32_t crc_err               : 1;  /**< [  2:  2](R/W1S/H) Mask Set for CRC_ERR interrupt:
                                                                     0 = No effect.
                                                                     1 = Interrupt masked. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_mcu_int_mskset_dl_s cn; */
};
typedef union cavm_cprix_cn4ipx_mcu_int_mskset_dl cavm_cprix_cn4ipx_mcu_int_mskset_dl_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MCU_INT_MSKSET_DL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MCU_INT_MSKSET_DL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000801114ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MCU_INT_MSKSET_DL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MCU_INT_MSKSET_DL(a,b) cavm_cprix_cn4ipx_mcu_int_mskset_dl_t
#define bustype_CAVM_CPRIX_CN4IPX_MCU_INT_MSKSET_DL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MCU_INT_MSKSET_DL(a,b) "CPRIX_CN4IPX_MCU_INT_MSKSET_DL"
#define busnum_CAVM_CPRIX_CN4IPX_MCU_INT_MSKSET_DL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MCU_INT_MSKSET_DL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_mcu_int_mskset_ul
 *
 * CPRI CONN4 IP MCUB RX Interrupt Mask Set UL Register
 */
union cavm_cprix_cn4ipx_mcu_int_mskset_ul
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_mcu_int_mskset_ul_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t crc_err               : 1;  /**< [  2:  2](R/W1S/H) Mask Set for CRC_ERR interrupt:
                                                                     0 = No effect.
                                                                     1 = Interrupt masked. */
        uint32_t msg_ovfl              : 1;  /**< [  1:  1](R/W1S/H) Mask Set for MSG_OVFL interrupt. */
        uint32_t msg_rcv               : 1;  /**< [  0:  0](R/W1S/H) Mask Set for MSG_RCV interrupt. */
#else /* Word 0 - Little Endian */
        uint32_t msg_rcv               : 1;  /**< [  0:  0](R/W1S/H) Mask Set for MSG_RCV interrupt. */
        uint32_t msg_ovfl              : 1;  /**< [  1:  1](R/W1S/H) Mask Set for MSG_OVFL interrupt. */
        uint32_t crc_err               : 1;  /**< [  2:  2](R/W1S/H) Mask Set for CRC_ERR interrupt:
                                                                     0 = No effect.
                                                                     1 = Interrupt masked. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_mcu_int_mskset_ul_s cn; */
};
typedef union cavm_cprix_cn4ipx_mcu_int_mskset_ul cavm_cprix_cn4ipx_mcu_int_mskset_ul_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MCU_INT_MSKSET_UL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MCU_INT_MSKSET_UL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000801094ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MCU_INT_MSKSET_UL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MCU_INT_MSKSET_UL(a,b) cavm_cprix_cn4ipx_mcu_int_mskset_ul_t
#define bustype_CAVM_CPRIX_CN4IPX_MCU_INT_MSKSET_UL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MCU_INT_MSKSET_UL(a,b) "CPRIX_CN4IPX_MCU_INT_MSKSET_UL"
#define busnum_CAVM_CPRIX_CN4IPX_MCU_INT_MSKSET_UL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MCU_INT_MSKSET_UL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_mcub_link_sel_rx
 *
 * CPRI CONN4 IP MCUB RX LINK SELECTION CONTROL Register
 */
union cavm_cprix_cn4ipx_mcub_link_sel_rx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_mcub_link_sel_rx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t link_sel_rx_1         : 1;  /**< [  1:  1](R/W) RX selection of RP3-01 link 1. */
        uint32_t link_sel_rx_0         : 1;  /**< [  0:  0](R/W) RX selection of RP3-01 link 0. */
#else /* Word 0 - Little Endian */
        uint32_t link_sel_rx_0         : 1;  /**< [  0:  0](R/W) RX selection of RP3-01 link 0. */
        uint32_t link_sel_rx_1         : 1;  /**< [  1:  1](R/W) RX selection of RP3-01 link 1. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_mcub_link_sel_rx_s cn; */
};
typedef union cavm_cprix_cn4ipx_mcub_link_sel_rx cavm_cprix_cn4ipx_mcub_link_sel_rx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_LINK_SEL_RX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_LINK_SEL_RX(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000801048ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MCUB_LINK_SEL_RX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MCUB_LINK_SEL_RX(a,b) cavm_cprix_cn4ipx_mcub_link_sel_rx_t
#define bustype_CAVM_CPRIX_CN4IPX_MCUB_LINK_SEL_RX(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MCUB_LINK_SEL_RX(a,b) "CPRIX_CN4IPX_MCUB_LINK_SEL_RX"
#define busnum_CAVM_CPRIX_CN4IPX_MCUB_LINK_SEL_RX(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MCUB_LINK_SEL_RX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_mcub_link_sel_tx
 *
 * CPRI CONN4 IP TX MCUB LINK SELECTION CONTROL Register
 */
union cavm_cprix_cn4ipx_mcub_link_sel_tx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_mcub_link_sel_tx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t link_sel_tx_1         : 1;  /**< [  1:  1](R/W) TX selection of RP3-01 link 1. */
        uint32_t link_sel_tx_0         : 1;  /**< [  0:  0](R/W) TX selection of RP3-01 link 0. */
#else /* Word 0 - Little Endian */
        uint32_t link_sel_tx_0         : 1;  /**< [  0:  0](R/W) TX selection of RP3-01 link 0. */
        uint32_t link_sel_tx_1         : 1;  /**< [  1:  1](R/W) TX selection of RP3-01 link 1. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_mcub_link_sel_tx_s cn; */
};
typedef union cavm_cprix_cn4ipx_mcub_link_sel_tx cavm_cprix_cn4ipx_mcub_link_sel_tx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_LINK_SEL_TX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_LINK_SEL_TX(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080104cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MCUB_LINK_SEL_TX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MCUB_LINK_SEL_TX(a,b) cavm_cprix_cn4ipx_mcub_link_sel_tx_t
#define bustype_CAVM_CPRIX_CN4IPX_MCUB_LINK_SEL_TX(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MCUB_LINK_SEL_TX(a,b) "CPRIX_CN4IPX_MCUB_LINK_SEL_TX"
#define busnum_CAVM_CPRIX_CN4IPX_MCUB_LINK_SEL_TX(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MCUB_LINK_SEL_TX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_mcub_rx4_tc_dl
 *
 * CPRI CONN4 IP MCU Receive Buffer Data 4 DL Register
 */
union cavm_cprix_cn4ipx_mcub_rx4_tc_dl
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_mcub_rx4_tc_dl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t rx_16                 : 8;  /**< [ 23: 16](RO/H) Byte 16 of the received message. */
        uint32_t rx_17                 : 8;  /**< [ 15:  8](RO/H) Byte 17 of the received message. */
        uint32_t rx_18                 : 8;  /**< [  7:  0](RO/H) Byte 18 of the received message. */
#else /* Word 0 - Little Endian */
        uint32_t rx_18                 : 8;  /**< [  7:  0](RO/H) Byte 18 of the received message. */
        uint32_t rx_17                 : 8;  /**< [ 15:  8](RO/H) Byte 17 of the received message. */
        uint32_t rx_16                 : 8;  /**< [ 23: 16](RO/H) Byte 16 of the received message. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_mcub_rx4_tc_dl_s cn; */
};
typedef union cavm_cprix_cn4ipx_mcub_rx4_tc_dl cavm_cprix_cn4ipx_mcub_rx4_tc_dl_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_RX4_TC_DL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_RX4_TC_DL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000801150ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MCUB_RX4_TC_DL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MCUB_RX4_TC_DL(a,b) cavm_cprix_cn4ipx_mcub_rx4_tc_dl_t
#define bustype_CAVM_CPRIX_CN4IPX_MCUB_RX4_TC_DL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MCUB_RX4_TC_DL(a,b) "CPRIX_CN4IPX_MCUB_RX4_TC_DL"
#define busnum_CAVM_CPRIX_CN4IPX_MCUB_RX4_TC_DL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MCUB_RX4_TC_DL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_mcub_rx4_tc_ul
 *
 * CPRI CONN4 IP MCU Receive Buffer Data 4 UL Register
 */
union cavm_cprix_cn4ipx_mcub_rx4_tc_ul
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_mcub_rx4_tc_ul_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t rx_16                 : 8;  /**< [ 23: 16](RO/H) Byte 16 of the received message. */
        uint32_t rx_17                 : 8;  /**< [ 15:  8](RO/H) Byte 17 of the received message. */
        uint32_t rx_18                 : 8;  /**< [  7:  0](RO/H) Byte 18 of the received message. */
#else /* Word 0 - Little Endian */
        uint32_t rx_18                 : 8;  /**< [  7:  0](RO/H) Byte 18 of the received message. */
        uint32_t rx_17                 : 8;  /**< [ 15:  8](RO/H) Byte 17 of the received message. */
        uint32_t rx_16                 : 8;  /**< [ 23: 16](RO/H) Byte 16 of the received message. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_mcub_rx4_tc_ul_s cn; */
};
typedef union cavm_cprix_cn4ipx_mcub_rx4_tc_ul cavm_cprix_cn4ipx_mcub_rx4_tc_ul_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_RX4_TC_UL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_RX4_TC_UL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x8640008010d0ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MCUB_RX4_TC_UL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MCUB_RX4_TC_UL(a,b) cavm_cprix_cn4ipx_mcub_rx4_tc_ul_t
#define bustype_CAVM_CPRIX_CN4IPX_MCUB_RX4_TC_UL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MCUB_RX4_TC_UL(a,b) "CPRIX_CN4IPX_MCUB_RX4_TC_UL"
#define busnum_CAVM_CPRIX_CN4IPX_MCUB_RX4_TC_UL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MCUB_RX4_TC_UL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_mcub_rx_0_dl
 *
 * CPRI CONN4 IP MCU Receive Buffer Data 0 DL Register
 */
union cavm_cprix_cn4ipx_mcub_rx_0_dl
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_mcub_rx_0_dl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t rx_0                  : 8;  /**< [ 31: 24](RO/H) Byte 0 of the received message. */
        uint32_t rx_1                  : 8;  /**< [ 23: 16](RO/H) Byte 1 of the received message. */
        uint32_t rx_2                  : 8;  /**< [ 15:  8](RO/H) Byte 2 of the received message. */
        uint32_t rx_3                  : 8;  /**< [  7:  0](RO/H) Byte 3 of the received message. */
#else /* Word 0 - Little Endian */
        uint32_t rx_3                  : 8;  /**< [  7:  0](RO/H) Byte 3 of the received message. */
        uint32_t rx_2                  : 8;  /**< [ 15:  8](RO/H) Byte 2 of the received message. */
        uint32_t rx_1                  : 8;  /**< [ 23: 16](RO/H) Byte 1 of the received message. */
        uint32_t rx_0                  : 8;  /**< [ 31: 24](RO/H) Byte 0 of the received message. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_mcub_rx_0_dl_s cn; */
};
typedef union cavm_cprix_cn4ipx_mcub_rx_0_dl cavm_cprix_cn4ipx_mcub_rx_0_dl_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_RX_0_DL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_RX_0_DL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000801140ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MCUB_RX_0_DL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MCUB_RX_0_DL(a,b) cavm_cprix_cn4ipx_mcub_rx_0_dl_t
#define bustype_CAVM_CPRIX_CN4IPX_MCUB_RX_0_DL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MCUB_RX_0_DL(a,b) "CPRIX_CN4IPX_MCUB_RX_0_DL"
#define busnum_CAVM_CPRIX_CN4IPX_MCUB_RX_0_DL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MCUB_RX_0_DL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_mcub_rx_0_ul
 *
 * CPRI CONN4 IP MCU Receive Buffer Data 0 UL Register
 */
union cavm_cprix_cn4ipx_mcub_rx_0_ul
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_mcub_rx_0_ul_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t rx_0                  : 8;  /**< [ 31: 24](RO/H) Byte 0 of the received message. */
        uint32_t rx_1                  : 8;  /**< [ 23: 16](RO/H) Byte 1 of the received message. */
        uint32_t rx_2                  : 8;  /**< [ 15:  8](RO/H) Byte 2 of the received message. */
        uint32_t rx_3                  : 8;  /**< [  7:  0](RO/H) Byte 3 of the received message. */
#else /* Word 0 - Little Endian */
        uint32_t rx_3                  : 8;  /**< [  7:  0](RO/H) Byte 3 of the received message. */
        uint32_t rx_2                  : 8;  /**< [ 15:  8](RO/H) Byte 2 of the received message. */
        uint32_t rx_1                  : 8;  /**< [ 23: 16](RO/H) Byte 1 of the received message. */
        uint32_t rx_0                  : 8;  /**< [ 31: 24](RO/H) Byte 0 of the received message. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_mcub_rx_0_ul_s cn; */
};
typedef union cavm_cprix_cn4ipx_mcub_rx_0_ul cavm_cprix_cn4ipx_mcub_rx_0_ul_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_RX_0_UL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_RX_0_UL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x8640008010c0ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MCUB_RX_0_UL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MCUB_RX_0_UL(a,b) cavm_cprix_cn4ipx_mcub_rx_0_ul_t
#define bustype_CAVM_CPRIX_CN4IPX_MCUB_RX_0_UL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MCUB_RX_0_UL(a,b) "CPRIX_CN4IPX_MCUB_RX_0_UL"
#define busnum_CAVM_CPRIX_CN4IPX_MCUB_RX_0_UL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MCUB_RX_0_UL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_mcub_rx_1_dl
 *
 * CPRI CONN4 IP MCU Receive Buffer Data 1 DL Register
 */
union cavm_cprix_cn4ipx_mcub_rx_1_dl
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_mcub_rx_1_dl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t rx_4                  : 8;  /**< [ 31: 24](RO/H) Byte 4 of the received message. */
        uint32_t rx_5                  : 8;  /**< [ 23: 16](RO/H) Byte 5 of the received message. */
        uint32_t rx_6                  : 8;  /**< [ 15:  8](RO/H) Byte 6 of the received message. */
        uint32_t rx_7                  : 8;  /**< [  7:  0](RO/H) Byte 7 of the received message. */
#else /* Word 0 - Little Endian */
        uint32_t rx_7                  : 8;  /**< [  7:  0](RO/H) Byte 7 of the received message. */
        uint32_t rx_6                  : 8;  /**< [ 15:  8](RO/H) Byte 6 of the received message. */
        uint32_t rx_5                  : 8;  /**< [ 23: 16](RO/H) Byte 5 of the received message. */
        uint32_t rx_4                  : 8;  /**< [ 31: 24](RO/H) Byte 4 of the received message. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_mcub_rx_1_dl_s cn; */
};
typedef union cavm_cprix_cn4ipx_mcub_rx_1_dl cavm_cprix_cn4ipx_mcub_rx_1_dl_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_RX_1_DL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_RX_1_DL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000801144ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MCUB_RX_1_DL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MCUB_RX_1_DL(a,b) cavm_cprix_cn4ipx_mcub_rx_1_dl_t
#define bustype_CAVM_CPRIX_CN4IPX_MCUB_RX_1_DL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MCUB_RX_1_DL(a,b) "CPRIX_CN4IPX_MCUB_RX_1_DL"
#define busnum_CAVM_CPRIX_CN4IPX_MCUB_RX_1_DL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MCUB_RX_1_DL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_mcub_rx_1_ul
 *
 * CPRI CONN4 IP MCU Receive Buffer Data 1 UL Register
 */
union cavm_cprix_cn4ipx_mcub_rx_1_ul
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_mcub_rx_1_ul_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t rx_4                  : 8;  /**< [ 31: 24](RO/H) Byte 4 of the received message. */
        uint32_t rx_5                  : 8;  /**< [ 23: 16](RO/H) Byte 5 of the received message. */
        uint32_t rx_6                  : 8;  /**< [ 15:  8](RO/H) Byte 6 of the received message. */
        uint32_t rx_7                  : 8;  /**< [  7:  0](RO/H) Byte 7 of the received message. */
#else /* Word 0 - Little Endian */
        uint32_t rx_7                  : 8;  /**< [  7:  0](RO/H) Byte 7 of the received message. */
        uint32_t rx_6                  : 8;  /**< [ 15:  8](RO/H) Byte 6 of the received message. */
        uint32_t rx_5                  : 8;  /**< [ 23: 16](RO/H) Byte 5 of the received message. */
        uint32_t rx_4                  : 8;  /**< [ 31: 24](RO/H) Byte 4 of the received message. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_mcub_rx_1_ul_s cn; */
};
typedef union cavm_cprix_cn4ipx_mcub_rx_1_ul cavm_cprix_cn4ipx_mcub_rx_1_ul_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_RX_1_UL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_RX_1_UL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x8640008010c4ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MCUB_RX_1_UL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MCUB_RX_1_UL(a,b) cavm_cprix_cn4ipx_mcub_rx_1_ul_t
#define bustype_CAVM_CPRIX_CN4IPX_MCUB_RX_1_UL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MCUB_RX_1_UL(a,b) "CPRIX_CN4IPX_MCUB_RX_1_UL"
#define busnum_CAVM_CPRIX_CN4IPX_MCUB_RX_1_UL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MCUB_RX_1_UL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_mcub_rx_2_dl
 *
 * CPRI CONN4 IP MCU Receive Buffer Data 2 DL Register
 */
union cavm_cprix_cn4ipx_mcub_rx_2_dl
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_mcub_rx_2_dl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t rx_8                  : 8;  /**< [ 31: 24](RO/H) Byte 8 of the received message. */
        uint32_t rx_9                  : 8;  /**< [ 23: 16](RO/H) Byte 9 of the received message. */
        uint32_t rx_10                 : 8;  /**< [ 15:  8](RO/H) Byte 10 of the received message. */
        uint32_t rx_11                 : 8;  /**< [  7:  0](RO/H) Byte 11 of the received message. */
#else /* Word 0 - Little Endian */
        uint32_t rx_11                 : 8;  /**< [  7:  0](RO/H) Byte 11 of the received message. */
        uint32_t rx_10                 : 8;  /**< [ 15:  8](RO/H) Byte 10 of the received message. */
        uint32_t rx_9                  : 8;  /**< [ 23: 16](RO/H) Byte 9 of the received message. */
        uint32_t rx_8                  : 8;  /**< [ 31: 24](RO/H) Byte 8 of the received message. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_mcub_rx_2_dl_s cn; */
};
typedef union cavm_cprix_cn4ipx_mcub_rx_2_dl cavm_cprix_cn4ipx_mcub_rx_2_dl_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_RX_2_DL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_RX_2_DL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000801148ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MCUB_RX_2_DL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MCUB_RX_2_DL(a,b) cavm_cprix_cn4ipx_mcub_rx_2_dl_t
#define bustype_CAVM_CPRIX_CN4IPX_MCUB_RX_2_DL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MCUB_RX_2_DL(a,b) "CPRIX_CN4IPX_MCUB_RX_2_DL"
#define busnum_CAVM_CPRIX_CN4IPX_MCUB_RX_2_DL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MCUB_RX_2_DL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_mcub_rx_2_ul
 *
 * CPRI CONN4 IP MCU Receive Buffer Data 2 UL Register
 */
union cavm_cprix_cn4ipx_mcub_rx_2_ul
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_mcub_rx_2_ul_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t rx_8                  : 8;  /**< [ 31: 24](RO/H) Byte 8 of the received message. */
        uint32_t rx_9                  : 8;  /**< [ 23: 16](RO/H) Byte 9 of the received message. */
        uint32_t rx_10                 : 8;  /**< [ 15:  8](RO/H) Byte 10 of the received message. */
        uint32_t rx_11                 : 8;  /**< [  7:  0](RO/H) Byte 11 of the received message. */
#else /* Word 0 - Little Endian */
        uint32_t rx_11                 : 8;  /**< [  7:  0](RO/H) Byte 11 of the received message. */
        uint32_t rx_10                 : 8;  /**< [ 15:  8](RO/H) Byte 10 of the received message. */
        uint32_t rx_9                  : 8;  /**< [ 23: 16](RO/H) Byte 9 of the received message. */
        uint32_t rx_8                  : 8;  /**< [ 31: 24](RO/H) Byte 8 of the received message. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_mcub_rx_2_ul_s cn; */
};
typedef union cavm_cprix_cn4ipx_mcub_rx_2_ul cavm_cprix_cn4ipx_mcub_rx_2_ul_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_RX_2_UL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_RX_2_UL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x8640008010c8ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MCUB_RX_2_UL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MCUB_RX_2_UL(a,b) cavm_cprix_cn4ipx_mcub_rx_2_ul_t
#define bustype_CAVM_CPRIX_CN4IPX_MCUB_RX_2_UL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MCUB_RX_2_UL(a,b) "CPRIX_CN4IPX_MCUB_RX_2_UL"
#define busnum_CAVM_CPRIX_CN4IPX_MCUB_RX_2_UL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MCUB_RX_2_UL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_mcub_rx_3_dl
 *
 * CPRI CONN4 IP MCU Receive Buffer Data 3 DL Register
 */
union cavm_cprix_cn4ipx_mcub_rx_3_dl
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_mcub_rx_3_dl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t rx_12                 : 8;  /**< [ 31: 24](RO/H) Byte 12 of the received message. */
        uint32_t rx_13                 : 8;  /**< [ 23: 16](RO/H) Byte 13 of the received message. */
        uint32_t rx_14                 : 8;  /**< [ 15:  8](RO/H) Byte 14 of the received message. */
        uint32_t rx_15                 : 8;  /**< [  7:  0](RO/H) Byte 15 of the received message. */
#else /* Word 0 - Little Endian */
        uint32_t rx_15                 : 8;  /**< [  7:  0](RO/H) Byte 15 of the received message. */
        uint32_t rx_14                 : 8;  /**< [ 15:  8](RO/H) Byte 14 of the received message. */
        uint32_t rx_13                 : 8;  /**< [ 23: 16](RO/H) Byte 13 of the received message. */
        uint32_t rx_12                 : 8;  /**< [ 31: 24](RO/H) Byte 12 of the received message. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_mcub_rx_3_dl_s cn; */
};
typedef union cavm_cprix_cn4ipx_mcub_rx_3_dl cavm_cprix_cn4ipx_mcub_rx_3_dl_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_RX_3_DL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_RX_3_DL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080114cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MCUB_RX_3_DL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MCUB_RX_3_DL(a,b) cavm_cprix_cn4ipx_mcub_rx_3_dl_t
#define bustype_CAVM_CPRIX_CN4IPX_MCUB_RX_3_DL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MCUB_RX_3_DL(a,b) "CPRIX_CN4IPX_MCUB_RX_3_DL"
#define busnum_CAVM_CPRIX_CN4IPX_MCUB_RX_3_DL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MCUB_RX_3_DL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_mcub_rx_3_ul
 *
 * CPRI CONN4 IP MCU Receive Buffer Data 3 UL Register
 */
union cavm_cprix_cn4ipx_mcub_rx_3_ul
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_mcub_rx_3_ul_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t rx_12                 : 8;  /**< [ 31: 24](RO/H) Byte 12 of the received message. */
        uint32_t rx_13                 : 8;  /**< [ 23: 16](RO/H) Byte 13 of the received message. */
        uint32_t rx_14                 : 8;  /**< [ 15:  8](RO/H) Byte 14 of the received message. */
        uint32_t rx_15                 : 8;  /**< [  7:  0](RO/H) Byte 15 of the received message. */
#else /* Word 0 - Little Endian */
        uint32_t rx_15                 : 8;  /**< [  7:  0](RO/H) Byte 15 of the received message. */
        uint32_t rx_14                 : 8;  /**< [ 15:  8](RO/H) Byte 14 of the received message. */
        uint32_t rx_13                 : 8;  /**< [ 23: 16](RO/H) Byte 13 of the received message. */
        uint32_t rx_12                 : 8;  /**< [ 31: 24](RO/H) Byte 12 of the received message. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_mcub_rx_3_ul_s cn; */
};
typedef union cavm_cprix_cn4ipx_mcub_rx_3_ul cavm_cprix_cn4ipx_mcub_rx_3_ul_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_RX_3_UL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_RX_3_UL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x8640008010ccll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MCUB_RX_3_UL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MCUB_RX_3_UL(a,b) cavm_cprix_cn4ipx_mcub_rx_3_ul_t
#define bustype_CAVM_CPRIX_CN4IPX_MCUB_RX_3_UL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MCUB_RX_3_UL(a,b) "CPRIX_CN4IPX_MCUB_RX_3_UL"
#define busnum_CAVM_CPRIX_CN4IPX_MCUB_RX_3_UL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MCUB_RX_3_UL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_mcub_rxc
 *
 * CPRI CONN4 IP MCUB RECEPTION INTERRUPT CTRL Register
 */
union cavm_cprix_cn4ipx_mcub_rxc
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_mcub_rxc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t int_ctrl_ul           : 1;  /**< [  1:  1](R/W) Interrupt control for DL Buffer:
                                                                   0 = Receive interrupt generated from every received message.
                                                                   1 = Receive interrupt generated only when buffer status changes from empty. */
        uint32_t int_ctrl_dl           : 1;  /**< [  0:  0](R/W) Interrupt control for DL Buffer. */
#else /* Word 0 - Little Endian */
        uint32_t int_ctrl_dl           : 1;  /**< [  0:  0](R/W) Interrupt control for DL Buffer. */
        uint32_t int_ctrl_ul           : 1;  /**< [  1:  1](R/W) Interrupt control for DL Buffer:
                                                                   0 = Receive interrupt generated from every received message.
                                                                   1 = Receive interrupt generated only when buffer status changes from empty. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_mcub_rxc_s cn; */
};
typedef union cavm_cprix_cn4ipx_mcub_rxc cavm_cprix_cn4ipx_mcub_rxc_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_RXC(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_RXC(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000801040ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MCUB_RXC", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MCUB_RXC(a,b) cavm_cprix_cn4ipx_mcub_rxc_t
#define bustype_CAVM_CPRIX_CN4IPX_MCUB_RXC(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MCUB_RXC(a,b) "CPRIX_CN4IPX_MCUB_RXC"
#define busnum_CAVM_CPRIX_CN4IPX_MCUB_RXC(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MCUB_RXC(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_mcub_rxint_msk_dl
 *
 * CPRI CONN4 IP MCUB RX Interrupt Mask DL Register
 */
union cavm_cprix_cn4ipx_mcub_rxint_msk_dl
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_mcub_rxint_msk_dl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t crc_err               : 1;  /**< [  2:  2](R/W) Mask for CRC_ERR interrupt:
                                                                     0 = Interrupt not masked.
                                                                     1 = Interrupt masked. */
        uint32_t msg_ovfl              : 1;  /**< [  1:  1](R/W) Mask for MSG_OVFL interrupt. */
        uint32_t msg_rcv               : 1;  /**< [  0:  0](R/W) Mask for MSG_RCV interrupt. */
#else /* Word 0 - Little Endian */
        uint32_t msg_rcv               : 1;  /**< [  0:  0](R/W) Mask for MSG_RCV interrupt. */
        uint32_t msg_ovfl              : 1;  /**< [  1:  1](R/W) Mask for MSG_OVFL interrupt. */
        uint32_t crc_err               : 1;  /**< [  2:  2](R/W) Mask for CRC_ERR interrupt:
                                                                     0 = Interrupt not masked.
                                                                     1 = Interrupt masked. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_mcub_rxint_msk_dl_s cn; */
};
typedef union cavm_cprix_cn4ipx_mcub_rxint_msk_dl cavm_cprix_cn4ipx_mcub_rxint_msk_dl_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_RXINT_MSK_DL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_RXINT_MSK_DL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080110cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MCUB_RXINT_MSK_DL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MCUB_RXINT_MSK_DL(a,b) cavm_cprix_cn4ipx_mcub_rxint_msk_dl_t
#define bustype_CAVM_CPRIX_CN4IPX_MCUB_RXINT_MSK_DL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MCUB_RXINT_MSK_DL(a,b) "CPRIX_CN4IPX_MCUB_RXINT_MSK_DL"
#define busnum_CAVM_CPRIX_CN4IPX_MCUB_RXINT_MSK_DL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MCUB_RXINT_MSK_DL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_mcub_rxint_msk_ul
 *
 * CPRI CONN4 IP MCUB RX Interrupt Mask UL Register
 */
union cavm_cprix_cn4ipx_mcub_rxint_msk_ul
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_mcub_rxint_msk_ul_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t crc_err               : 1;  /**< [  2:  2](R/W) Mask for CRC_ERR interrupt:
                                                                     0 = Interrupt not masked.
                                                                     1 = Interrupt masked. */
        uint32_t msg_ovfl              : 1;  /**< [  1:  1](R/W) Mask for MSG_OVFL interrupt. */
        uint32_t msg_rcv               : 1;  /**< [  0:  0](R/W) Mask for MSG_RCV interrupt. */
#else /* Word 0 - Little Endian */
        uint32_t msg_rcv               : 1;  /**< [  0:  0](R/W) Mask for MSG_RCV interrupt. */
        uint32_t msg_ovfl              : 1;  /**< [  1:  1](R/W) Mask for MSG_OVFL interrupt. */
        uint32_t crc_err               : 1;  /**< [  2:  2](R/W) Mask for CRC_ERR interrupt:
                                                                     0 = Interrupt not masked.
                                                                     1 = Interrupt masked. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_mcub_rxint_msk_ul_s cn; */
};
typedef union cavm_cprix_cn4ipx_mcub_rxint_msk_ul cavm_cprix_cn4ipx_mcub_rxint_msk_ul_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_RXINT_MSK_UL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_RXINT_MSK_UL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080108cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MCUB_RXINT_MSK_UL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MCUB_RXINT_MSK_UL(a,b) cavm_cprix_cn4ipx_mcub_rxint_msk_ul_t
#define bustype_CAVM_CPRIX_CN4IPX_MCUB_RXINT_MSK_UL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MCUB_RXINT_MSK_UL(a,b) "CPRIX_CN4IPX_MCUB_RXINT_MSK_UL"
#define busnum_CAVM_CPRIX_CN4IPX_MCUB_RXINT_MSK_UL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MCUB_RXINT_MSK_UL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_mcub_rxintclr_dl
 *
 * CPRI CONN4 IP MCUB RX Interrupt Clear DL Register
 */
union cavm_cprix_cn4ipx_mcub_rxintclr_dl
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_mcub_rxintclr_dl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t crc_err               : 1;  /**< [  2:  2](R/W1C/H) Clear for CRC_ERR interrupt:
                                                                     0 = no effect.
                                                                     1 = clear interrupt status. */
        uint32_t msg_ovfl              : 1;  /**< [  1:  1](R/W1C/H) Clear for MSG_OVFL interrupt. */
        uint32_t msg_rcv               : 1;  /**< [  0:  0](R/W1C/H) Clear for MSG_RCV interrupt. */
#else /* Word 0 - Little Endian */
        uint32_t msg_rcv               : 1;  /**< [  0:  0](R/W1C/H) Clear for MSG_RCV interrupt. */
        uint32_t msg_ovfl              : 1;  /**< [  1:  1](R/W1C/H) Clear for MSG_OVFL interrupt. */
        uint32_t crc_err               : 1;  /**< [  2:  2](R/W1C/H) Clear for CRC_ERR interrupt:
                                                                     0 = no effect.
                                                                     1 = clear interrupt status. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_mcub_rxintclr_dl_s cn; */
};
typedef union cavm_cprix_cn4ipx_mcub_rxintclr_dl cavm_cprix_cn4ipx_mcub_rxintclr_dl_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_RXINTCLR_DL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_RXINTCLR_DL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000801104ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MCUB_RXINTCLR_DL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MCUB_RXINTCLR_DL(a,b) cavm_cprix_cn4ipx_mcub_rxintclr_dl_t
#define bustype_CAVM_CPRIX_CN4IPX_MCUB_RXINTCLR_DL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MCUB_RXINTCLR_DL(a,b) "CPRIX_CN4IPX_MCUB_RXINTCLR_DL"
#define busnum_CAVM_CPRIX_CN4IPX_MCUB_RXINTCLR_DL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MCUB_RXINTCLR_DL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_mcub_rxintclr_ul
 *
 * CPRI CONN4 IP MCUB RX Interrupt Clear UL Register
 */
union cavm_cprix_cn4ipx_mcub_rxintclr_ul
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_mcub_rxintclr_ul_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t crc_err               : 1;  /**< [  2:  2](R/W1C/H) Clear for CRC_ERR interrupt:
                                                                     0 = no effect.
                                                                     1 = clear interrupt status. */
        uint32_t msg_ovfl              : 1;  /**< [  1:  1](R/W1C/H) Clear for MSG_OVFL interrupt. */
        uint32_t msg_rcv               : 1;  /**< [  0:  0](R/W1C/H) Clear for MSG_RCV interrupt. */
#else /* Word 0 - Little Endian */
        uint32_t msg_rcv               : 1;  /**< [  0:  0](R/W1C/H) Clear for MSG_RCV interrupt. */
        uint32_t msg_ovfl              : 1;  /**< [  1:  1](R/W1C/H) Clear for MSG_OVFL interrupt. */
        uint32_t crc_err               : 1;  /**< [  2:  2](R/W1C/H) Clear for CRC_ERR interrupt:
                                                                     0 = no effect.
                                                                     1 = clear interrupt status. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_mcub_rxintclr_ul_s cn; */
};
typedef union cavm_cprix_cn4ipx_mcub_rxintclr_ul cavm_cprix_cn4ipx_mcub_rxintclr_ul_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_RXINTCLR_UL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_RXINTCLR_UL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000801084ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MCUB_RXINTCLR_UL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MCUB_RXINTCLR_UL(a,b) cavm_cprix_cn4ipx_mcub_rxintclr_ul_t
#define bustype_CAVM_CPRIX_CN4IPX_MCUB_RXINTCLR_UL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MCUB_RXINTCLR_UL(a,b) "CPRIX_CN4IPX_MCUB_RXINTCLR_UL"
#define busnum_CAVM_CPRIX_CN4IPX_MCUB_RXINTCLR_UL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MCUB_RXINTCLR_UL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_mcub_rxintset_dl
 *
 * CPRI CONN4 IP MCUB RX Interrupt Event Set DL Register
 */
union cavm_cprix_cn4ipx_mcub_rxintset_dl
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_mcub_rxintset_dl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t crc_err               : 1;  /**< [  2:  2](R/W1S/H) Set for CRC_ERR interrupt:
                                                                     0 = no effect.
                                                                     1 = set interrupt status. */
        uint32_t msg_ovfl              : 1;  /**< [  1:  1](R/W1S/H) Set for MSG_OVFL interrupt. */
        uint32_t msg_rcv               : 1;  /**< [  0:  0](R/W1S/H) Set for MSG_RCV interrupt. */
#else /* Word 0 - Little Endian */
        uint32_t msg_rcv               : 1;  /**< [  0:  0](R/W1S/H) Set for MSG_RCV interrupt. */
        uint32_t msg_ovfl              : 1;  /**< [  1:  1](R/W1S/H) Set for MSG_OVFL interrupt. */
        uint32_t crc_err               : 1;  /**< [  2:  2](R/W1S/H) Set for CRC_ERR interrupt:
                                                                     0 = no effect.
                                                                     1 = set interrupt status. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_mcub_rxintset_dl_s cn; */
};
typedef union cavm_cprix_cn4ipx_mcub_rxintset_dl cavm_cprix_cn4ipx_mcub_rxintset_dl_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_RXINTSET_DL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_RXINTSET_DL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000801108ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MCUB_RXINTSET_DL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MCUB_RXINTSET_DL(a,b) cavm_cprix_cn4ipx_mcub_rxintset_dl_t
#define bustype_CAVM_CPRIX_CN4IPX_MCUB_RXINTSET_DL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MCUB_RXINTSET_DL(a,b) "CPRIX_CN4IPX_MCUB_RXINTSET_DL"
#define busnum_CAVM_CPRIX_CN4IPX_MCUB_RXINTSET_DL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MCUB_RXINTSET_DL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_mcub_rxintset_ul
 *
 * CPRI CONN4 IP MCUB RX Interrupt Event Set UL Register
 */
union cavm_cprix_cn4ipx_mcub_rxintset_ul
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_mcub_rxintset_ul_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t crc_err               : 1;  /**< [  2:  2](R/W1S/H) Set for CRC_ERR interrupt:
                                                                     0 = no effect.
                                                                     1 = set interrupt status. */
        uint32_t msg_ovfl              : 1;  /**< [  1:  1](R/W1S/H) Set for MSG_OVFL interrupt. */
        uint32_t msg_rcv               : 1;  /**< [  0:  0](R/W1S/H) Set for MSG_RCV interrupt. */
#else /* Word 0 - Little Endian */
        uint32_t msg_rcv               : 1;  /**< [  0:  0](R/W1S/H) Set for MSG_RCV interrupt. */
        uint32_t msg_ovfl              : 1;  /**< [  1:  1](R/W1S/H) Set for MSG_OVFL interrupt. */
        uint32_t crc_err               : 1;  /**< [  2:  2](R/W1S/H) Set for CRC_ERR interrupt:
                                                                     0 = no effect.
                                                                     1 = set interrupt status. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_mcub_rxintset_ul_s cn; */
};
typedef union cavm_cprix_cn4ipx_mcub_rxintset_ul cavm_cprix_cn4ipx_mcub_rxintset_ul_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_RXINTSET_UL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_RXINTSET_UL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000801088ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MCUB_RXINTSET_UL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MCUB_RXINTSET_UL(a,b) cavm_cprix_cn4ipx_mcub_rxintset_ul_t
#define bustype_CAVM_CPRIX_CN4IPX_MCUB_RXINTSET_UL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MCUB_RXINTSET_UL(a,b) "CPRIX_CN4IPX_MCUB_RXINTSET_UL"
#define busnum_CAVM_CPRIX_CN4IPX_MCUB_RXINTSET_UL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MCUB_RXINTSET_UL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_mcub_rxintsts_dl
 *
 * CPRI CONN4 IP MCUB RX Interrupt Status DL Register
 */
union cavm_cprix_cn4ipx_mcub_rxintsts_dl
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_mcub_rxintsts_dl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_12_31        : 20;
        uint32_t num_msg               : 3;  /**< [ 11:  9](RO/H) Number of messages in the buffer FIFO. Can get values from 0 to 4. */
        uint32_t reserved_6_8          : 3;
        uint32_t msg_link              : 2;  /**< [  5:  4](RO/H) Link number, where the oldest unread message was received from:
                                                                   0 = RP3 link 0.
                                                                   1 = RP3 link 1. */
        uint32_t reserved_3            : 1;
        uint32_t crc_err               : 1;  /**< [  2:  2](RO/H) CRC error in the oldest unread received message:
                                                                   0 = No CRC error in the received message.
                                                                   1 = CRC error in the received message. */
        uint32_t msg_ovfl              : 1;  /**< [  1:  1](RO/H) Message buffer overflow (message lost because of FIFO full or messages in adjacent slots):
                                                                   0 = No overflow.
                                                                   1 = Overflow. */
        uint32_t msg_rcv               : 1;  /**< [  0:  0](RO/H) Message received.
                                                                   0 = No new message received.
                                                                   1 = New message received. */
#else /* Word 0 - Little Endian */
        uint32_t msg_rcv               : 1;  /**< [  0:  0](RO/H) Message received.
                                                                   0 = No new message received.
                                                                   1 = New message received. */
        uint32_t msg_ovfl              : 1;  /**< [  1:  1](RO/H) Message buffer overflow (message lost because of FIFO full or messages in adjacent slots):
                                                                   0 = No overflow.
                                                                   1 = Overflow. */
        uint32_t crc_err               : 1;  /**< [  2:  2](RO/H) CRC error in the oldest unread received message:
                                                                   0 = No CRC error in the received message.
                                                                   1 = CRC error in the received message. */
        uint32_t reserved_3            : 1;
        uint32_t msg_link              : 2;  /**< [  5:  4](RO/H) Link number, where the oldest unread message was received from:
                                                                   0 = RP3 link 0.
                                                                   1 = RP3 link 1. */
        uint32_t reserved_6_8          : 3;
        uint32_t num_msg               : 3;  /**< [ 11:  9](RO/H) Number of messages in the buffer FIFO. Can get values from 0 to 4. */
        uint32_t reserved_12_31        : 20;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_mcub_rxintsts_dl_s cn; */
};
typedef union cavm_cprix_cn4ipx_mcub_rxintsts_dl cavm_cprix_cn4ipx_mcub_rxintsts_dl_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_RXINTSTS_DL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_RXINTSTS_DL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000801100ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MCUB_RXINTSTS_DL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MCUB_RXINTSTS_DL(a,b) cavm_cprix_cn4ipx_mcub_rxintsts_dl_t
#define bustype_CAVM_CPRIX_CN4IPX_MCUB_RXINTSTS_DL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MCUB_RXINTSTS_DL(a,b) "CPRIX_CN4IPX_MCUB_RXINTSTS_DL"
#define busnum_CAVM_CPRIX_CN4IPX_MCUB_RXINTSTS_DL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MCUB_RXINTSTS_DL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_mcub_rxintsts_ul
 *
 * CPRI CONN4 IP MCUB RX Interrupt Status UL Register
 */
union cavm_cprix_cn4ipx_mcub_rxintsts_ul
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_mcub_rxintsts_ul_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_12_31        : 20;
        uint32_t num_msg               : 3;  /**< [ 11:  9](RO/H) Number of messages in the buffer FIFO. Can get values from 0 to 4. */
        uint32_t reserved_6_8          : 3;
        uint32_t msg_link              : 2;  /**< [  5:  4](RO/H) Link number, where the oldest unread message was received from:
                                                                   0 = RP3 link 0.
                                                                   1 = RP3 link 1. */
        uint32_t reserved_3            : 1;
        uint32_t crc_err               : 1;  /**< [  2:  2](RO/H) CRC error in the oldest unread received message:
                                                                   0 = No CRC error in the received message.
                                                                   1 = CRC error in the received message. */
        uint32_t msg_ovfl              : 1;  /**< [  1:  1](RO/H) Message buffer overflow (message lost because of FIFO full or messages in adjacent slots):
                                                                   0 = No overflow.
                                                                   1 = Overflow. */
        uint32_t msg_rcv               : 1;  /**< [  0:  0](RO/H) Message received:
                                                                   0 = No new message received.
                                                                   1 = New message received. */
#else /* Word 0 - Little Endian */
        uint32_t msg_rcv               : 1;  /**< [  0:  0](RO/H) Message received:
                                                                   0 = No new message received.
                                                                   1 = New message received. */
        uint32_t msg_ovfl              : 1;  /**< [  1:  1](RO/H) Message buffer overflow (message lost because of FIFO full or messages in adjacent slots):
                                                                   0 = No overflow.
                                                                   1 = Overflow. */
        uint32_t crc_err               : 1;  /**< [  2:  2](RO/H) CRC error in the oldest unread received message:
                                                                   0 = No CRC error in the received message.
                                                                   1 = CRC error in the received message. */
        uint32_t reserved_3            : 1;
        uint32_t msg_link              : 2;  /**< [  5:  4](RO/H) Link number, where the oldest unread message was received from:
                                                                   0 = RP3 link 0.
                                                                   1 = RP3 link 1. */
        uint32_t reserved_6_8          : 3;
        uint32_t num_msg               : 3;  /**< [ 11:  9](RO/H) Number of messages in the buffer FIFO. Can get values from 0 to 4. */
        uint32_t reserved_12_31        : 20;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_mcub_rxintsts_ul_s cn; */
};
typedef union cavm_cprix_cn4ipx_mcub_rxintsts_ul cavm_cprix_cn4ipx_mcub_rxintsts_ul_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_RXINTSTS_UL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_RXINTSTS_UL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000801080ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MCUB_RXINTSTS_UL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MCUB_RXINTSTS_UL(a,b) cavm_cprix_cn4ipx_mcub_rxintsts_ul_t
#define bustype_CAVM_CPRIX_CN4IPX_MCUB_RXINTSTS_UL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MCUB_RXINTSTS_UL(a,b) "CPRIX_CN4IPX_MCUB_RXINTSTS_UL"
#define busnum_CAVM_CPRIX_CN4IPX_MCUB_RXINTSTS_UL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MCUB_RXINTSTS_UL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_mcub_tx_0_dl
 *
 * CPRI CONN4 IP MCU Transmit Buffer Data 0 DL Register
 */
union cavm_cprix_cn4ipx_mcub_tx_0_dl
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_mcub_tx_0_dl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t tx_0                  : 8;  /**< [ 31: 24](R/W) Byte 0 of the transmit message. */
        uint32_t tx_1                  : 8;  /**< [ 23: 16](R/W) Byte 1 of the transmit message. */
        uint32_t tx_2                  : 8;  /**< [ 15:  8](R/W) Byte 2 of the transmit message. */
        uint32_t tx_3                  : 8;  /**< [  7:  0](R/W) Byte 3 of the transmit message. */
#else /* Word 0 - Little Endian */
        uint32_t tx_3                  : 8;  /**< [  7:  0](R/W) Byte 3 of the transmit message. */
        uint32_t tx_2                  : 8;  /**< [ 15:  8](R/W) Byte 2 of the transmit message. */
        uint32_t tx_1                  : 8;  /**< [ 23: 16](R/W) Byte 1 of the transmit message. */
        uint32_t tx_0                  : 8;  /**< [ 31: 24](R/W) Byte 0 of the transmit message. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_mcub_tx_0_dl_s cn; */
};
typedef union cavm_cprix_cn4ipx_mcub_tx_0_dl cavm_cprix_cn4ipx_mcub_tx_0_dl_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_TX_0_DL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_TX_0_DL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000801158ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MCUB_TX_0_DL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MCUB_TX_0_DL(a,b) cavm_cprix_cn4ipx_mcub_tx_0_dl_t
#define bustype_CAVM_CPRIX_CN4IPX_MCUB_TX_0_DL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MCUB_TX_0_DL(a,b) "CPRIX_CN4IPX_MCUB_TX_0_DL"
#define busnum_CAVM_CPRIX_CN4IPX_MCUB_TX_0_DL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MCUB_TX_0_DL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_mcub_tx_0_ul
 *
 * CPRI CONN4 IP MCU Transmit Buffer Data 0 UL Register
 */
union cavm_cprix_cn4ipx_mcub_tx_0_ul
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_mcub_tx_0_ul_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t tx_0                  : 8;  /**< [ 31: 24](R/W) Byte 0 of the transmit message. */
        uint32_t tx_1                  : 8;  /**< [ 23: 16](R/W) Byte 1 of the transmit message. */
        uint32_t tx_2                  : 8;  /**< [ 15:  8](R/W) Byte 2 of the transmit message. */
        uint32_t tx_3                  : 8;  /**< [  7:  0](R/W) Byte 3 of the transmit message. */
#else /* Word 0 - Little Endian */
        uint32_t tx_3                  : 8;  /**< [  7:  0](R/W) Byte 3 of the transmit message. */
        uint32_t tx_2                  : 8;  /**< [ 15:  8](R/W) Byte 2 of the transmit message. */
        uint32_t tx_1                  : 8;  /**< [ 23: 16](R/W) Byte 1 of the transmit message. */
        uint32_t tx_0                  : 8;  /**< [ 31: 24](R/W) Byte 0 of the transmit message. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_mcub_tx_0_ul_s cn; */
};
typedef union cavm_cprix_cn4ipx_mcub_tx_0_ul cavm_cprix_cn4ipx_mcub_tx_0_ul_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_TX_0_UL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_TX_0_UL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x8640008010d8ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MCUB_TX_0_UL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MCUB_TX_0_UL(a,b) cavm_cprix_cn4ipx_mcub_tx_0_ul_t
#define bustype_CAVM_CPRIX_CN4IPX_MCUB_TX_0_UL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MCUB_TX_0_UL(a,b) "CPRIX_CN4IPX_MCUB_TX_0_UL"
#define busnum_CAVM_CPRIX_CN4IPX_MCUB_TX_0_UL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MCUB_TX_0_UL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_mcub_tx_1_dl
 *
 * CPRI CONN4 IP MCU Transmit Buffer Data 1 DL Register
 */
union cavm_cprix_cn4ipx_mcub_tx_1_dl
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_mcub_tx_1_dl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t tx_4                  : 8;  /**< [ 31: 24](R/W) Byte 4 of the transmit message. */
        uint32_t tx_5                  : 8;  /**< [ 23: 16](R/W) Byte 5 of the transmit message. */
        uint32_t tx_6                  : 8;  /**< [ 15:  8](R/W) Byte 6 of the transmit message. */
        uint32_t tx_7                  : 8;  /**< [  7:  0](R/W) Byte 7 of the transmit message. */
#else /* Word 0 - Little Endian */
        uint32_t tx_7                  : 8;  /**< [  7:  0](R/W) Byte 7 of the transmit message. */
        uint32_t tx_6                  : 8;  /**< [ 15:  8](R/W) Byte 6 of the transmit message. */
        uint32_t tx_5                  : 8;  /**< [ 23: 16](R/W) Byte 5 of the transmit message. */
        uint32_t tx_4                  : 8;  /**< [ 31: 24](R/W) Byte 4 of the transmit message. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_mcub_tx_1_dl_s cn; */
};
typedef union cavm_cprix_cn4ipx_mcub_tx_1_dl cavm_cprix_cn4ipx_mcub_tx_1_dl_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_TX_1_DL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_TX_1_DL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080115cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MCUB_TX_1_DL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MCUB_TX_1_DL(a,b) cavm_cprix_cn4ipx_mcub_tx_1_dl_t
#define bustype_CAVM_CPRIX_CN4IPX_MCUB_TX_1_DL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MCUB_TX_1_DL(a,b) "CPRIX_CN4IPX_MCUB_TX_1_DL"
#define busnum_CAVM_CPRIX_CN4IPX_MCUB_TX_1_DL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MCUB_TX_1_DL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_mcub_tx_1_ul
 *
 * CPRI CONN4 IP MCU Transmit Buffer Data 1 UL Register
 */
union cavm_cprix_cn4ipx_mcub_tx_1_ul
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_mcub_tx_1_ul_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t tx_4                  : 8;  /**< [ 31: 24](R/W) Byte 4 of the transmit message. */
        uint32_t tx_5                  : 8;  /**< [ 23: 16](R/W) Byte 5 of the transmit message. */
        uint32_t tx_6                  : 8;  /**< [ 15:  8](R/W) Byte 6 of the transmit message. */
        uint32_t tx_7                  : 8;  /**< [  7:  0](R/W) Byte 7 of the transmit message. */
#else /* Word 0 - Little Endian */
        uint32_t tx_7                  : 8;  /**< [  7:  0](R/W) Byte 7 of the transmit message. */
        uint32_t tx_6                  : 8;  /**< [ 15:  8](R/W) Byte 6 of the transmit message. */
        uint32_t tx_5                  : 8;  /**< [ 23: 16](R/W) Byte 5 of the transmit message. */
        uint32_t tx_4                  : 8;  /**< [ 31: 24](R/W) Byte 4 of the transmit message. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_mcub_tx_1_ul_s cn; */
};
typedef union cavm_cprix_cn4ipx_mcub_tx_1_ul cavm_cprix_cn4ipx_mcub_tx_1_ul_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_TX_1_UL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_TX_1_UL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x8640008010dcll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MCUB_TX_1_UL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MCUB_TX_1_UL(a,b) cavm_cprix_cn4ipx_mcub_tx_1_ul_t
#define bustype_CAVM_CPRIX_CN4IPX_MCUB_TX_1_UL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MCUB_TX_1_UL(a,b) "CPRIX_CN4IPX_MCUB_TX_1_UL"
#define busnum_CAVM_CPRIX_CN4IPX_MCUB_TX_1_UL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MCUB_TX_1_UL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_mcub_tx_2_dl
 *
 * CPRI CONN4 IP MCU Transmit Buffer Data 2 DL Register
 */
union cavm_cprix_cn4ipx_mcub_tx_2_dl
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_mcub_tx_2_dl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t tx_8                  : 8;  /**< [ 31: 24](R/W) Byte 8 of the transmit message. */
        uint32_t tx_9                  : 8;  /**< [ 23: 16](R/W) Byte 9 of the transmit message. */
        uint32_t tx_10                 : 8;  /**< [ 15:  8](R/W) Byte 10 of the transmit message. */
        uint32_t tx_11                 : 8;  /**< [  7:  0](R/W) Byte 11 of the transmit message. */
#else /* Word 0 - Little Endian */
        uint32_t tx_11                 : 8;  /**< [  7:  0](R/W) Byte 11 of the transmit message. */
        uint32_t tx_10                 : 8;  /**< [ 15:  8](R/W) Byte 10 of the transmit message. */
        uint32_t tx_9                  : 8;  /**< [ 23: 16](R/W) Byte 9 of the transmit message. */
        uint32_t tx_8                  : 8;  /**< [ 31: 24](R/W) Byte 8 of the transmit message. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_mcub_tx_2_dl_s cn; */
};
typedef union cavm_cprix_cn4ipx_mcub_tx_2_dl cavm_cprix_cn4ipx_mcub_tx_2_dl_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_TX_2_DL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_TX_2_DL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000801160ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MCUB_TX_2_DL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MCUB_TX_2_DL(a,b) cavm_cprix_cn4ipx_mcub_tx_2_dl_t
#define bustype_CAVM_CPRIX_CN4IPX_MCUB_TX_2_DL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MCUB_TX_2_DL(a,b) "CPRIX_CN4IPX_MCUB_TX_2_DL"
#define busnum_CAVM_CPRIX_CN4IPX_MCUB_TX_2_DL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MCUB_TX_2_DL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_mcub_tx_2_ul
 *
 * CPRI CONN4 IP MCU Transmit Buffer Data 2 UL Register
 */
union cavm_cprix_cn4ipx_mcub_tx_2_ul
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_mcub_tx_2_ul_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t tx_8                  : 8;  /**< [ 31: 24](R/W) Byte 8 of the transmit message. */
        uint32_t tx_9                  : 8;  /**< [ 23: 16](R/W) Byte 9 of the transmit message. */
        uint32_t tx_10                 : 8;  /**< [ 15:  8](R/W) Byte 10 of the transmit message. */
        uint32_t tx_11                 : 8;  /**< [  7:  0](R/W) Byte 11 of the transmit message. */
#else /* Word 0 - Little Endian */
        uint32_t tx_11                 : 8;  /**< [  7:  0](R/W) Byte 11 of the transmit message. */
        uint32_t tx_10                 : 8;  /**< [ 15:  8](R/W) Byte 10 of the transmit message. */
        uint32_t tx_9                  : 8;  /**< [ 23: 16](R/W) Byte 9 of the transmit message. */
        uint32_t tx_8                  : 8;  /**< [ 31: 24](R/W) Byte 8 of the transmit message. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_mcub_tx_2_ul_s cn; */
};
typedef union cavm_cprix_cn4ipx_mcub_tx_2_ul cavm_cprix_cn4ipx_mcub_tx_2_ul_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_TX_2_UL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_TX_2_UL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x8640008010e0ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MCUB_TX_2_UL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MCUB_TX_2_UL(a,b) cavm_cprix_cn4ipx_mcub_tx_2_ul_t
#define bustype_CAVM_CPRIX_CN4IPX_MCUB_TX_2_UL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MCUB_TX_2_UL(a,b) "CPRIX_CN4IPX_MCUB_TX_2_UL"
#define busnum_CAVM_CPRIX_CN4IPX_MCUB_TX_2_UL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MCUB_TX_2_UL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_mcub_tx_3_dl
 *
 * CPRI CONN4 IP MCU Transmit Buffer Data 3 DL Register
 */
union cavm_cprix_cn4ipx_mcub_tx_3_dl
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_mcub_tx_3_dl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t tx_12                 : 8;  /**< [ 31: 24](R/W) Byte 12 of the transmit message. */
        uint32_t tx_13                 : 8;  /**< [ 23: 16](R/W) Byte 13 of the transmit message. */
        uint32_t tx_14                 : 8;  /**< [ 15:  8](R/W) Byte 14 of the transmit message. */
        uint32_t tx_15                 : 8;  /**< [  7:  0](R/W) Byte 15 of the transmit message. */
#else /* Word 0 - Little Endian */
        uint32_t tx_15                 : 8;  /**< [  7:  0](R/W) Byte 15 of the transmit message. */
        uint32_t tx_14                 : 8;  /**< [ 15:  8](R/W) Byte 14 of the transmit message. */
        uint32_t tx_13                 : 8;  /**< [ 23: 16](R/W) Byte 13 of the transmit message. */
        uint32_t tx_12                 : 8;  /**< [ 31: 24](R/W) Byte 12 of the transmit message. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_mcub_tx_3_dl_s cn; */
};
typedef union cavm_cprix_cn4ipx_mcub_tx_3_dl cavm_cprix_cn4ipx_mcub_tx_3_dl_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_TX_3_DL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_TX_3_DL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000801164ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MCUB_TX_3_DL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MCUB_TX_3_DL(a,b) cavm_cprix_cn4ipx_mcub_tx_3_dl_t
#define bustype_CAVM_CPRIX_CN4IPX_MCUB_TX_3_DL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MCUB_TX_3_DL(a,b) "CPRIX_CN4IPX_MCUB_TX_3_DL"
#define busnum_CAVM_CPRIX_CN4IPX_MCUB_TX_3_DL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MCUB_TX_3_DL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_mcub_tx_3_ul
 *
 * CPRI CONN4 IP MCU Transmit Buffer Data 3 UL Register
 */
union cavm_cprix_cn4ipx_mcub_tx_3_ul
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_mcub_tx_3_ul_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t tx_12                 : 8;  /**< [ 31: 24](R/W) Byte 12 of the transmit message. */
        uint32_t tx_13                 : 8;  /**< [ 23: 16](R/W) Byte 13 of the transmit message. */
        uint32_t tx_14                 : 8;  /**< [ 15:  8](R/W) Byte 14 of the transmit message. */
        uint32_t tx_15                 : 8;  /**< [  7:  0](R/W) Byte 15 of the transmit message. */
#else /* Word 0 - Little Endian */
        uint32_t tx_15                 : 8;  /**< [  7:  0](R/W) Byte 15 of the transmit message. */
        uint32_t tx_14                 : 8;  /**< [ 15:  8](R/W) Byte 14 of the transmit message. */
        uint32_t tx_13                 : 8;  /**< [ 23: 16](R/W) Byte 13 of the transmit message. */
        uint32_t tx_12                 : 8;  /**< [ 31: 24](R/W) Byte 12 of the transmit message. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_mcub_tx_3_ul_s cn; */
};
typedef union cavm_cprix_cn4ipx_mcub_tx_3_ul cavm_cprix_cn4ipx_mcub_tx_3_ul_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_TX_3_UL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_TX_3_UL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x8640008010e4ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MCUB_TX_3_UL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MCUB_TX_3_UL(a,b) cavm_cprix_cn4ipx_mcub_tx_3_ul_t
#define bustype_CAVM_CPRIX_CN4IPX_MCUB_TX_3_UL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MCUB_TX_3_UL(a,b) "CPRIX_CN4IPX_MCUB_TX_3_UL"
#define busnum_CAVM_CPRIX_CN4IPX_MCUB_TX_3_UL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MCUB_TX_3_UL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_mcub_tx_4_dl
 *
 * CPRI CONN4 IP MCU Transmit Buffer Data 4 DL Register
 */
union cavm_cprix_cn4ipx_mcub_tx_4_dl
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_mcub_tx_4_dl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t tx_16                 : 8;  /**< [ 23: 16](R/W) Byte 16 of the transmit message. */
        uint32_t tx_17                 : 8;  /**< [ 15:  8](R/W) Byte 17 of the transmit message. */
        uint32_t tx_18                 : 8;  /**< [  7:  0](R/W) Byte 18 of the transmit message. */
#else /* Word 0 - Little Endian */
        uint32_t tx_18                 : 8;  /**< [  7:  0](R/W) Byte 18 of the transmit message. */
        uint32_t tx_17                 : 8;  /**< [ 15:  8](R/W) Byte 17 of the transmit message. */
        uint32_t tx_16                 : 8;  /**< [ 23: 16](R/W) Byte 16 of the transmit message. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_mcub_tx_4_dl_s cn; */
};
typedef union cavm_cprix_cn4ipx_mcub_tx_4_dl cavm_cprix_cn4ipx_mcub_tx_4_dl_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_TX_4_DL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_TX_4_DL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000801168ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MCUB_TX_4_DL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MCUB_TX_4_DL(a,b) cavm_cprix_cn4ipx_mcub_tx_4_dl_t
#define bustype_CAVM_CPRIX_CN4IPX_MCUB_TX_4_DL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MCUB_TX_4_DL(a,b) "CPRIX_CN4IPX_MCUB_TX_4_DL"
#define busnum_CAVM_CPRIX_CN4IPX_MCUB_TX_4_DL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MCUB_TX_4_DL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_mcub_tx_4_ul
 *
 * CPRI CONN4 IP MCU Transmit Buffer Data 4 UL Register
 */
union cavm_cprix_cn4ipx_mcub_tx_4_ul
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_mcub_tx_4_ul_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t tx_16                 : 8;  /**< [ 23: 16](R/W) Byte 16 of the transmit message. */
        uint32_t tx_17                 : 8;  /**< [ 15:  8](R/W) Byte 17 of the transmit message. */
        uint32_t tx_18                 : 8;  /**< [  7:  0](R/W) Byte 18 of the transmit message. */
#else /* Word 0 - Little Endian */
        uint32_t tx_18                 : 8;  /**< [  7:  0](R/W) Byte 18 of the transmit message. */
        uint32_t tx_17                 : 8;  /**< [ 15:  8](R/W) Byte 17 of the transmit message. */
        uint32_t tx_16                 : 8;  /**< [ 23: 16](R/W) Byte 16 of the transmit message. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_mcub_tx_4_ul_s cn; */
};
typedef union cavm_cprix_cn4ipx_mcub_tx_4_ul cavm_cprix_cn4ipx_mcub_tx_4_ul_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_TX_4_UL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_TX_4_UL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x8640008010e8ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MCUB_TX_4_UL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MCUB_TX_4_UL(a,b) cavm_cprix_cn4ipx_mcub_tx_4_ul_t
#define bustype_CAVM_CPRIX_CN4IPX_MCUB_TX_4_UL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MCUB_TX_4_UL(a,b) "CPRIX_CN4IPX_MCUB_TX_4_UL"
#define busnum_CAVM_CPRIX_CN4IPX_MCUB_TX_4_UL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MCUB_TX_4_UL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_mcub_txc_dl
 *
 * CPRI CONN4 IP MCU Transmit Control DL Register
 */
union cavm_cprix_cn4ipx_mcub_txc_dl
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_mcub_txc_dl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t tx_status             : 1;  /**< [  6:  6](RO/H) Buffer status:
                                                                   0 = Transmit completed.
                                                                   1 = Transmit ongoing. */
        uint32_t send_msg              : 1;  /**< [  5:  5](R/W/H) Send message:
                                                                   0 = No action.
                                                                   1 = Send message. */
        uint32_t reserved_2_4          : 3;
        uint32_t dest_link             : 2;  /**< [  1:  0](R/W) Destination link:
                                                                   0 = RP3 link 0.
                                                                   1 = RP3 link 1.
                                                                   2,3 = not used. */
#else /* Word 0 - Little Endian */
        uint32_t dest_link             : 2;  /**< [  1:  0](R/W) Destination link:
                                                                   0 = RP3 link 0.
                                                                   1 = RP3 link 1.
                                                                   2,3 = not used. */
        uint32_t reserved_2_4          : 3;
        uint32_t send_msg              : 1;  /**< [  5:  5](R/W/H) Send message:
                                                                   0 = No action.
                                                                   1 = Send message. */
        uint32_t tx_status             : 1;  /**< [  6:  6](RO/H) Buffer status:
                                                                   0 = Transmit completed.
                                                                   1 = Transmit ongoing. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_mcub_txc_dl_s cn; */
};
typedef union cavm_cprix_cn4ipx_mcub_txc_dl cavm_cprix_cn4ipx_mcub_txc_dl_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_TXC_DL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_TXC_DL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000801154ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MCUB_TXC_DL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MCUB_TXC_DL(a,b) cavm_cprix_cn4ipx_mcub_txc_dl_t
#define bustype_CAVM_CPRIX_CN4IPX_MCUB_TXC_DL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MCUB_TXC_DL(a,b) "CPRIX_CN4IPX_MCUB_TXC_DL"
#define busnum_CAVM_CPRIX_CN4IPX_MCUB_TXC_DL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MCUB_TXC_DL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_mcub_txc_ul
 *
 * CPRI CONN4 IP MCU Transmit Control UL Register
 */
union cavm_cprix_cn4ipx_mcub_txc_ul
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_mcub_txc_ul_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t tx_status             : 1;  /**< [  6:  6](RO/H) Buffer status:
                                                                   0 = Transmit completed.
                                                                   1 = Transmit ongoing. */
        uint32_t send_msg              : 1;  /**< [  5:  5](R/W/H) Send message:
                                                                   0 = No action.
                                                                   1 = Send message. */
        uint32_t reserved_2_4          : 3;
        uint32_t dest_link             : 2;  /**< [  1:  0](R/W) Destination link:
                                                                   0 = RP3 link 0.
                                                                   1 = RP3 link 1.
                                                                   2,3 = not used. */
#else /* Word 0 - Little Endian */
        uint32_t dest_link             : 2;  /**< [  1:  0](R/W) Destination link:
                                                                   0 = RP3 link 0.
                                                                   1 = RP3 link 1.
                                                                   2,3 = not used. */
        uint32_t reserved_2_4          : 3;
        uint32_t send_msg              : 1;  /**< [  5:  5](R/W/H) Send message:
                                                                   0 = No action.
                                                                   1 = Send message. */
        uint32_t tx_status             : 1;  /**< [  6:  6](RO/H) Buffer status:
                                                                   0 = Transmit completed.
                                                                   1 = Transmit ongoing. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_mcub_txc_ul_s cn; */
};
typedef union cavm_cprix_cn4ipx_mcub_txc_ul cavm_cprix_cn4ipx_mcub_txc_ul_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_TXC_UL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MCUB_TXC_UL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x8640008010d4ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MCUB_TXC_UL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MCUB_TXC_UL(a,b) cavm_cprix_cn4ipx_mcub_txc_ul_t
#define bustype_CAVM_CPRIX_CN4IPX_MCUB_TXC_UL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MCUB_TXC_UL(a,b) "CPRIX_CN4IPX_MCUB_TXC_UL"
#define busnum_CAVM_CPRIX_CN4IPX_MCUB_TXC_UL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MCUB_TXC_UL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_mcubuf_crc
 *
 * CPRI CONN4 IP MCUBUF CRC Register
 */
union cavm_cprix_cn4ipx_mcubuf_crc
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_mcubuf_crc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t crc_ena               : 32; /**< [ 31:  0](R/W) Enable HW CRC check for messages of given RP3 message type.
                                                                 Each bit maps to one of the possible RP3 types as specified in RP3 spec:
                                                                   0 = control.
                                                                   1 = measurement.
                                                                   2 = WCDMA/FDD.  ...

                                                                     0 = CRC check/generation disabled.
                                                                     1 = CRC check/generation enabled. */
#else /* Word 0 - Little Endian */
        uint32_t crc_ena               : 32; /**< [ 31:  0](R/W) Enable HW CRC check for messages of given RP3 message type.
                                                                 Each bit maps to one of the possible RP3 types as specified in RP3 spec:
                                                                   0 = control.
                                                                   1 = measurement.
                                                                   2 = WCDMA/FDD.  ...

                                                                     0 = CRC check/generation disabled.
                                                                     1 = CRC check/generation enabled. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_mcubuf_crc_s cn; */
};
typedef union cavm_cprix_cn4ipx_mcubuf_crc cavm_cprix_cn4ipx_mcubuf_crc_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MCUBUF_CRC(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MCUBUF_CRC(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000801044ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MCUBUF_CRC", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MCUBUF_CRC(a,b) cavm_cprix_cn4ipx_mcubuf_crc_t
#define bustype_CAVM_CPRIX_CN4IPX_MCUBUF_CRC(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MCUBUF_CRC(a,b) "CPRIX_CN4IPX_MCUBUF_CRC"
#define busnum_CAVM_CPRIX_CN4IPX_MCUBUF_CRC(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MCUBUF_CRC(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_meas_hf_ctrl#_ln#
 *
 * CPRI CONN4 IP Measurement Message CPRI capture hyperframe and trigger control 0 to 15 Register
 */
union cavm_cprix_cn4ipx_meas_hf_ctrlx_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_meas_hf_ctrlx_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_22_31        : 10;
        uint32_t meas_trig             : 6;  /**< [ 21: 16](R/W) Inclusion of measurement fields in RP3 measurement message. The field which bit
                                                                 is '1' must be available before RP3 measurement message is sent. If bit is '0',
                                                                 field will be included in the message if available.
                                                                 Bit5 = DL C2 TCP.
                                                                 Bit4 = DL C1 TCP.
                                                                 Bit3 = UL C2Br1.
                                                                 Bit2 = UL C2Br0.
                                                                 Bit1 = UL C1Br1.
                                                                 Bit0 = UL C1Br0.
                                                                 At least one bit must be '1' for transmission of RP3 measurement message.
                                                                 MEAS_MASK has priority over MEAS_TRIG. MEAS_TRIG is not valid for any masked
                                                                 field but the masked field will be zero in the outgoing RP3 measurement message.
                                                                 At least one field should have MEAS_MASK = '0' and MEAS_TRIG = '1'. */
        uint32_t meas_active_indx      : 8;  /**< [ 15:  8](R/W) Active hyperframe number(s), index.
                                                                 Valid range [0:149]. */
        uint32_t meas_active_mod       : 8;  /**< [  7:  0](R/W) Active hyperframe number(s), modulo.
                                                                 Valid range [1:150]. */
#else /* Word 0 - Little Endian */
        uint32_t meas_active_mod       : 8;  /**< [  7:  0](R/W) Active hyperframe number(s), modulo.
                                                                 Valid range [1:150]. */
        uint32_t meas_active_indx      : 8;  /**< [ 15:  8](R/W) Active hyperframe number(s), index.
                                                                 Valid range [0:149]. */
        uint32_t meas_trig             : 6;  /**< [ 21: 16](R/W) Inclusion of measurement fields in RP3 measurement message. The field which bit
                                                                 is '1' must be available before RP3 measurement message is sent. If bit is '0',
                                                                 field will be included in the message if available.
                                                                 Bit5 = DL C2 TCP.
                                                                 Bit4 = DL C1 TCP.
                                                                 Bit3 = UL C2Br1.
                                                                 Bit2 = UL C2Br0.
                                                                 Bit1 = UL C1Br1.
                                                                 Bit0 = UL C1Br0.
                                                                 At least one bit must be '1' for transmission of RP3 measurement message.
                                                                 MEAS_MASK has priority over MEAS_TRIG. MEAS_TRIG is not valid for any masked
                                                                 field but the masked field will be zero in the outgoing RP3 measurement message.
                                                                 At least one field should have MEAS_MASK = '0' and MEAS_TRIG = '1'. */
        uint32_t reserved_22_31        : 10;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_meas_hf_ctrlx_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_meas_hf_ctrlx_lnx cavm_cprix_cn4ipx_meas_hf_ctrlx_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MEAS_HF_CTRLX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MEAS_HF_CTRLX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=15) && (d<=1)))
        return 0x864000820288ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0xcll * ((c) & 0xf) + 0x10000ll * ((d) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MEAS_HF_CTRLX_LNX", 4, a, b, c, d, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MEAS_HF_CTRLX_LNX(a,b,c,d) cavm_cprix_cn4ipx_meas_hf_ctrlx_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_MEAS_HF_CTRLX_LNX(a,b,c,d) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MEAS_HF_CTRLX_LNX(a,b,c,d) "CPRIX_CN4IPX_MEAS_HF_CTRLX_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_MEAS_HF_CTRLX_LNX(a,b,c,d) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MEAS_HF_CTRLX_LNX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) cpri#_cn4ip#_meas_msg_ctrl#_ln#
 *
 * CPRI CONN4 IP Measurement Message control for message 0 to 15 Register
 */
union cavm_cprix_cn4ipx_meas_msg_ctrlx_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_meas_msg_ctrlx_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t meas_id               : 16; /**< [ 31: 16](R/W) Measurement Message ID.
                                                                 Bits 31:24 will be the first the transmitted byte. */
        uint32_t reserved_13_15        : 3;
        uint32_t meas_addr             : 13; /**< [ 12:  0](R/W) RP3 address of the measurement message. */
#else /* Word 0 - Little Endian */
        uint32_t meas_addr             : 13; /**< [ 12:  0](R/W) RP3 address of the measurement message. */
        uint32_t reserved_13_15        : 3;
        uint32_t meas_id               : 16; /**< [ 31: 16](R/W) Measurement Message ID.
                                                                 Bits 31:24 will be the first the transmitted byte. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_meas_msg_ctrlx_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_meas_msg_ctrlx_lnx cavm_cprix_cn4ipx_meas_msg_ctrlx_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MEAS_MSG_CTRLX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MEAS_MSG_CTRLX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=15) && (d<=1)))
        return 0x864000820280ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0xcll * ((c) & 0xf) + 0x10000ll * ((d) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MEAS_MSG_CTRLX_LNX", 4, a, b, c, d, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MEAS_MSG_CTRLX_LNX(a,b,c,d) cavm_cprix_cn4ipx_meas_msg_ctrlx_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_MEAS_MSG_CTRLX_LNX(a,b,c,d) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MEAS_MSG_CTRLX_LNX(a,b,c,d) "CPRIX_CN4IPX_MEAS_MSG_CTRLX_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_MEAS_MSG_CTRLX_LNX(a,b,c,d) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MEAS_MSG_CTRLX_LNX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) cpri#_cn4ip#_meas_ul_ctrl#_ln#
 *
 * CPRI CONN4 IP Measurement Message CPRI capture control 0 to 15 Register
 */
union cavm_cprix_cn4ipx_meas_ul_ctrlx_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_meas_ul_ctrlx_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_30_31        : 2;
        uint32_t meas_mask             : 6;  /**< [ 29: 24](R/W) Masking of measurement fields in RP3 measurement message.
                                                                 Bit5 = DL C2 TCP.
                                                                 Bit4 = DL C1 TCP.
                                                                 Bit3 = UL C2Br1.
                                                                 Bit2 = UL C2Br0.
                                                                 Bit1 = UL C1Br1.
                                                                 Bit0 = UL C1Br0.
                                                                 1 = Masked.
                                                                 0 = Not masked.
                                                                 Masked field will be zero in RP3 measurement message. */
        uint32_t meas_word_pos1        : 4;  /**< [ 23: 20](R/W) CPRI control word bit position containing the UL measurement word byte1 (MSB byte of the result).
                                                                 0x0 = Byte[0].
                                                                 0x1 = Byte[1].
                                                                 0x2 = Byte[2].
                                                                 0x3 = Byte[3].
                                                                 0x4 = Byte[4].
                                                                 0x5 = Byte[5].
                                                                 0x6 = Byte[6].
                                                                 0x7 = Byte[7].
                                                                 0x8 = Byte[8].
                                                                 0x9 = Byte[9].
                                                                 .
                                                                 .
                                                                 .
                                                                 0xF = Byte[15].

                                                                 Note! Valid values depend on the used line rate. */
        uint32_t meas_word_pos0        : 4;  /**< [ 19: 16](R/W) CPRI control word bit position containing the UL measurement word byte0 (LSB byte of the result).
                                                                 0x0 = Byte[0].
                                                                 0x1 = Byte[1].
                                                                 0x2 = Byte[2].
                                                                 0x3 = Byte[3].
                                                                 0x4 = Byte[4].
                                                                 0x5 = Byte[5].
                                                                 0x6 = Byte[6].
                                                                 0x7 = Byte[7].
                                                                 0x8 = Byte[8].
                                                                 0x9 = Byte[9].
                                                                 .
                                                                 .
                                                                 .
                                                                 0xF = Byte[15].

                                                                 Note! Valid values depend on the used line rate. */
        uint32_t reserved_12_15        : 4;
        uint32_t meas_ns1              : 6;  /**< [ 11:  6](R/W) CPRI subchannel number for UL measurement word byte1 (MSB byte of the result).
                                                                 Valid range [3:63]. */
        uint32_t meas_ns0              : 6;  /**< [  5:  0](R/W) CPRI subchannel number for UL measurement word byte0 (LSB byte of the result).
                                                                 Valid range [3:63]. */
#else /* Word 0 - Little Endian */
        uint32_t meas_ns0              : 6;  /**< [  5:  0](R/W) CPRI subchannel number for UL measurement word byte0 (LSB byte of the result).
                                                                 Valid range [3:63]. */
        uint32_t meas_ns1              : 6;  /**< [ 11:  6](R/W) CPRI subchannel number for UL measurement word byte1 (MSB byte of the result).
                                                                 Valid range [3:63]. */
        uint32_t reserved_12_15        : 4;
        uint32_t meas_word_pos0        : 4;  /**< [ 19: 16](R/W) CPRI control word bit position containing the UL measurement word byte0 (LSB byte of the result).
                                                                 0x0 = Byte[0].
                                                                 0x1 = Byte[1].
                                                                 0x2 = Byte[2].
                                                                 0x3 = Byte[3].
                                                                 0x4 = Byte[4].
                                                                 0x5 = Byte[5].
                                                                 0x6 = Byte[6].
                                                                 0x7 = Byte[7].
                                                                 0x8 = Byte[8].
                                                                 0x9 = Byte[9].
                                                                 .
                                                                 .
                                                                 .
                                                                 0xF = Byte[15].

                                                                 Note! Valid values depend on the used line rate. */
        uint32_t meas_word_pos1        : 4;  /**< [ 23: 20](R/W) CPRI control word bit position containing the UL measurement word byte1 (MSB byte of the result).
                                                                 0x0 = Byte[0].
                                                                 0x1 = Byte[1].
                                                                 0x2 = Byte[2].
                                                                 0x3 = Byte[3].
                                                                 0x4 = Byte[4].
                                                                 0x5 = Byte[5].
                                                                 0x6 = Byte[6].
                                                                 0x7 = Byte[7].
                                                                 0x8 = Byte[8].
                                                                 0x9 = Byte[9].
                                                                 .
                                                                 .
                                                                 .
                                                                 0xF = Byte[15].

                                                                 Note! Valid values depend on the used line rate. */
        uint32_t meas_mask             : 6;  /**< [ 29: 24](R/W) Masking of measurement fields in RP3 measurement message.
                                                                 Bit5 = DL C2 TCP.
                                                                 Bit4 = DL C1 TCP.
                                                                 Bit3 = UL C2Br1.
                                                                 Bit2 = UL C2Br0.
                                                                 Bit1 = UL C1Br1.
                                                                 Bit0 = UL C1Br0.
                                                                 1 = Masked.
                                                                 0 = Not masked.
                                                                 Masked field will be zero in RP3 measurement message. */
        uint32_t reserved_30_31        : 2;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_meas_ul_ctrlx_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_meas_ul_ctrlx_lnx cavm_cprix_cn4ipx_meas_ul_ctrlx_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_MEAS_UL_CTRLX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_MEAS_UL_CTRLX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=15) && (d<=1)))
        return 0x864000820284ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0xcll * ((c) & 0xf) + 0x10000ll * ((d) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_MEAS_UL_CTRLX_LNX", 4, a, b, c, d, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_MEAS_UL_CTRLX_LNX(a,b,c,d) cavm_cprix_cn4ipx_meas_ul_ctrlx_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_MEAS_UL_CTRLX_LNX(a,b,c,d) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_MEAS_UL_CTRLX_LNX(a,b,c,d) "CPRIX_CN4IPX_MEAS_UL_CTRLX_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_MEAS_UL_CTRLX_LNX(a,b,c,d) (a)
#define arguments_CAVM_CPRIX_CN4IPX_MEAS_UL_CTRLX_LNX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) cpri#_cn4ip#_rp301_cint_clr
 *
 * CPRI CONN4 IP RP3-01 Common Interrupt Event Clear Register
 */
union cavm_cprix_cn4ipx_rp301_cint_clr
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rp301_cint_clr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t fcb_rp1_crc_er        : 1;  /**< [  3:  3](R/W1C/H) Clear for FCB_RP1_CRC_ER interrupt:
                                                                     0 = no effect.
                                                                     1 = clear interrupt status. */
        uint32_t bcn_frint             : 1;  /**< [  2:  2](R/W1C/H) Clear for BCN_FRINT interrupt. */
        uint32_t bcn_sr                : 1;  /**< [  1:  1](R/W1C/H) Clear for BCN_SR interrupt. */
        uint32_t rttm_crc              : 1;  /**< [  0:  0](R/W1C/H) Clear for RTTM_CRC interrupt. */
#else /* Word 0 - Little Endian */
        uint32_t rttm_crc              : 1;  /**< [  0:  0](R/W1C/H) Clear for RTTM_CRC interrupt. */
        uint32_t bcn_sr                : 1;  /**< [  1:  1](R/W1C/H) Clear for BCN_SR interrupt. */
        uint32_t bcn_frint             : 1;  /**< [  2:  2](R/W1C/H) Clear for BCN_FRINT interrupt. */
        uint32_t fcb_rp1_crc_er        : 1;  /**< [  3:  3](R/W1C/H) Clear for FCB_RP1_CRC_ER interrupt:
                                                                     0 = no effect.
                                                                     1 = clear interrupt status. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rp301_cint_clr_s cn; */
};
typedef union cavm_cprix_cn4ipx_rp301_cint_clr cavm_cprix_cn4ipx_rp301_cint_clr_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RP301_CINT_CLR(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RP301_CINT_CLR(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f144ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RP301_CINT_CLR", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RP301_CINT_CLR(a,b) cavm_cprix_cn4ipx_rp301_cint_clr_t
#define bustype_CAVM_CPRIX_CN4IPX_RP301_CINT_CLR(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RP301_CINT_CLR(a,b) "CPRIX_CN4IPX_RP301_CINT_CLR"
#define busnum_CAVM_CPRIX_CN4IPX_RP301_CINT_CLR(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RP301_CINT_CLR(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rp301_cint_msk
 *
 * CPRI CONN4 IP RP3-01 Common Interrupt Event Mask Register
 */
union cavm_cprix_cn4ipx_rp301_cint_msk
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rp301_cint_msk_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t fcb_rp1_crc_er        : 1;  /**< [  3:  3](R/W) Mask for FCB_RP1_CRC_ER interrupt:
                                                                     0 = interrupt enabled.
                                                                     1 = interrupt disabled. */
        uint32_t bcn_frint             : 1;  /**< [  2:  2](R/W) Mask for BCN_FRINT interrupt. */
        uint32_t bcn_sr                : 1;  /**< [  1:  1](R/W) Mask for BCN_SR interrupt. */
        uint32_t rttm_crc              : 1;  /**< [  0:  0](R/W) Mask for RTTM_CRC interrupt. */
#else /* Word 0 - Little Endian */
        uint32_t rttm_crc              : 1;  /**< [  0:  0](R/W) Mask for RTTM_CRC interrupt. */
        uint32_t bcn_sr                : 1;  /**< [  1:  1](R/W) Mask for BCN_SR interrupt. */
        uint32_t bcn_frint             : 1;  /**< [  2:  2](R/W) Mask for BCN_FRINT interrupt. */
        uint32_t fcb_rp1_crc_er        : 1;  /**< [  3:  3](R/W) Mask for FCB_RP1_CRC_ER interrupt:
                                                                     0 = interrupt enabled.
                                                                     1 = interrupt disabled. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rp301_cint_msk_s cn; */
};
typedef union cavm_cprix_cn4ipx_rp301_cint_msk cavm_cprix_cn4ipx_rp301_cint_msk_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RP301_CINT_MSK(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RP301_CINT_MSK(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f14cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RP301_CINT_MSK", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RP301_CINT_MSK(a,b) cavm_cprix_cn4ipx_rp301_cint_msk_t
#define bustype_CAVM_CPRIX_CN4IPX_RP301_CINT_MSK(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RP301_CINT_MSK(a,b) "CPRIX_CN4IPX_RP301_CINT_MSK"
#define busnum_CAVM_CPRIX_CN4IPX_RP301_CINT_MSK(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RP301_CINT_MSK(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rp301_cint_mskclr
 *
 * CPRI CONN4 IP RP3-01 Common Interrupt Event Mask Clear Register
 */
union cavm_cprix_cn4ipx_rp301_cint_mskclr
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rp301_cint_mskclr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t fcb_rp1_crc_er        : 1;  /**< [  3:  3](R/W1C/H) Mask clear for FCB_RP1_CRC_ER interrupt:
                                                                     0 = no effect.
                                                                     1 = Mask clear. */
        uint32_t bcn_frint             : 1;  /**< [  2:  2](R/W1C/H) Mask clear for BCN_FRINT interrupt. */
        uint32_t bcn_sr                : 1;  /**< [  1:  1](R/W1C/H) Mask clear for BCN_SR interrupt. */
        uint32_t rttm_crc              : 1;  /**< [  0:  0](R/W1C/H) Mask clear for RTTM_CRC interrupt. */
#else /* Word 0 - Little Endian */
        uint32_t rttm_crc              : 1;  /**< [  0:  0](R/W1C/H) Mask clear for RTTM_CRC interrupt. */
        uint32_t bcn_sr                : 1;  /**< [  1:  1](R/W1C/H) Mask clear for BCN_SR interrupt. */
        uint32_t bcn_frint             : 1;  /**< [  2:  2](R/W1C/H) Mask clear for BCN_FRINT interrupt. */
        uint32_t fcb_rp1_crc_er        : 1;  /**< [  3:  3](R/W1C/H) Mask clear for FCB_RP1_CRC_ER interrupt:
                                                                     0 = no effect.
                                                                     1 = Mask clear. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rp301_cint_mskclr_s cn; */
};
typedef union cavm_cprix_cn4ipx_rp301_cint_mskclr cavm_cprix_cn4ipx_rp301_cint_mskclr_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RP301_CINT_MSKCLR(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RP301_CINT_MSKCLR(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f150ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RP301_CINT_MSKCLR", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RP301_CINT_MSKCLR(a,b) cavm_cprix_cn4ipx_rp301_cint_mskclr_t
#define bustype_CAVM_CPRIX_CN4IPX_RP301_CINT_MSKCLR(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RP301_CINT_MSKCLR(a,b) "CPRIX_CN4IPX_RP301_CINT_MSKCLR"
#define busnum_CAVM_CPRIX_CN4IPX_RP301_CINT_MSKCLR(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RP301_CINT_MSKCLR(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rp301_cint_mskset
 *
 * CPRI CONN4 IP RP3-01 Common Interrupt Event Mask Set Register
 */
union cavm_cprix_cn4ipx_rp301_cint_mskset
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rp301_cint_mskset_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t fcb_rp1_crc_er        : 1;  /**< [  3:  3](R/W1S/H) Mask set for FCB_RP1_CRC_ER interrupt:
                                                                     0 = no effect.
                                                                     1 = Mask set. */
        uint32_t bcn_frint             : 1;  /**< [  2:  2](R/W1S/H) Mask set for BCN_FRINT interrupt. */
        uint32_t bcn_sr                : 1;  /**< [  1:  1](R/W1S/H) Mask set for BCN_SR interrupt. */
        uint32_t rttm_crc              : 1;  /**< [  0:  0](R/W1S/H) Mask set for RTTM_CRC interrupt. */
#else /* Word 0 - Little Endian */
        uint32_t rttm_crc              : 1;  /**< [  0:  0](R/W1S/H) Mask set for RTTM_CRC interrupt. */
        uint32_t bcn_sr                : 1;  /**< [  1:  1](R/W1S/H) Mask set for BCN_SR interrupt. */
        uint32_t bcn_frint             : 1;  /**< [  2:  2](R/W1S/H) Mask set for BCN_FRINT interrupt. */
        uint32_t fcb_rp1_crc_er        : 1;  /**< [  3:  3](R/W1S/H) Mask set for FCB_RP1_CRC_ER interrupt:
                                                                     0 = no effect.
                                                                     1 = Mask set. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rp301_cint_mskset_s cn; */
};
typedef union cavm_cprix_cn4ipx_rp301_cint_mskset cavm_cprix_cn4ipx_rp301_cint_mskset_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RP301_CINT_MSKSET(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RP301_CINT_MSKSET(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f154ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RP301_CINT_MSKSET", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RP301_CINT_MSKSET(a,b) cavm_cprix_cn4ipx_rp301_cint_mskset_t
#define bustype_CAVM_CPRIX_CN4IPX_RP301_CINT_MSKSET(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RP301_CINT_MSKSET(a,b) "CPRIX_CN4IPX_RP301_CINT_MSKSET"
#define busnum_CAVM_CPRIX_CN4IPX_RP301_CINT_MSKSET(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RP301_CINT_MSKSET(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rp301_cint_set
 *
 * CPRI CONN4 IP RP3-01 Common Interrupt Event Set Register
 */
union cavm_cprix_cn4ipx_rp301_cint_set
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rp301_cint_set_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t fcb_rp1_crc_er        : 1;  /**< [  3:  3](R/W1S/H) Set for FCB_RP1_CRC_ER interrupt:
                                                                     0 = no effect.
                                                                     1 = set interrupt status. */
        uint32_t bcn_frint             : 1;  /**< [  2:  2](R/W1S/H) Set for BCN_FRINT interrupt. */
        uint32_t bcn_sr                : 1;  /**< [  1:  1](R/W1S/H) Set for BCN_SR interrupt. */
        uint32_t rttm_crc              : 1;  /**< [  0:  0](R/W1S/H) Set for RTTM_CRC interrupt. */
#else /* Word 0 - Little Endian */
        uint32_t rttm_crc              : 1;  /**< [  0:  0](R/W1S/H) Set for RTTM_CRC interrupt. */
        uint32_t bcn_sr                : 1;  /**< [  1:  1](R/W1S/H) Set for BCN_SR interrupt. */
        uint32_t bcn_frint             : 1;  /**< [  2:  2](R/W1S/H) Set for BCN_FRINT interrupt. */
        uint32_t fcb_rp1_crc_er        : 1;  /**< [  3:  3](R/W1S/H) Set for FCB_RP1_CRC_ER interrupt:
                                                                     0 = no effect.
                                                                     1 = set interrupt status. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rp301_cint_set_s cn; */
};
typedef union cavm_cprix_cn4ipx_rp301_cint_set cavm_cprix_cn4ipx_rp301_cint_set_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RP301_CINT_SET(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RP301_CINT_SET(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f148ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RP301_CINT_SET", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RP301_CINT_SET(a,b) cavm_cprix_cn4ipx_rp301_cint_set_t
#define bustype_CAVM_CPRIX_CN4IPX_RP301_CINT_SET(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RP301_CINT_SET(a,b) "CPRIX_CN4IPX_RP301_CINT_SET"
#define busnum_CAVM_CPRIX_CN4IPX_RP301_CINT_SET(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RP301_CINT_SET(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rp301_cint_sts
 *
 * CPRI CONN4 IP RP3-01 Common Interrupt Status Register
 */
union cavm_cprix_cn4ipx_rp301_cint_sts
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rp301_cint_sts_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t fcb_rp1_crc_er        : 1;  /**< [  3:  3](RO/H) CRC error in received RP1 synchronization burst. */
        uint32_t bcn_frint             : 1;  /**< [  2:  2](RO/H) BCN timer frame interrupt:
                                                                   0 = No frame interrupt.
                                                                   1 = Frame interrupt. */
        uint32_t bcn_sr                : 1;  /**< [  1:  1](RO/H) BCN timer synchronization reached. Interrupt is activated, when status bit
                                                                 BCN_SYNC:STATUS goes active.
                                                                   0 = No synchronization status change.
                                                                   1 = Synchronization succeeded. */
        uint32_t rttm_crc              : 1;  /**< [  0:  0](RO/H) RTT master message CRC error.
                                                                   0 = CRC OK.
                                                                   1 = CRC error detected. */
#else /* Word 0 - Little Endian */
        uint32_t rttm_crc              : 1;  /**< [  0:  0](RO/H) RTT master message CRC error.
                                                                   0 = CRC OK.
                                                                   1 = CRC error detected. */
        uint32_t bcn_sr                : 1;  /**< [  1:  1](RO/H) BCN timer synchronization reached. Interrupt is activated, when status bit
                                                                 BCN_SYNC:STATUS goes active.
                                                                   0 = No synchronization status change.
                                                                   1 = Synchronization succeeded. */
        uint32_t bcn_frint             : 1;  /**< [  2:  2](RO/H) BCN timer frame interrupt:
                                                                   0 = No frame interrupt.
                                                                   1 = Frame interrupt. */
        uint32_t fcb_rp1_crc_er        : 1;  /**< [  3:  3](RO/H) CRC error in received RP1 synchronization burst. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rp301_cint_sts_s cn; */
};
typedef union cavm_cprix_cn4ipx_rp301_cint_sts cavm_cprix_cn4ipx_rp301_cint_sts_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RP301_CINT_STS(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RP301_CINT_STS(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f140ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RP301_CINT_STS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RP301_CINT_STS(a,b) cavm_cprix_cn4ipx_rp301_cint_sts_t
#define bustype_CAVM_CPRIX_CN4IPX_RP301_CINT_STS(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RP301_CINT_STS(a,b) "CPRIX_CN4IPX_RP301_CINT_STS"
#define busnum_CAVM_CPRIX_CN4IPX_RP301_CINT_STS(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RP301_CINT_STS(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rp301_int_clr0
 *
 * CPRI CONN4 IP RP3-01 Interrupt Event Clear for Link 0 Register
 */
union cavm_cprix_cn4ipx_rp301_int_clr0
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rp301_int_clr0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t sh_rdy                : 1;  /**< [  6:  6](R/W1C/H) Clear for SH_RDY interrupt.
                                                                     0 = no effect.
                                                                     1 = clear interrupt status. */
        uint32_t fcb_crc               : 1;  /**< [  5:  5](R/W1C/H) Clear for FCB_CRC interrupt. */
        uint32_t fcb_txer              : 1;  /**< [  4:  4](R/W1C/H) Clear for FCB_TXER interrupt. */
        uint32_t rtts_crc              : 1;  /**< [  3:  3](R/W1C/H) Clear for RTTS_CRC interrupt. */
        uint32_t hw_r_crc              : 1;  /**< [  2:  2](R/W1C/H) Clear for HW_R_CRC interrupt. */
        uint32_t rp2eth_tser           : 1;  /**< [  1:  1](R/W1C/H) Clear for RP2ETH_TSER interrupt. */
        uint32_t eth2rpbuf             : 1;  /**< [  0:  0](R/W1C/H) Clear for ETH2RPBUF interrupt.
                                                                     0 = no effect.
                                                                     1 = clear interrupt status. */
#else /* Word 0 - Little Endian */
        uint32_t eth2rpbuf             : 1;  /**< [  0:  0](R/W1C/H) Clear for ETH2RPBUF interrupt.
                                                                     0 = no effect.
                                                                     1 = clear interrupt status. */
        uint32_t rp2eth_tser           : 1;  /**< [  1:  1](R/W1C/H) Clear for RP2ETH_TSER interrupt. */
        uint32_t hw_r_crc              : 1;  /**< [  2:  2](R/W1C/H) Clear for HW_R_CRC interrupt. */
        uint32_t rtts_crc              : 1;  /**< [  3:  3](R/W1C/H) Clear for RTTS_CRC interrupt. */
        uint32_t fcb_txer              : 1;  /**< [  4:  4](R/W1C/H) Clear for FCB_TXER interrupt. */
        uint32_t fcb_crc               : 1;  /**< [  5:  5](R/W1C/H) Clear for FCB_CRC interrupt. */
        uint32_t sh_rdy                : 1;  /**< [  6:  6](R/W1C/H) Clear for SH_RDY interrupt.
                                                                     0 = no effect.
                                                                     1 = clear interrupt status. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rp301_int_clr0_s cn; */
};
typedef union cavm_cprix_cn4ipx_rp301_int_clr0 cavm_cprix_cn4ipx_rp301_int_clr0_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RP301_INT_CLR0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RP301_INT_CLR0(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f15cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RP301_INT_CLR0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RP301_INT_CLR0(a,b) cavm_cprix_cn4ipx_rp301_int_clr0_t
#define bustype_CAVM_CPRIX_CN4IPX_RP301_INT_CLR0(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RP301_INT_CLR0(a,b) "CPRIX_CN4IPX_RP301_INT_CLR0"
#define busnum_CAVM_CPRIX_CN4IPX_RP301_INT_CLR0(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RP301_INT_CLR0(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rp301_int_clr1
 *
 * CPRI CONN4 IP RP3-01 Interrupt Event Clear for Link 1 Register
 */
union cavm_cprix_cn4ipx_rp301_int_clr1
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rp301_int_clr1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t sh_rdy                : 1;  /**< [  6:  6](R/W1C/H) Clear for SH_RDY interrupt.
                                                                     0 = no effect.
                                                                     1 = clear interrupt status. */
        uint32_t fcb_crc               : 1;  /**< [  5:  5](R/W1C/H) Clear for FCB_CRC interrupt. */
        uint32_t fcb_txer              : 1;  /**< [  4:  4](R/W1C/H) Clear for FCB_TXER interrupt. */
        uint32_t rtts_crc              : 1;  /**< [  3:  3](R/W1C/H) Clear for RTTS_CRC interrupt. */
        uint32_t hw_r_crc              : 1;  /**< [  2:  2](R/W1C/H) Clear for HW_R_CRC interrupt. */
        uint32_t rp2eth_tser           : 1;  /**< [  1:  1](R/W1C/H) Clear for RP2ETH_TSER interrupt. */
        uint32_t eth2rpbuf             : 1;  /**< [  0:  0](R/W1C/H) Clear for ETH2RPBUF interrupt.
                                                                     0 = no effect.
                                                                     1 = clear interrupt status. */
#else /* Word 0 - Little Endian */
        uint32_t eth2rpbuf             : 1;  /**< [  0:  0](R/W1C/H) Clear for ETH2RPBUF interrupt.
                                                                     0 = no effect.
                                                                     1 = clear interrupt status. */
        uint32_t rp2eth_tser           : 1;  /**< [  1:  1](R/W1C/H) Clear for RP2ETH_TSER interrupt. */
        uint32_t hw_r_crc              : 1;  /**< [  2:  2](R/W1C/H) Clear for HW_R_CRC interrupt. */
        uint32_t rtts_crc              : 1;  /**< [  3:  3](R/W1C/H) Clear for RTTS_CRC interrupt. */
        uint32_t fcb_txer              : 1;  /**< [  4:  4](R/W1C/H) Clear for FCB_TXER interrupt. */
        uint32_t fcb_crc               : 1;  /**< [  5:  5](R/W1C/H) Clear for FCB_CRC interrupt. */
        uint32_t sh_rdy                : 1;  /**< [  6:  6](R/W1C/H) Clear for SH_RDY interrupt.
                                                                     0 = no effect.
                                                                     1 = clear interrupt status. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rp301_int_clr1_s cn; */
};
typedef union cavm_cprix_cn4ipx_rp301_int_clr1 cavm_cprix_cn4ipx_rp301_int_clr1_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RP301_INT_CLR1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RP301_INT_CLR1(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f174ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RP301_INT_CLR1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RP301_INT_CLR1(a,b) cavm_cprix_cn4ipx_rp301_int_clr1_t
#define bustype_CAVM_CPRIX_CN4IPX_RP301_INT_CLR1(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RP301_INT_CLR1(a,b) "CPRIX_CN4IPX_RP301_INT_CLR1"
#define busnum_CAVM_CPRIX_CN4IPX_RP301_INT_CLR1(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RP301_INT_CLR1(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rp301_int_msk0
 *
 * CPRI CONN4 IP RP3-01 Interrupt Event Mask for Link 0 Register
 */
union cavm_cprix_cn4ipx_rp301_int_msk0
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rp301_int_msk0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t sh_rdy                : 1;  /**< [  6:  6](R/W) Mask for SH_RDY interrupt:
                                                                     0 = Interrupt enabled.
                                                                     1 = Interrupt disabled. */
        uint32_t fcb_crc               : 1;  /**< [  5:  5](R/W) Mask for FCB_CRC interrupt. */
        uint32_t fcb_txer              : 1;  /**< [  4:  4](R/W) Mask for FCB_TXER interrupt. */
        uint32_t rtts_crc              : 1;  /**< [  3:  3](R/W) Mask for RTTS_CRC interrupt. */
        uint32_t hw_r_crc              : 1;  /**< [  2:  2](R/W) Mask for HW_R_CRC interrupt. */
        uint32_t rp2eth_tser           : 1;  /**< [  1:  1](R/W) Mask for RP2ETH_TSER interrupt. */
        uint32_t eth2rpbuf             : 1;  /**< [  0:  0](R/W) Mask for ETH2RPBUF interrupt. */
#else /* Word 0 - Little Endian */
        uint32_t eth2rpbuf             : 1;  /**< [  0:  0](R/W) Mask for ETH2RPBUF interrupt. */
        uint32_t rp2eth_tser           : 1;  /**< [  1:  1](R/W) Mask for RP2ETH_TSER interrupt. */
        uint32_t hw_r_crc              : 1;  /**< [  2:  2](R/W) Mask for HW_R_CRC interrupt. */
        uint32_t rtts_crc              : 1;  /**< [  3:  3](R/W) Mask for RTTS_CRC interrupt. */
        uint32_t fcb_txer              : 1;  /**< [  4:  4](R/W) Mask for FCB_TXER interrupt. */
        uint32_t fcb_crc               : 1;  /**< [  5:  5](R/W) Mask for FCB_CRC interrupt. */
        uint32_t sh_rdy                : 1;  /**< [  6:  6](R/W) Mask for SH_RDY interrupt:
                                                                     0 = Interrupt enabled.
                                                                     1 = Interrupt disabled. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rp301_int_msk0_s cn; */
};
typedef union cavm_cprix_cn4ipx_rp301_int_msk0 cavm_cprix_cn4ipx_rp301_int_msk0_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RP301_INT_MSK0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RP301_INT_MSK0(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f164ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RP301_INT_MSK0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RP301_INT_MSK0(a,b) cavm_cprix_cn4ipx_rp301_int_msk0_t
#define bustype_CAVM_CPRIX_CN4IPX_RP301_INT_MSK0(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RP301_INT_MSK0(a,b) "CPRIX_CN4IPX_RP301_INT_MSK0"
#define busnum_CAVM_CPRIX_CN4IPX_RP301_INT_MSK0(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RP301_INT_MSK0(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rp301_int_msk1
 *
 * CPRI CONN4 IP RP3-01 Interrupt Event Mask for Link 1 Register
 */
union cavm_cprix_cn4ipx_rp301_int_msk1
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rp301_int_msk1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t sh_rdy                : 1;  /**< [  6:  6](R/W) Mask for SH_RDY interrupt:
                                                                     0 = Interrupt enabled.
                                                                     1 = Interrupt disabled. */
        uint32_t fcb_crc               : 1;  /**< [  5:  5](R/W) Mask for FCB_CRC interrupt. */
        uint32_t fcb_txer              : 1;  /**< [  4:  4](R/W) Mask for FCB_TXER interrupt. */
        uint32_t rtts_crc              : 1;  /**< [  3:  3](R/W) Mask for RTTS_CRC interrupt. */
        uint32_t hw_r_crc              : 1;  /**< [  2:  2](R/W) Mask for HW_R_CRC interrupt. */
        uint32_t rp2eth_tser           : 1;  /**< [  1:  1](R/W) Mask for RP2ETH_TSER interrupt. */
        uint32_t eth2rpbuf             : 1;  /**< [  0:  0](R/W) Mask for ETH2RPBUF interrupt. */
#else /* Word 0 - Little Endian */
        uint32_t eth2rpbuf             : 1;  /**< [  0:  0](R/W) Mask for ETH2RPBUF interrupt. */
        uint32_t rp2eth_tser           : 1;  /**< [  1:  1](R/W) Mask for RP2ETH_TSER interrupt. */
        uint32_t hw_r_crc              : 1;  /**< [  2:  2](R/W) Mask for HW_R_CRC interrupt. */
        uint32_t rtts_crc              : 1;  /**< [  3:  3](R/W) Mask for RTTS_CRC interrupt. */
        uint32_t fcb_txer              : 1;  /**< [  4:  4](R/W) Mask for FCB_TXER interrupt. */
        uint32_t fcb_crc               : 1;  /**< [  5:  5](R/W) Mask for FCB_CRC interrupt. */
        uint32_t sh_rdy                : 1;  /**< [  6:  6](R/W) Mask for SH_RDY interrupt:
                                                                     0 = Interrupt enabled.
                                                                     1 = Interrupt disabled. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rp301_int_msk1_s cn; */
};
typedef union cavm_cprix_cn4ipx_rp301_int_msk1 cavm_cprix_cn4ipx_rp301_int_msk1_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RP301_INT_MSK1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RP301_INT_MSK1(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f17cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RP301_INT_MSK1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RP301_INT_MSK1(a,b) cavm_cprix_cn4ipx_rp301_int_msk1_t
#define bustype_CAVM_CPRIX_CN4IPX_RP301_INT_MSK1(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RP301_INT_MSK1(a,b) "CPRIX_CN4IPX_RP301_INT_MSK1"
#define busnum_CAVM_CPRIX_CN4IPX_RP301_INT_MSK1(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RP301_INT_MSK1(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rp301_int_mskclr0
 *
 * CPRI CONN4 IP RP3-01 Interrupt Event Mask Clear for Link 0 Register
 */
union cavm_cprix_cn4ipx_rp301_int_mskclr0
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rp301_int_mskclr0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t sh_rdy                : 1;  /**< [  6:  6](R/W1C/H) Mask clear for SH_RDY interrupt:
                                                                     0 = no effect.
                                                                     1 = clear mask.
                                                                 Mask state is returned when read. */
        uint32_t fcb_crc               : 1;  /**< [  5:  5](R/W1C/H) Mask clear for FCB_CRC interrupt. */
        uint32_t fcb_txer              : 1;  /**< [  4:  4](R/W1C/H) Mask clear for FCB_TXER interrupt. */
        uint32_t rtts_crc              : 1;  /**< [  3:  3](R/W1C/H) Mask clear for RTTS_CRC interrupt. */
        uint32_t hw_r_crc              : 1;  /**< [  2:  2](R/W1C/H) Mask clear for HW_R_CRC interrupt. */
        uint32_t rp2eth_tser           : 1;  /**< [  1:  1](R/W1C/H) Mask clear for RP2ETH_TSER interrupt. */
        uint32_t eth2rpbuf             : 1;  /**< [  0:  0](R/W1C/H) Mask clear for ETH2RPBUF interrupt. */
#else /* Word 0 - Little Endian */
        uint32_t eth2rpbuf             : 1;  /**< [  0:  0](R/W1C/H) Mask clear for ETH2RPBUF interrupt. */
        uint32_t rp2eth_tser           : 1;  /**< [  1:  1](R/W1C/H) Mask clear for RP2ETH_TSER interrupt. */
        uint32_t hw_r_crc              : 1;  /**< [  2:  2](R/W1C/H) Mask clear for HW_R_CRC interrupt. */
        uint32_t rtts_crc              : 1;  /**< [  3:  3](R/W1C/H) Mask clear for RTTS_CRC interrupt. */
        uint32_t fcb_txer              : 1;  /**< [  4:  4](R/W1C/H) Mask clear for FCB_TXER interrupt. */
        uint32_t fcb_crc               : 1;  /**< [  5:  5](R/W1C/H) Mask clear for FCB_CRC interrupt. */
        uint32_t sh_rdy                : 1;  /**< [  6:  6](R/W1C/H) Mask clear for SH_RDY interrupt:
                                                                     0 = no effect.
                                                                     1 = clear mask.
                                                                 Mask state is returned when read. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rp301_int_mskclr0_s cn; */
};
typedef union cavm_cprix_cn4ipx_rp301_int_mskclr0 cavm_cprix_cn4ipx_rp301_int_mskclr0_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RP301_INT_MSKCLR0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RP301_INT_MSKCLR0(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f168ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RP301_INT_MSKCLR0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RP301_INT_MSKCLR0(a,b) cavm_cprix_cn4ipx_rp301_int_mskclr0_t
#define bustype_CAVM_CPRIX_CN4IPX_RP301_INT_MSKCLR0(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RP301_INT_MSKCLR0(a,b) "CPRIX_CN4IPX_RP301_INT_MSKCLR0"
#define busnum_CAVM_CPRIX_CN4IPX_RP301_INT_MSKCLR0(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RP301_INT_MSKCLR0(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rp301_int_mskclr1
 *
 * CPRI CONN4 IP RP3-01 Interrupt Event Mask Clear for Link 1 Register
 */
union cavm_cprix_cn4ipx_rp301_int_mskclr1
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rp301_int_mskclr1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t sh_rdy                : 1;  /**< [  6:  6](R/W1C/H) Mask clear for SH_RDY interrupt.
                                                                     0 = no effect.
                                                                     1 = clear mask.
                                                                 Mask state is returned when read. */
        uint32_t fcb_crc               : 1;  /**< [  5:  5](R/W1C/H) Mask clear for FCB_CRC interrupt. */
        uint32_t fcb_txer              : 1;  /**< [  4:  4](R/W1C/H) Mask clear for FCB_TXER interrupt. */
        uint32_t rtts_crc              : 1;  /**< [  3:  3](R/W1C/H) Mask clear for RTTS_CRC interrupt. */
        uint32_t hw_r_crc              : 1;  /**< [  2:  2](R/W1C/H) Mask clear for HW_R_CRC interrupt. */
        uint32_t rp2eth_tser           : 1;  /**< [  1:  1](R/W1C/H) Mask clear for RP2ETH_TSER interrupt. */
        uint32_t eth2rpbuf             : 1;  /**< [  0:  0](R/W1C/H) Mask clear for ETH2RPBUF interrupt. */
#else /* Word 0 - Little Endian */
        uint32_t eth2rpbuf             : 1;  /**< [  0:  0](R/W1C/H) Mask clear for ETH2RPBUF interrupt. */
        uint32_t rp2eth_tser           : 1;  /**< [  1:  1](R/W1C/H) Mask clear for RP2ETH_TSER interrupt. */
        uint32_t hw_r_crc              : 1;  /**< [  2:  2](R/W1C/H) Mask clear for HW_R_CRC interrupt. */
        uint32_t rtts_crc              : 1;  /**< [  3:  3](R/W1C/H) Mask clear for RTTS_CRC interrupt. */
        uint32_t fcb_txer              : 1;  /**< [  4:  4](R/W1C/H) Mask clear for FCB_TXER interrupt. */
        uint32_t fcb_crc               : 1;  /**< [  5:  5](R/W1C/H) Mask clear for FCB_CRC interrupt. */
        uint32_t sh_rdy                : 1;  /**< [  6:  6](R/W1C/H) Mask clear for SH_RDY interrupt.
                                                                     0 = no effect.
                                                                     1 = clear mask.
                                                                 Mask state is returned when read. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rp301_int_mskclr1_s cn; */
};
typedef union cavm_cprix_cn4ipx_rp301_int_mskclr1 cavm_cprix_cn4ipx_rp301_int_mskclr1_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RP301_INT_MSKCLR1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RP301_INT_MSKCLR1(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f180ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RP301_INT_MSKCLR1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RP301_INT_MSKCLR1(a,b) cavm_cprix_cn4ipx_rp301_int_mskclr1_t
#define bustype_CAVM_CPRIX_CN4IPX_RP301_INT_MSKCLR1(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RP301_INT_MSKCLR1(a,b) "CPRIX_CN4IPX_RP301_INT_MSKCLR1"
#define busnum_CAVM_CPRIX_CN4IPX_RP301_INT_MSKCLR1(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RP301_INT_MSKCLR1(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rp301_int_mskset0
 *
 * CPRI CONN4 IP RP3-01 Interrupt Event Mask Set for Link 0 Register
 */
union cavm_cprix_cn4ipx_rp301_int_mskset0
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rp301_int_mskset0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t sh_rdy                : 1;  /**< [  6:  6](R/W1S/H) Mask set for SH_RDY interrupt:
                                                                     0 = no effect.
                                                                     1 = set mask.
                                                                 Mask state is returned when read. */
        uint32_t fcb_crc               : 1;  /**< [  5:  5](R/W1S/H) Mask set for FCB_CRC interrupt. */
        uint32_t fcb_txer              : 1;  /**< [  4:  4](R/W1S/H) Mask set for FCB_TXER interrupt. */
        uint32_t rtts_crc              : 1;  /**< [  3:  3](R/W1S/H) Mask set for RTTS_CRC interrupt. */
        uint32_t hw_r_crc              : 1;  /**< [  2:  2](R/W1S/H) Mask set for HW_R_CRC interrupt. */
        uint32_t rp2eth_tser           : 1;  /**< [  1:  1](R/W1S/H) Mask set for RP2ETH_TSER interrupt. */
        uint32_t eth2rpbuf             : 1;  /**< [  0:  0](R/W1S/H) Mask set for ETH2RPBUF interrupt. */
#else /* Word 0 - Little Endian */
        uint32_t eth2rpbuf             : 1;  /**< [  0:  0](R/W1S/H) Mask set for ETH2RPBUF interrupt. */
        uint32_t rp2eth_tser           : 1;  /**< [  1:  1](R/W1S/H) Mask set for RP2ETH_TSER interrupt. */
        uint32_t hw_r_crc              : 1;  /**< [  2:  2](R/W1S/H) Mask set for HW_R_CRC interrupt. */
        uint32_t rtts_crc              : 1;  /**< [  3:  3](R/W1S/H) Mask set for RTTS_CRC interrupt. */
        uint32_t fcb_txer              : 1;  /**< [  4:  4](R/W1S/H) Mask set for FCB_TXER interrupt. */
        uint32_t fcb_crc               : 1;  /**< [  5:  5](R/W1S/H) Mask set for FCB_CRC interrupt. */
        uint32_t sh_rdy                : 1;  /**< [  6:  6](R/W1S/H) Mask set for SH_RDY interrupt:
                                                                     0 = no effect.
                                                                     1 = set mask.
                                                                 Mask state is returned when read. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rp301_int_mskset0_s cn; */
};
typedef union cavm_cprix_cn4ipx_rp301_int_mskset0 cavm_cprix_cn4ipx_rp301_int_mskset0_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RP301_INT_MSKSET0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RP301_INT_MSKSET0(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f16cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RP301_INT_MSKSET0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RP301_INT_MSKSET0(a,b) cavm_cprix_cn4ipx_rp301_int_mskset0_t
#define bustype_CAVM_CPRIX_CN4IPX_RP301_INT_MSKSET0(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RP301_INT_MSKSET0(a,b) "CPRIX_CN4IPX_RP301_INT_MSKSET0"
#define busnum_CAVM_CPRIX_CN4IPX_RP301_INT_MSKSET0(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RP301_INT_MSKSET0(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rp301_int_mskset1
 *
 * CPRI CONN4 IP RP3-01 Interrupt Event Mask Set for Link 1 Register
 */
union cavm_cprix_cn4ipx_rp301_int_mskset1
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rp301_int_mskset1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t sh_rdy                : 1;  /**< [  6:  6](R/W1S/H) Mask set for SH_RDY interrupt:
                                                                     0 = no effect.
                                                                     1 = set mask.
                                                                 Mask state is returned when read. */
        uint32_t fcb_crc               : 1;  /**< [  5:  5](R/W1S/H) Mask set for FCB_CRC interrupt. */
        uint32_t fcb_txer              : 1;  /**< [  4:  4](R/W1S/H) Mask set for FCB_TXER interrupt. */
        uint32_t rtts_crc              : 1;  /**< [  3:  3](R/W1S/H) Mask set for RTTS_CRC interrupt. */
        uint32_t hw_r_crc              : 1;  /**< [  2:  2](R/W1S/H) Mask set for HW_R_CRC interrupt. */
        uint32_t rp2eth_tser           : 1;  /**< [  1:  1](R/W1S/H) Mask set for RP2ETH_TSER interrupt. */
        uint32_t eth2rpbuf             : 1;  /**< [  0:  0](R/W1S/H) Mask set for ETH2RPBUF interrupt. */
#else /* Word 0 - Little Endian */
        uint32_t eth2rpbuf             : 1;  /**< [  0:  0](R/W1S/H) Mask set for ETH2RPBUF interrupt. */
        uint32_t rp2eth_tser           : 1;  /**< [  1:  1](R/W1S/H) Mask set for RP2ETH_TSER interrupt. */
        uint32_t hw_r_crc              : 1;  /**< [  2:  2](R/W1S/H) Mask set for HW_R_CRC interrupt. */
        uint32_t rtts_crc              : 1;  /**< [  3:  3](R/W1S/H) Mask set for RTTS_CRC interrupt. */
        uint32_t fcb_txer              : 1;  /**< [  4:  4](R/W1S/H) Mask set for FCB_TXER interrupt. */
        uint32_t fcb_crc               : 1;  /**< [  5:  5](R/W1S/H) Mask set for FCB_CRC interrupt. */
        uint32_t sh_rdy                : 1;  /**< [  6:  6](R/W1S/H) Mask set for SH_RDY interrupt:
                                                                     0 = no effect.
                                                                     1 = set mask.
                                                                 Mask state is returned when read. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rp301_int_mskset1_s cn; */
};
typedef union cavm_cprix_cn4ipx_rp301_int_mskset1 cavm_cprix_cn4ipx_rp301_int_mskset1_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RP301_INT_MSKSET1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RP301_INT_MSKSET1(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f184ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RP301_INT_MSKSET1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RP301_INT_MSKSET1(a,b) cavm_cprix_cn4ipx_rp301_int_mskset1_t
#define bustype_CAVM_CPRIX_CN4IPX_RP301_INT_MSKSET1(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RP301_INT_MSKSET1(a,b) "CPRIX_CN4IPX_RP301_INT_MSKSET1"
#define busnum_CAVM_CPRIX_CN4IPX_RP301_INT_MSKSET1(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RP301_INT_MSKSET1(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rp301_int_set0
 *
 * CPRI CONN4 IP RP3-01 Interrupt Event Set for Link 0 Register
 */
union cavm_cprix_cn4ipx_rp301_int_set0
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rp301_int_set0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t sh_rdy                : 1;  /**< [  6:  6](R/W1S/H) Set for SH_RDY interrupt:
                                                                     0 = no effect.
                                                                     1 = set interrupt status. */
        uint32_t fcb_crc               : 1;  /**< [  5:  5](R/W1S/H) Set for FCB_CRC interrupt. */
        uint32_t fcb_txer              : 1;  /**< [  4:  4](R/W1S/H) Set for FCB_TXER interrupt. */
        uint32_t rtts_crc              : 1;  /**< [  3:  3](R/W1S/H) Set for RTTS_CRC interrupt. */
        uint32_t hw_r_crc              : 1;  /**< [  2:  2](R/W1S/H) Set for HW_R_CRC interrupt. */
        uint32_t rp2eth_tser           : 1;  /**< [  1:  1](R/W1S/H) Set for RP2ETH_TSER interrupt. */
        uint32_t eth2rpbuf             : 1;  /**< [  0:  0](R/W1S/H) Set for ETH2RPBUF interrupt. */
#else /* Word 0 - Little Endian */
        uint32_t eth2rpbuf             : 1;  /**< [  0:  0](R/W1S/H) Set for ETH2RPBUF interrupt. */
        uint32_t rp2eth_tser           : 1;  /**< [  1:  1](R/W1S/H) Set for RP2ETH_TSER interrupt. */
        uint32_t hw_r_crc              : 1;  /**< [  2:  2](R/W1S/H) Set for HW_R_CRC interrupt. */
        uint32_t rtts_crc              : 1;  /**< [  3:  3](R/W1S/H) Set for RTTS_CRC interrupt. */
        uint32_t fcb_txer              : 1;  /**< [  4:  4](R/W1S/H) Set for FCB_TXER interrupt. */
        uint32_t fcb_crc               : 1;  /**< [  5:  5](R/W1S/H) Set for FCB_CRC interrupt. */
        uint32_t sh_rdy                : 1;  /**< [  6:  6](R/W1S/H) Set for SH_RDY interrupt:
                                                                     0 = no effect.
                                                                     1 = set interrupt status. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rp301_int_set0_s cn; */
};
typedef union cavm_cprix_cn4ipx_rp301_int_set0 cavm_cprix_cn4ipx_rp301_int_set0_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RP301_INT_SET0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RP301_INT_SET0(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f160ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RP301_INT_SET0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RP301_INT_SET0(a,b) cavm_cprix_cn4ipx_rp301_int_set0_t
#define bustype_CAVM_CPRIX_CN4IPX_RP301_INT_SET0(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RP301_INT_SET0(a,b) "CPRIX_CN4IPX_RP301_INT_SET0"
#define busnum_CAVM_CPRIX_CN4IPX_RP301_INT_SET0(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RP301_INT_SET0(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rp301_int_set1
 *
 * CPRI CONN4 IP RP3-01 Interrupt Event Set for Link 1 Register
 */
union cavm_cprix_cn4ipx_rp301_int_set1
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rp301_int_set1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t sh_rdy                : 1;  /**< [  6:  6](R/W1S/H) Set for SH_RDY interrupt:
                                                                     0 = no effect.
                                                                     1 = set interrupt status. */
        uint32_t fcb_crc               : 1;  /**< [  5:  5](R/W1S/H) Set for FCB_CRC interrupt. */
        uint32_t fcb_txer              : 1;  /**< [  4:  4](R/W1S/H) Set for FCB_TXER interrupt. */
        uint32_t rtts_crc              : 1;  /**< [  3:  3](R/W1S/H) Set for RTTS_CRC interrupt. */
        uint32_t hw_r_crc              : 1;  /**< [  2:  2](R/W1S/H) Set for HW_R_CRC interrupt. */
        uint32_t rp2eth_tser           : 1;  /**< [  1:  1](R/W1S/H) Set for RP2ETH_TSER interrupt. */
        uint32_t eth2rpbuf             : 1;  /**< [  0:  0](R/W1S/H) Set for ETH2RPBUF interrupt. */
#else /* Word 0 - Little Endian */
        uint32_t eth2rpbuf             : 1;  /**< [  0:  0](R/W1S/H) Set for ETH2RPBUF interrupt. */
        uint32_t rp2eth_tser           : 1;  /**< [  1:  1](R/W1S/H) Set for RP2ETH_TSER interrupt. */
        uint32_t hw_r_crc              : 1;  /**< [  2:  2](R/W1S/H) Set for HW_R_CRC interrupt. */
        uint32_t rtts_crc              : 1;  /**< [  3:  3](R/W1S/H) Set for RTTS_CRC interrupt. */
        uint32_t fcb_txer              : 1;  /**< [  4:  4](R/W1S/H) Set for FCB_TXER interrupt. */
        uint32_t fcb_crc               : 1;  /**< [  5:  5](R/W1S/H) Set for FCB_CRC interrupt. */
        uint32_t sh_rdy                : 1;  /**< [  6:  6](R/W1S/H) Set for SH_RDY interrupt:
                                                                     0 = no effect.
                                                                     1 = set interrupt status. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rp301_int_set1_s cn; */
};
typedef union cavm_cprix_cn4ipx_rp301_int_set1 cavm_cprix_cn4ipx_rp301_int_set1_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RP301_INT_SET1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RP301_INT_SET1(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f178ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RP301_INT_SET1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RP301_INT_SET1(a,b) cavm_cprix_cn4ipx_rp301_int_set1_t
#define bustype_CAVM_CPRIX_CN4IPX_RP301_INT_SET1(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RP301_INT_SET1(a,b) "CPRIX_CN4IPX_RP301_INT_SET1"
#define busnum_CAVM_CPRIX_CN4IPX_RP301_INT_SET1(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RP301_INT_SET1(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rp301_int_sts0
 *
 * CPRI CONN4 IP RP3-01 Interrupt Status for Link 0 Register
 */
union cavm_cprix_cn4ipx_rp301_int_sts0
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rp301_int_sts0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t sh_rdy                : 1;  /**< [  6:  6](RO/H) Sample and hold circuit result ready:
                                                                   0 = no interrupt.
                                                                   1 = interrupt. */
        uint32_t fcb_crc               : 1;  /**< [  5:  5](RO/H) FCB message CRC error.
                                                                   0 = CRC OK.
                                                                   1 = CRC error detected. */
        uint32_t fcb_txer              : 1;  /**< [  4:  4](RO/H) FCB transfer status.
                                                                   0 = Transfer OK.
                                                                   1 = Error at transfer.
                                                                 Indicates 9 ms timeout has elapsed in sending out FCB message. */
        uint32_t rtts_crc              : 1;  /**< [  3:  3](RO/H) RTT message CRC error.
                                                                   0 = CRC OK.
                                                                   1 = CRC error detected. */
        uint32_t hw_r_crc              : 1;  /**< [  2:  2](RO/H) Virtual HW reset message CRC error.
                                                                   0 = CRC OK.
                                                                   1 = CRC error detected. */
        uint32_t rp2eth_tser           : 1;  /**< [  1:  1](RO/H) RP3-01 to ETH time stamp error.
                                                                   0 = No time stamp error.
                                                                   1 = Time stamp error. */
        uint32_t eth2rpbuf             : 1;  /**< [  0:  0](RO/H) ETH to RP3-01 buffer status.
                                                                   0 = Buffer not full.
                                                                   1 = Buffer full. */
#else /* Word 0 - Little Endian */
        uint32_t eth2rpbuf             : 1;  /**< [  0:  0](RO/H) ETH to RP3-01 buffer status.
                                                                   0 = Buffer not full.
                                                                   1 = Buffer full. */
        uint32_t rp2eth_tser           : 1;  /**< [  1:  1](RO/H) RP3-01 to ETH time stamp error.
                                                                   0 = No time stamp error.
                                                                   1 = Time stamp error. */
        uint32_t hw_r_crc              : 1;  /**< [  2:  2](RO/H) Virtual HW reset message CRC error.
                                                                   0 = CRC OK.
                                                                   1 = CRC error detected. */
        uint32_t rtts_crc              : 1;  /**< [  3:  3](RO/H) RTT message CRC error.
                                                                   0 = CRC OK.
                                                                   1 = CRC error detected. */
        uint32_t fcb_txer              : 1;  /**< [  4:  4](RO/H) FCB transfer status.
                                                                   0 = Transfer OK.
                                                                   1 = Error at transfer.
                                                                 Indicates 9 ms timeout has elapsed in sending out FCB message. */
        uint32_t fcb_crc               : 1;  /**< [  5:  5](RO/H) FCB message CRC error.
                                                                   0 = CRC OK.
                                                                   1 = CRC error detected. */
        uint32_t sh_rdy                : 1;  /**< [  6:  6](RO/H) Sample and hold circuit result ready:
                                                                   0 = no interrupt.
                                                                   1 = interrupt. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rp301_int_sts0_s cn; */
};
typedef union cavm_cprix_cn4ipx_rp301_int_sts0 cavm_cprix_cn4ipx_rp301_int_sts0_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RP301_INT_STS0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RP301_INT_STS0(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f158ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RP301_INT_STS0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RP301_INT_STS0(a,b) cavm_cprix_cn4ipx_rp301_int_sts0_t
#define bustype_CAVM_CPRIX_CN4IPX_RP301_INT_STS0(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RP301_INT_STS0(a,b) "CPRIX_CN4IPX_RP301_INT_STS0"
#define busnum_CAVM_CPRIX_CN4IPX_RP301_INT_STS0(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RP301_INT_STS0(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rp301_int_sts1
 *
 * CPRI CONN4 IP RP3-01 Interrupt Status for Link 1 Register
 */
union cavm_cprix_cn4ipx_rp301_int_sts1
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rp301_int_sts1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t sh_rdy                : 1;  /**< [  6:  6](RO/H) Sample and hold circuit result ready:
                                                                   0 = no interrupt.
                                                                   1 = interrupt. */
        uint32_t fcb_crc               : 1;  /**< [  5:  5](RO/H) FCB message CRC error:
                                                                   0 = CRC OK.
                                                                   1 = CRC error detected. */
        uint32_t fcb_txer              : 1;  /**< [  4:  4](RO/H) FCB transfer status.
                                                                   0 = Transfer OK.
                                                                   1 = Error at transfer.
                                                                 Indicates 9 ms timeout has elapsed in sending out FCB message. */
        uint32_t rtts_crc              : 1;  /**< [  3:  3](RO/H) RTT message CRC error.
                                                                   0 = CRC OK.
                                                                   1 = CRC error detected. */
        uint32_t hw_r_crc              : 1;  /**< [  2:  2](RO/H) Virtual HW reset message CRC error.
                                                                   0 = CRC OK.
                                                                   1 = CRC error detected. */
        uint32_t rp2eth_tser           : 1;  /**< [  1:  1](RO/H) RP3-01 to ETH time stamp error.
                                                                   0 = No time stamp error.
                                                                   1 = Time stamp error. */
        uint32_t eth2rpbuf             : 1;  /**< [  0:  0](RO/H) ETH to RP3-01 buffer status.
                                                                   0 = Buffer not full.
                                                                   1 = Buffer full. */
#else /* Word 0 - Little Endian */
        uint32_t eth2rpbuf             : 1;  /**< [  0:  0](RO/H) ETH to RP3-01 buffer status.
                                                                   0 = Buffer not full.
                                                                   1 = Buffer full. */
        uint32_t rp2eth_tser           : 1;  /**< [  1:  1](RO/H) RP3-01 to ETH time stamp error.
                                                                   0 = No time stamp error.
                                                                   1 = Time stamp error. */
        uint32_t hw_r_crc              : 1;  /**< [  2:  2](RO/H) Virtual HW reset message CRC error.
                                                                   0 = CRC OK.
                                                                   1 = CRC error detected. */
        uint32_t rtts_crc              : 1;  /**< [  3:  3](RO/H) RTT message CRC error.
                                                                   0 = CRC OK.
                                                                   1 = CRC error detected. */
        uint32_t fcb_txer              : 1;  /**< [  4:  4](RO/H) FCB transfer status.
                                                                   0 = Transfer OK.
                                                                   1 = Error at transfer.
                                                                 Indicates 9 ms timeout has elapsed in sending out FCB message. */
        uint32_t fcb_crc               : 1;  /**< [  5:  5](RO/H) FCB message CRC error:
                                                                   0 = CRC OK.
                                                                   1 = CRC error detected. */
        uint32_t sh_rdy                : 1;  /**< [  6:  6](RO/H) Sample and hold circuit result ready:
                                                                   0 = no interrupt.
                                                                   1 = interrupt. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rp301_int_sts1_s cn; */
};
typedef union cavm_cprix_cn4ipx_rp301_int_sts1 cavm_cprix_cn4ipx_rp301_int_sts1_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RP301_INT_STS1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RP301_INT_STS1(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f170ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RP301_INT_STS1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RP301_INT_STS1(a,b) cavm_cprix_cn4ipx_rp301_int_sts1_t
#define bustype_CAVM_CPRIX_CN4IPX_RP301_INT_STS1(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RP301_INT_STS1(a,b) "CPRIX_CN4IPX_RP301_INT_STS1"
#define busnum_CAVM_CPRIX_CN4IPX_RP301_INT_STS1(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RP301_INT_STS1(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rp3_in1_0_ln#
 *
 * CPRI CONN4 IP RP3/WCDMA initial N1 value Register
 */
union cavm_cprix_cn4ipx_rp3_in1_0_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rp3_in1_0_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_12_31        : 20;
        uint32_t n1_0                  : 12; /**< [ 11:  0](R/W) Timer initial N1 value to which timer is synced.
                                                                 The value is represented as an unsigned 40-bit value, this register has 12 LSBs. */
#else /* Word 0 - Little Endian */
        uint32_t n1_0                  : 12; /**< [ 11:  0](R/W) Timer initial N1 value to which timer is synced.
                                                                 The value is represented as an unsigned 40-bit value, this register has 12 LSBs. */
        uint32_t reserved_12_31        : 20;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rp3_in1_0_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rp3_in1_0_lnx cavm_cprix_cn4ipx_rp3_in1_0_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RP3_IN1_0_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RP3_IN1_0_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=2)))
        return 0x86400080f064ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x14ll * ((c) & 0x3);
    __cavm_csr_fatal("CPRIX_CN4IPX_RP3_IN1_0_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RP3_IN1_0_LNX(a,b,c) cavm_cprix_cn4ipx_rp3_in1_0_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RP3_IN1_0_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RP3_IN1_0_LNX(a,b,c) "CPRIX_CN4IPX_RP3_IN1_0_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RP3_IN1_0_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RP3_IN1_0_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rp3_in1_1_ln#
 *
 * CPRI CONN4 IP RP3/WCDMA initial N1 value Register
 */
union cavm_cprix_cn4ipx_rp3_in1_1_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rp3_in1_1_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t n1_1                  : 28; /**< [ 27:  0](R/W) Timer initial N1 value to which timer is synced.
                                                                 The value is represented as an unsigned 40-bit value, this register has 28 MSBs. */
#else /* Word 0 - Little Endian */
        uint32_t n1_1                  : 28; /**< [ 27:  0](R/W) Timer initial N1 value to which timer is synced.
                                                                 The value is represented as an unsigned 40-bit value, this register has 28 MSBs. */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rp3_in1_1_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rp3_in1_1_lnx cavm_cprix_cn4ipx_rp3_in1_1_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RP3_IN1_1_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RP3_IN1_1_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=2)))
        return 0x86400080f068ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x14ll * ((c) & 0x3);
    __cavm_csr_fatal("CPRIX_CN4IPX_RP3_IN1_1_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RP3_IN1_1_LNX(a,b,c) cavm_cprix_cn4ipx_rp3_in1_1_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RP3_IN1_1_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RP3_IN1_1_LNX(a,b,c) "CPRIX_CN4IPX_RP3_IN1_1_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RP3_IN1_1_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RP3_IN1_1_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rp3_lnk_ctrl_0
 *
 * CPRI CONN4 IP RP3 LINK CTRL for Link 0 Register
 */
union cavm_cprix_cn4ipx_rp3_lnk_ctrl_0
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rp3_lnk_ctrl_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t cpri_mode             : 1;  /**< [  4:  4](R/W) CPRI mode selection for Link0:
                                                                   0 = Link is in RP3 mode.
                                                                   1 = Link is in CPRI mode.
                                                                 Mode selection should only be changed while the link is in reset. */
        uint32_t rate                  : 3;  /**< [  3:  1](R/W) Link rate for Link0.
                                                                 RP3-01 rates (bits 2:1):
                                                                   0x2 = 3072 Mbps (4x).
                                                                   0x3 = 6144 Mbps (8x).
                                                                   others = not used.

                                                                 CPRI rates (bits 3:1):
                                                                   0x1 = 2457.6 Mbps (4x).
                                                                   0x2 = 4915.2 Mbps (8x).
                                                                   0x3 = 6144.0 Mbps (10x).
                                                                   0x4 = 9830.4 Mbps (16x).
                                                                   others = Not used.

                                                                 Link rate should only be changed while the link is in reset. */
        uint32_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0            : 1;
        uint32_t rate                  : 3;  /**< [  3:  1](R/W) Link rate for Link0.
                                                                 RP3-01 rates (bits 2:1):
                                                                   0x2 = 3072 Mbps (4x).
                                                                   0x3 = 6144 Mbps (8x).
                                                                   others = not used.

                                                                 CPRI rates (bits 3:1):
                                                                   0x1 = 2457.6 Mbps (4x).
                                                                   0x2 = 4915.2 Mbps (8x).
                                                                   0x3 = 6144.0 Mbps (10x).
                                                                   0x4 = 9830.4 Mbps (16x).
                                                                   others = Not used.

                                                                 Link rate should only be changed while the link is in reset. */
        uint32_t cpri_mode             : 1;  /**< [  4:  4](R/W) CPRI mode selection for Link0:
                                                                   0 = Link is in RP3 mode.
                                                                   1 = Link is in CPRI mode.
                                                                 Mode selection should only be changed while the link is in reset. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rp3_lnk_ctrl_0_s cn; */
};
typedef union cavm_cprix_cn4ipx_rp3_lnk_ctrl_0 cavm_cprix_cn4ipx_rp3_lnk_ctrl_0_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RP3_LNK_CTRL_0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RP3_LNK_CTRL_0(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x8640008000c0ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RP3_LNK_CTRL_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RP3_LNK_CTRL_0(a,b) cavm_cprix_cn4ipx_rp3_lnk_ctrl_0_t
#define bustype_CAVM_CPRIX_CN4IPX_RP3_LNK_CTRL_0(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RP3_LNK_CTRL_0(a,b) "CPRIX_CN4IPX_RP3_LNK_CTRL_0"
#define busnum_CAVM_CPRIX_CN4IPX_RP3_LNK_CTRL_0(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RP3_LNK_CTRL_0(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rp3_lnk_ctrl_1
 *
 * CPRI CONN4 IP RP3 LINK CTRL for Link 1 Register
 */
union cavm_cprix_cn4ipx_rp3_lnk_ctrl_1
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rp3_lnk_ctrl_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t cpri_mode             : 1;  /**< [  4:  4](R/W) CPRI mode selection for Link1:
                                                                   0 = Link is in RP3 mode.
                                                                   1 = Link is in CPRI mode.
                                                                 Mode selection should only be changed while the link is in reset. */
        uint32_t rate                  : 3;  /**< [  3:  1](R/W) Link rate for Link1.
                                                                 RP3-01 rates (bits 2:1):
                                                                   0x2 = 3072 Mbps (4x).
                                                                   0x3 = 6144 Mbps (8x).
                                                                   others = not used.

                                                                 CPRI rates (bits 3:1):
                                                                   0x1 = 2457.6 Mbps (4x).
                                                                   0x2 = 4915.2 Mbps (8x).
                                                                   0x3 = 6144.0 Mbps (10x).
                                                                   0x4 = 9830.4 Mbps (16x).
                                                                   others = Not used.

                                                                 Link rate should only be changed while the link is in reset. */
        uint32_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0            : 1;
        uint32_t rate                  : 3;  /**< [  3:  1](R/W) Link rate for Link1.
                                                                 RP3-01 rates (bits 2:1):
                                                                   0x2 = 3072 Mbps (4x).
                                                                   0x3 = 6144 Mbps (8x).
                                                                   others = not used.

                                                                 CPRI rates (bits 3:1):
                                                                   0x1 = 2457.6 Mbps (4x).
                                                                   0x2 = 4915.2 Mbps (8x).
                                                                   0x3 = 6144.0 Mbps (10x).
                                                                   0x4 = 9830.4 Mbps (16x).
                                                                   others = Not used.

                                                                 Link rate should only be changed while the link is in reset. */
        uint32_t cpri_mode             : 1;  /**< [  4:  4](R/W) CPRI mode selection for Link1:
                                                                   0 = Link is in RP3 mode.
                                                                   1 = Link is in CPRI mode.
                                                                 Mode selection should only be changed while the link is in reset. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rp3_lnk_ctrl_1_s cn; */
};
typedef union cavm_cprix_cn4ipx_rp3_lnk_ctrl_1 cavm_cprix_cn4ipx_rp3_lnk_ctrl_1_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RP3_LNK_CTRL_1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RP3_LNK_CTRL_1(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x8640008000c4ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RP3_LNK_CTRL_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RP3_LNK_CTRL_1(a,b) cavm_cprix_cn4ipx_rp3_lnk_ctrl_1_t
#define bustype_CAVM_CPRIX_CN4IPX_RP3_LNK_CTRL_1(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RP3_LNK_CTRL_1(a,b) "CPRIX_CN4IPX_RP3_LNK_CTRL_1"
#define busnum_CAVM_CPRIX_CN4IPX_RP3_LNK_CTRL_1(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RP3_LNK_CTRL_1(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rp3_sn1_0_ln#
 *
 * CPRI CONN4 IP RP3/WCDMA Timer sync N1 value Register
 */
union cavm_cprix_cn4ipx_rp3_sn1_0_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rp3_sn1_0_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_13_31        : 19;
        uint32_t resync                : 1;  /**< [ 12: 12](R/W) Activate timer synchronization.

                                                                 Write:
                                                                   0 = No action
                                                                   1 = Synchronize timer

                                                                 Read:
                                                                   0 = Timer not synchronized
                                                                   1 = Timer synchronized */
        uint32_t n1_0                  : 12; /**< [ 11:  0](R/W) BCN timer N1 value when timer is synced.
                                                                 The value is represented as an unsigned 40-bit value, this register has 12 LSBs.
                                                                 When reading this is 12 LSBs of timer N1 value. */
#else /* Word 0 - Little Endian */
        uint32_t n1_0                  : 12; /**< [ 11:  0](R/W) BCN timer N1 value when timer is synced.
                                                                 The value is represented as an unsigned 40-bit value, this register has 12 LSBs.
                                                                 When reading this is 12 LSBs of timer N1 value. */
        uint32_t resync                : 1;  /**< [ 12: 12](R/W) Activate timer synchronization.

                                                                 Write:
                                                                   0 = No action
                                                                   1 = Synchronize timer

                                                                 Read:
                                                                   0 = Timer not synchronized
                                                                   1 = Timer synchronized */
        uint32_t reserved_13_31        : 19;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rp3_sn1_0_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rp3_sn1_0_lnx cavm_cprix_cn4ipx_rp3_sn1_0_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RP3_SN1_0_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RP3_SN1_0_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=2)))
        return 0x86400080f058ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x14ll * ((c) & 0x3);
    __cavm_csr_fatal("CPRIX_CN4IPX_RP3_SN1_0_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RP3_SN1_0_LNX(a,b,c) cavm_cprix_cn4ipx_rp3_sn1_0_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RP3_SN1_0_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RP3_SN1_0_LNX(a,b,c) "CPRIX_CN4IPX_RP3_SN1_0_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RP3_SN1_0_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RP3_SN1_0_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rp3_sn1_1_ln#
 *
 * CPRI CONN4 IP RP3/WCDMA Timer sync N1 value Register
 */
union cavm_cprix_cn4ipx_rp3_sn1_1_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rp3_sn1_1_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t n1_1                  : 28; /**< [ 27:  0](R/W) BCN timer N1 value when timer is synced.
                                                                 The value is represented as an unsigned 40-bit value, this register has 28 MSBs.
                                                                 When reading this is 28 MSBs of timer N1 value. */
#else /* Word 0 - Little Endian */
        uint32_t n1_1                  : 28; /**< [ 27:  0](R/W) BCN timer N1 value when timer is synced.
                                                                 The value is represented as an unsigned 40-bit value, this register has 28 MSBs.
                                                                 When reading this is 28 MSBs of timer N1 value. */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rp3_sn1_1_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rp3_sn1_1_lnx cavm_cprix_cn4ipx_rp3_sn1_1_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RP3_SN1_1_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RP3_SN1_1_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=2)))
        return 0x86400080f05cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x14ll * ((c) & 0x3);
    __cavm_csr_fatal("CPRIX_CN4IPX_RP3_SN1_1_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RP3_SN1_1_LNX(a,b,c) cavm_cprix_cn4ipx_rp3_sn1_1_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RP3_SN1_1_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RP3_SN1_1_LNX(a,b,c) "CPRIX_CN4IPX_RP3_SN1_1_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RP3_SN1_1_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RP3_SN1_1_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rp3_sn2_ln#
 *
 * CPRI CONN4 IP RP3/WCDMA Timer sync N2 value Register
 */
union cavm_cprix_cn4ipx_rp3_sn2_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rp3_sn2_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t n2                    : 28; /**< [ 27:  0](R/W) BCN timer N2 value when timer is synced.
                                                                 The value is represented as an unsigned 22-bit value.
                                                                 When reading this is timer N2 value. */
#else /* Word 0 - Little Endian */
        uint32_t n2                    : 28; /**< [ 27:  0](R/W) BCN timer N2 value when timer is synced.
                                                                 The value is represented as an unsigned 22-bit value.
                                                                 When reading this is timer N2 value. */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rp3_sn2_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rp3_sn2_lnx cavm_cprix_cn4ipx_rp3_sn2_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RP3_SN2_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RP3_SN2_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=2)))
        return 0x86400080f060ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x14ll * ((c) & 0x3);
    __cavm_csr_fatal("CPRIX_CN4IPX_RP3_SN2_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RP3_SN2_LNX(a,b,c) cavm_cprix_cn4ipx_rp3_sn2_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RP3_SN2_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RP3_SN2_LNX(a,b,c) "CPRIX_CN4IPX_RP3_SN2_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RP3_SN2_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RP3_SN2_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rx_axc_ctrlh#_ln#
 *
 * CPRI CONN4 IP  Rx AxC Control AxC 16 to 37 Register
 */
union cavm_cprix_cn4ipx_rx_axc_ctrlhx_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rx_axc_ctrlhx_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t rp3_axc_addr          : 13; /**< [ 31: 19](R/W) RP3 address of the received AxC. */
        uint32_t rp3_axc_type          : 5;  /**< [ 18: 14](R/W) RP3 type of the received AxC. */
        uint32_t rp3_axc_ts            : 8;  /**< [ 13:  6](R/W) Expected RP3 timestamp (LTE/WCDMA) or message number (GSM) of the received AxC
                                                                 in the first message of frame.
                                                                 Valid values (in decimal):
                                                                   WCDMA/LTE = 063.
                                                                   GSM DL IQ mode 0 = 011.
                                                                   GSM DL IQ mode 1 = 046.
                                                                   GSM DL IQ mode 2 = 0235.
                                                                   GSM UL HSR = 094.
                                                                   GSM UL NSR = 078. */
        uint32_t reserved_4_5          : 2;
        uint32_t rp3_axc_gsm           : 3;  /**< [  3:  1](R/W) GSM AxC type when RP3_AXC_TYPE = 0x4.
                                                                   0x0 = GSM DL IQ mode 0.
                                                                   0x1 = GSM DL IQ mode 1.
                                                                   0x2 = GSM DL IQ mode 2.
                                                                   0x3 = GSM UL HSR.
                                                                   0x4 = GSM UL NSR.
                                                                   0x5..0x7 = not valid. */
        uint32_t rp3_axc_en            : 1;  /**< [  0:  0](R/W) Enable AxC reception:
                                                                   0 = Reception disabled.
                                                                   1 = Reception enabled. */
#else /* Word 0 - Little Endian */
        uint32_t rp3_axc_en            : 1;  /**< [  0:  0](R/W) Enable AxC reception:
                                                                   0 = Reception disabled.
                                                                   1 = Reception enabled. */
        uint32_t rp3_axc_gsm           : 3;  /**< [  3:  1](R/W) GSM AxC type when RP3_AXC_TYPE = 0x4.
                                                                   0x0 = GSM DL IQ mode 0.
                                                                   0x1 = GSM DL IQ mode 1.
                                                                   0x2 = GSM DL IQ mode 2.
                                                                   0x3 = GSM UL HSR.
                                                                   0x4 = GSM UL NSR.
                                                                   0x5..0x7 = not valid. */
        uint32_t reserved_4_5          : 2;
        uint32_t rp3_axc_ts            : 8;  /**< [ 13:  6](R/W) Expected RP3 timestamp (LTE/WCDMA) or message number (GSM) of the received AxC
                                                                 in the first message of frame.
                                                                 Valid values (in decimal):
                                                                   WCDMA/LTE = 063.
                                                                   GSM DL IQ mode 0 = 011.
                                                                   GSM DL IQ mode 1 = 046.
                                                                   GSM DL IQ mode 2 = 0235.
                                                                   GSM UL HSR = 094.
                                                                   GSM UL NSR = 078. */
        uint32_t rp3_axc_type          : 5;  /**< [ 18: 14](R/W) RP3 type of the received AxC. */
        uint32_t rp3_axc_addr          : 13; /**< [ 31: 19](R/W) RP3 address of the received AxC. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rx_axc_ctrlhx_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rx_axc_ctrlhx_lnx cavm_cprix_cn4ipx_rx_axc_ctrlhx_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RX_AXC_CTRLHX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RX_AXC_CTRLHX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=21) && (d<=1)))
        return 0x864000808300ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 8ll * ((c) & 0x1f) + 0x1000ll * ((d) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RX_AXC_CTRLHX_LNX", 4, a, b, c, d, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RX_AXC_CTRLHX_LNX(a,b,c,d) cavm_cprix_cn4ipx_rx_axc_ctrlhx_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RX_AXC_CTRLHX_LNX(a,b,c,d) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RX_AXC_CTRLHX_LNX(a,b,c,d) "CPRIX_CN4IPX_RX_AXC_CTRLHX_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RX_AXC_CTRLHX_LNX(a,b,c,d) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RX_AXC_CTRLHX_LNX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) cpri#_cn4ip#_rx_axc_ctrll#_ln#
 *
 * CPRI CONN4 IP  Rx AxC Control AxC 0 to 15 Register
 */
union cavm_cprix_cn4ipx_rx_axc_ctrllx_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rx_axc_ctrllx_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t rp3_axc_addr          : 13; /**< [ 31: 19](R/W) RP3 address of the received AxC. */
        uint32_t rp3_axc_type          : 5;  /**< [ 18: 14](R/W) RP3 type of the received AxC. */
        uint32_t rp3_axc_ts            : 8;  /**< [ 13:  6](R/W) Expected RP3 timestamp (LTE/WCDMA) or message number (GSM) of the received AxC
                                                                 in the first message of frame.
                                                                 Valid values (in decimal):
                                                                   WCDMA/LTE = 063.
                                                                   GSM DL IQ mode 0 = 011.
                                                                   GSM DL IQ mode 1 = 046.
                                                                   GSM DL IQ mode 2 = 0235.
                                                                   GSM UL HSR = 094.
                                                                   GSM UL NSR = 078. */
        uint32_t reserved_4_5          : 2;
        uint32_t rp3_axc_gsm           : 3;  /**< [  3:  1](R/W) GSM AxC type when RP3_AXC_TYPE = 0x4.
                                                                   0x0 = GSM DL IQ mode 0.
                                                                   0x1 = GSM DL IQ mode 1.
                                                                   0x2 = GSM DL IQ mode 2.
                                                                   0x3 = GSM UL HSR.
                                                                   0x4 = GSM UL NSR.
                                                                   0x5..0x7 = not valid. */
        uint32_t rp3_axc_en            : 1;  /**< [  0:  0](R/W) Enable AxC reception:
                                                                   0 = Reception disabled.
                                                                   1 = Reception enabled. */
#else /* Word 0 - Little Endian */
        uint32_t rp3_axc_en            : 1;  /**< [  0:  0](R/W) Enable AxC reception:
                                                                   0 = Reception disabled.
                                                                   1 = Reception enabled. */
        uint32_t rp3_axc_gsm           : 3;  /**< [  3:  1](R/W) GSM AxC type when RP3_AXC_TYPE = 0x4.
                                                                   0x0 = GSM DL IQ mode 0.
                                                                   0x1 = GSM DL IQ mode 1.
                                                                   0x2 = GSM DL IQ mode 2.
                                                                   0x3 = GSM UL HSR.
                                                                   0x4 = GSM UL NSR.
                                                                   0x5..0x7 = not valid. */
        uint32_t reserved_4_5          : 2;
        uint32_t rp3_axc_ts            : 8;  /**< [ 13:  6](R/W) Expected RP3 timestamp (LTE/WCDMA) or message number (GSM) of the received AxC
                                                                 in the first message of frame.
                                                                 Valid values (in decimal):
                                                                   WCDMA/LTE = 063.
                                                                   GSM DL IQ mode 0 = 011.
                                                                   GSM DL IQ mode 1 = 046.
                                                                   GSM DL IQ mode 2 = 0235.
                                                                   GSM UL HSR = 094.
                                                                   GSM UL NSR = 078. */
        uint32_t rp3_axc_type          : 5;  /**< [ 18: 14](R/W) RP3 type of the received AxC. */
        uint32_t rp3_axc_addr          : 13; /**< [ 31: 19](R/W) RP3 address of the received AxC. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rx_axc_ctrllx_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rx_axc_ctrllx_lnx cavm_cprix_cn4ipx_rx_axc_ctrllx_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RX_AXC_CTRLLX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RX_AXC_CTRLLX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=15) && (d<=1)))
        return 0x864000808280ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 8ll * ((c) & 0xf) + 0x1000ll * ((d) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RX_AXC_CTRLLX_LNX", 4, a, b, c, d, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RX_AXC_CTRLLX_LNX(a,b,c,d) cavm_cprix_cn4ipx_rx_axc_ctrllx_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RX_AXC_CTRLLX_LNX(a,b,c,d) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RX_AXC_CTRLLX_LNX(a,b,c,d) "CPRIX_CN4IPX_RX_AXC_CTRLLX_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RX_AXC_CTRLLX_LNX(a,b,c,d) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RX_AXC_CTRLLX_LNX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) cpri#_cn4ip#_rx_axc_stath#_ln#
 *
 * CPRI CONN4 IP  Rx AxC Status AxC 16 to 37 Register
 */
union cavm_cprix_cn4ipx_rx_axc_stathx_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rx_axc_stathx_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t timeout_window        : 4;  /**< [  7:  4](R/W) Timeout window for the received AxC.
                                                                   0x0 = 4x (LTE20).
                                                                   0x1 = 8x (LTE15/LTE10).
                                                                   0x2 = 16x (LTE7.5/LTE5)
                                                                   0x3 = 32x (LTE3/WCDMA)
                                                                   0x4 = 64x (LTE1.4)
                                                                   0x5 = 96x (GSM DL IQ mode 2)
                                                                   0x6 = 128x
                                                                   0x7 = 192x (GSM UL HSR)
                                                                   0x8 = 256x (GSM UL NSR)
                                                                   0x9 = 384x (GSM DL IQ mode 1)
                                                                   0xA = 512x
                                                                   0xB = 1024x
                                                                   0xC = 1536x (GSM DL IQ mode 0)
                                                                   0xD = 2048x
                                                                   0xE = 4095x
                                                                   0xF = no timeout check
                                                                 Timeout window = (TIMEOUT_WINDOW + 1) x 42 x 1/307.2 MHz */
        uint32_t reserved_3            : 1;
        uint32_t axc_timeout           : 1;  /**< [  2:  2](RO/H) No matching RP3 addresses have been received during the timeout period.
                                                                   0 = Normal reception.
                                                                   1 = No message with matching RP3 address have been received during timeout period.
                                                                       AxC must be disabled and re-enabled to recover. */
        uint32_t axc_ts_mism           : 1;  /**< [  1:  1](RO/H) Mismatch in received RP3 timestamps, indicating lost messages.
                                                                   0 = Normal reception.
                                                                   1 = Mismatch in received RP3 message timestamps. AxC must be disabled and re-enabled to recover. */
        uint32_t axc_inactive          : 1;  /**< [  0:  0](RO/H) AxC has been enabled, but no messages with matching RP3 address has been received.
                                                                   0 = AxC active or disabled.
                                                                   1 = AxC enabled, but reception has not started. */
#else /* Word 0 - Little Endian */
        uint32_t axc_inactive          : 1;  /**< [  0:  0](RO/H) AxC has been enabled, but no messages with matching RP3 address has been received.
                                                                   0 = AxC active or disabled.
                                                                   1 = AxC enabled, but reception has not started. */
        uint32_t axc_ts_mism           : 1;  /**< [  1:  1](RO/H) Mismatch in received RP3 timestamps, indicating lost messages.
                                                                   0 = Normal reception.
                                                                   1 = Mismatch in received RP3 message timestamps. AxC must be disabled and re-enabled to recover. */
        uint32_t axc_timeout           : 1;  /**< [  2:  2](RO/H) No matching RP3 addresses have been received during the timeout period.
                                                                   0 = Normal reception.
                                                                   1 = No message with matching RP3 address have been received during timeout period.
                                                                       AxC must be disabled and re-enabled to recover. */
        uint32_t reserved_3            : 1;
        uint32_t timeout_window        : 4;  /**< [  7:  4](R/W) Timeout window for the received AxC.
                                                                   0x0 = 4x (LTE20).
                                                                   0x1 = 8x (LTE15/LTE10).
                                                                   0x2 = 16x (LTE7.5/LTE5)
                                                                   0x3 = 32x (LTE3/WCDMA)
                                                                   0x4 = 64x (LTE1.4)
                                                                   0x5 = 96x (GSM DL IQ mode 2)
                                                                   0x6 = 128x
                                                                   0x7 = 192x (GSM UL HSR)
                                                                   0x8 = 256x (GSM UL NSR)
                                                                   0x9 = 384x (GSM DL IQ mode 1)
                                                                   0xA = 512x
                                                                   0xB = 1024x
                                                                   0xC = 1536x (GSM DL IQ mode 0)
                                                                   0xD = 2048x
                                                                   0xE = 4095x
                                                                   0xF = no timeout check
                                                                 Timeout window = (TIMEOUT_WINDOW + 1) x 42 x 1/307.2 MHz */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rx_axc_stathx_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rx_axc_stathx_lnx cavm_cprix_cn4ipx_rx_axc_stathx_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RX_AXC_STATHX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RX_AXC_STATHX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=21) && (d<=1)))
        return 0x864000808304ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 8ll * ((c) & 0x1f) + 0x1000ll * ((d) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RX_AXC_STATHX_LNX", 4, a, b, c, d, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RX_AXC_STATHX_LNX(a,b,c,d) cavm_cprix_cn4ipx_rx_axc_stathx_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RX_AXC_STATHX_LNX(a,b,c,d) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RX_AXC_STATHX_LNX(a,b,c,d) "CPRIX_CN4IPX_RX_AXC_STATHX_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RX_AXC_STATHX_LNX(a,b,c,d) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RX_AXC_STATHX_LNX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) cpri#_cn4ip#_rx_axc_statl#_ln#
 *
 * CPRI CONN4 IP  Rx AxC Status AxC 0 to 15 Register
 */
union cavm_cprix_cn4ipx_rx_axc_statlx_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rx_axc_statlx_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t timeout_window        : 4;  /**< [  7:  4](R/W) Timeout window for the received AxC:
                                                                   0x0 = 4x (LTE20).
                                                                   0x1 = 8x (LTE15/LTE10).
                                                                   0x2 = 16x (LTE7.5/LTE5)
                                                                   0x3 = 32x (LTE3/WCDMA)
                                                                   0x4 = 64x (LTE1.4)
                                                                   0x5 = 96x (GSM DL IQ mode 2)
                                                                   0x6 = 128x
                                                                   0x7 = 192x (GSM UL HSR)
                                                                   0x8 = 256x (GSM UL NSR)
                                                                   0x9 = 384x (GSM DL IQ mode 1)
                                                                   0xA = 512x
                                                                   0xB = 1024x
                                                                   0xC = 1536x (GSM DL IQ mode 0)
                                                                   0xD = 2048x
                                                                   0xE = 4095x
                                                                   0xF = no timeout check
                                                                 Timeout window = (TIMEOUT_WINDOW + 1) x 42 x 1/307.2 MHz */
        uint32_t reserved_3            : 1;
        uint32_t axc_timeout           : 1;  /**< [  2:  2](RO/H) No matching RP3 addresses have been received during the timeout period.
                                                                   0 = Normal reception.
                                                                   1 = No message with matching RP3 address have been received during timeout period.
                                                                       AxC must be disabled and re-enabled to recover. */
        uint32_t axc_ts_mism           : 1;  /**< [  1:  1](RO/H) Mismatch in received RP3 timestamps, indicating lost messages.
                                                                   0 = Normal reception.
                                                                   1 = Mismatch in received RP3 message timestamps. AxC must be disabled and re-enabled to recover. */
        uint32_t axc_inactive          : 1;  /**< [  0:  0](RO/H) AxC has been enabled, but no messages with matching RP3 address has been received.
                                                                   0 = AxC active or disabled.
                                                                   1 = AxC enabled, but reception has not started. */
#else /* Word 0 - Little Endian */
        uint32_t axc_inactive          : 1;  /**< [  0:  0](RO/H) AxC has been enabled, but no messages with matching RP3 address has been received.
                                                                   0 = AxC active or disabled.
                                                                   1 = AxC enabled, but reception has not started. */
        uint32_t axc_ts_mism           : 1;  /**< [  1:  1](RO/H) Mismatch in received RP3 timestamps, indicating lost messages.
                                                                   0 = Normal reception.
                                                                   1 = Mismatch in received RP3 message timestamps. AxC must be disabled and re-enabled to recover. */
        uint32_t axc_timeout           : 1;  /**< [  2:  2](RO/H) No matching RP3 addresses have been received during the timeout period.
                                                                   0 = Normal reception.
                                                                   1 = No message with matching RP3 address have been received during timeout period.
                                                                       AxC must be disabled and re-enabled to recover. */
        uint32_t reserved_3            : 1;
        uint32_t timeout_window        : 4;  /**< [  7:  4](R/W) Timeout window for the received AxC:
                                                                   0x0 = 4x (LTE20).
                                                                   0x1 = 8x (LTE15/LTE10).
                                                                   0x2 = 16x (LTE7.5/LTE5)
                                                                   0x3 = 32x (LTE3/WCDMA)
                                                                   0x4 = 64x (LTE1.4)
                                                                   0x5 = 96x (GSM DL IQ mode 2)
                                                                   0x6 = 128x
                                                                   0x7 = 192x (GSM UL HSR)
                                                                   0x8 = 256x (GSM UL NSR)
                                                                   0x9 = 384x (GSM DL IQ mode 1)
                                                                   0xA = 512x
                                                                   0xB = 1024x
                                                                   0xC = 1536x (GSM DL IQ mode 0)
                                                                   0xD = 2048x
                                                                   0xE = 4095x
                                                                   0xF = no timeout check
                                                                 Timeout window = (TIMEOUT_WINDOW + 1) x 42 x 1/307.2 MHz */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rx_axc_statlx_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rx_axc_statlx_lnx cavm_cprix_cn4ipx_rx_axc_statlx_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RX_AXC_STATLX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RX_AXC_STATLX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=15) && (d<=1)))
        return 0x864000808284ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 8ll * ((c) & 0xf) + 0x1000ll * ((d) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RX_AXC_STATLX_LNX", 4, a, b, c, d, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RX_AXC_STATLX_LNX(a,b,c,d) cavm_cprix_cn4ipx_rx_axc_statlx_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RX_AXC_STATLX_LNX(a,b,c,d) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RX_AXC_STATLX_LNX(a,b,c,d) "CPRIX_CN4IPX_RX_AXC_STATLX_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RX_AXC_STATLX_LNX(a,b,c,d) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RX_AXC_STATLX_LNX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) cpri#_cn4ip#_rx_ber_acen_ln#
 *
 * CPRI CONN4 IP Functional BER RX Antenna Carrier Enable Register
 */
union cavm_cprix_cn4ipx_rx_ber_acen_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rx_ber_acen_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t rx_carr_en31          : 1;  /**< [ 31: 31](R/W) Enable Functional BER reception for Antenna Carrier 31.
                                                                   0 = BER reception disabled.
                                                                   1 = BER reception enabled. */
        uint32_t rx_carr_en30          : 1;  /**< [ 30: 30](R/W) Enable Functional BER reception for Antenna Carrier 30. */
        uint32_t rx_carr_en29          : 1;  /**< [ 29: 29](R/W) Enable Functional BER reception for Antenna Carrier 29. */
        uint32_t rx_carr_en28          : 1;  /**< [ 28: 28](R/W) Enable Functional BER reception for Antenna Carrier 28. */
        uint32_t rx_carr_en27          : 1;  /**< [ 27: 27](R/W) Enable Functional BER reception for Antenna Carrier 27. */
        uint32_t rx_carr_en26          : 1;  /**< [ 26: 26](R/W) Enable Functional BER reception for Antenna Carrier 26. */
        uint32_t rx_carr_en25          : 1;  /**< [ 25: 25](R/W) Enable Functional BER reception for Antenna Carrier 25. */
        uint32_t rx_carr_en24          : 1;  /**< [ 24: 24](R/W) Enable Functional BER reception for Antenna Carrier 24. */
        uint32_t rx_carr_en23          : 1;  /**< [ 23: 23](R/W) Enable Functional BER reception for Antenna Carrier 23. */
        uint32_t rx_carr_en22          : 1;  /**< [ 22: 22](R/W) Enable Functional BER reception for Antenna Carrier 22. */
        uint32_t rx_carr_en21          : 1;  /**< [ 21: 21](R/W) Enable Functional BER reception for Antenna Carrier 21. */
        uint32_t rx_carr_en20          : 1;  /**< [ 20: 20](R/W) Enable Functional BER reception for Antenna Carrier 20. */
        uint32_t rx_carr_en19          : 1;  /**< [ 19: 19](R/W) Enable Functional BER reception for Antenna Carrier 19. */
        uint32_t rx_carr_en18          : 1;  /**< [ 18: 18](R/W) Enable Functional BER reception for Antenna Carrier 18. */
        uint32_t rx_carr_en17          : 1;  /**< [ 17: 17](R/W) Enable Functional BER reception for Antenna Carrier 17. */
        uint32_t rx_carr_en16          : 1;  /**< [ 16: 16](R/W) Enable Functional BER reception for Antenna Carrier 16. */
        uint32_t rx_carr_en15          : 1;  /**< [ 15: 15](R/W) Enable Functional BER reception for Antenna Carrier 15. */
        uint32_t rx_carr_en14          : 1;  /**< [ 14: 14](R/W) Enable Functional BER reception for Antenna Carrier 14. */
        uint32_t rx_carr_en13          : 1;  /**< [ 13: 13](R/W) Enable Functional BER reception for Antenna Carrier 13. */
        uint32_t rx_carr_en12          : 1;  /**< [ 12: 12](R/W) Enable Functional BER reception for Antenna Carrier 12. */
        uint32_t rx_carr_en11          : 1;  /**< [ 11: 11](R/W) Enable Functional BER reception for Antenna Carrier 11. */
        uint32_t rx_carr_en10          : 1;  /**< [ 10: 10](R/W) Enable Functional BER reception for Antenna Carrier 10. */
        uint32_t rx_carr_en9           : 1;  /**< [  9:  9](R/W) Enable Functional BER reception for Antenna Carrier 9. */
        uint32_t rx_carr_en8           : 1;  /**< [  8:  8](R/W) Enable Functional BER reception for Antenna Carrier 8. */
        uint32_t rx_carr_en7           : 1;  /**< [  7:  7](R/W) Enable Functional BER reception for Antenna Carrier 7. */
        uint32_t rx_carr_en6           : 1;  /**< [  6:  6](R/W) Enable Functional BER reception for Antenna Carrier 6. */
        uint32_t rx_carr_en5           : 1;  /**< [  5:  5](R/W) Enable Functional BER reception for Antenna Carrier 5. */
        uint32_t rx_carr_en4           : 1;  /**< [  4:  4](R/W) Enable Functional BER reception for Antenna Carrier 4. */
        uint32_t rx_carr_en3           : 1;  /**< [  3:  3](R/W) Enable Functional BER reception for Antenna Carrier 3. */
        uint32_t rx_carr_en2           : 1;  /**< [  2:  2](R/W) Enable Functional BER reception for Antenna Carrier 2. */
        uint32_t rx_carr_en1           : 1;  /**< [  1:  1](R/W) Enable Functional BER reception for Antenna Carrier 1. */
        uint32_t rx_carr_en0           : 1;  /**< [  0:  0](R/W) Enable Functional BER reception for Antenna Carrier 0. */
#else /* Word 0 - Little Endian */
        uint32_t rx_carr_en0           : 1;  /**< [  0:  0](R/W) Enable Functional BER reception for Antenna Carrier 0. */
        uint32_t rx_carr_en1           : 1;  /**< [  1:  1](R/W) Enable Functional BER reception for Antenna Carrier 1. */
        uint32_t rx_carr_en2           : 1;  /**< [  2:  2](R/W) Enable Functional BER reception for Antenna Carrier 2. */
        uint32_t rx_carr_en3           : 1;  /**< [  3:  3](R/W) Enable Functional BER reception for Antenna Carrier 3. */
        uint32_t rx_carr_en4           : 1;  /**< [  4:  4](R/W) Enable Functional BER reception for Antenna Carrier 4. */
        uint32_t rx_carr_en5           : 1;  /**< [  5:  5](R/W) Enable Functional BER reception for Antenna Carrier 5. */
        uint32_t rx_carr_en6           : 1;  /**< [  6:  6](R/W) Enable Functional BER reception for Antenna Carrier 6. */
        uint32_t rx_carr_en7           : 1;  /**< [  7:  7](R/W) Enable Functional BER reception for Antenna Carrier 7. */
        uint32_t rx_carr_en8           : 1;  /**< [  8:  8](R/W) Enable Functional BER reception for Antenna Carrier 8. */
        uint32_t rx_carr_en9           : 1;  /**< [  9:  9](R/W) Enable Functional BER reception for Antenna Carrier 9. */
        uint32_t rx_carr_en10          : 1;  /**< [ 10: 10](R/W) Enable Functional BER reception for Antenna Carrier 10. */
        uint32_t rx_carr_en11          : 1;  /**< [ 11: 11](R/W) Enable Functional BER reception for Antenna Carrier 11. */
        uint32_t rx_carr_en12          : 1;  /**< [ 12: 12](R/W) Enable Functional BER reception for Antenna Carrier 12. */
        uint32_t rx_carr_en13          : 1;  /**< [ 13: 13](R/W) Enable Functional BER reception for Antenna Carrier 13. */
        uint32_t rx_carr_en14          : 1;  /**< [ 14: 14](R/W) Enable Functional BER reception for Antenna Carrier 14. */
        uint32_t rx_carr_en15          : 1;  /**< [ 15: 15](R/W) Enable Functional BER reception for Antenna Carrier 15. */
        uint32_t rx_carr_en16          : 1;  /**< [ 16: 16](R/W) Enable Functional BER reception for Antenna Carrier 16. */
        uint32_t rx_carr_en17          : 1;  /**< [ 17: 17](R/W) Enable Functional BER reception for Antenna Carrier 17. */
        uint32_t rx_carr_en18          : 1;  /**< [ 18: 18](R/W) Enable Functional BER reception for Antenna Carrier 18. */
        uint32_t rx_carr_en19          : 1;  /**< [ 19: 19](R/W) Enable Functional BER reception for Antenna Carrier 19. */
        uint32_t rx_carr_en20          : 1;  /**< [ 20: 20](R/W) Enable Functional BER reception for Antenna Carrier 20. */
        uint32_t rx_carr_en21          : 1;  /**< [ 21: 21](R/W) Enable Functional BER reception for Antenna Carrier 21. */
        uint32_t rx_carr_en22          : 1;  /**< [ 22: 22](R/W) Enable Functional BER reception for Antenna Carrier 22. */
        uint32_t rx_carr_en23          : 1;  /**< [ 23: 23](R/W) Enable Functional BER reception for Antenna Carrier 23. */
        uint32_t rx_carr_en24          : 1;  /**< [ 24: 24](R/W) Enable Functional BER reception for Antenna Carrier 24. */
        uint32_t rx_carr_en25          : 1;  /**< [ 25: 25](R/W) Enable Functional BER reception for Antenna Carrier 25. */
        uint32_t rx_carr_en26          : 1;  /**< [ 26: 26](R/W) Enable Functional BER reception for Antenna Carrier 26. */
        uint32_t rx_carr_en27          : 1;  /**< [ 27: 27](R/W) Enable Functional BER reception for Antenna Carrier 27. */
        uint32_t rx_carr_en28          : 1;  /**< [ 28: 28](R/W) Enable Functional BER reception for Antenna Carrier 28. */
        uint32_t rx_carr_en29          : 1;  /**< [ 29: 29](R/W) Enable Functional BER reception for Antenna Carrier 29. */
        uint32_t rx_carr_en30          : 1;  /**< [ 30: 30](R/W) Enable Functional BER reception for Antenna Carrier 30. */
        uint32_t rx_carr_en31          : 1;  /**< [ 31: 31](R/W) Enable Functional BER reception for Antenna Carrier 31.
                                                                   0 = BER reception disabled.
                                                                   1 = BER reception enabled. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rx_ber_acen_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rx_ber_acen_lnx cavm_cprix_cn4ipx_rx_ber_acen_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RX_BER_ACEN_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RX_BER_ACEN_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000808168ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RX_BER_ACEN_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RX_BER_ACEN_LNX(a,b,c) cavm_cprix_cn4ipx_rx_ber_acen_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RX_BER_ACEN_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RX_BER_ACEN_LNX(a,b,c) "CPRIX_CN4IPX_RX_BER_ACEN_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RX_BER_ACEN_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RX_BER_ACEN_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rx_ber_cten_ln#
 *
 * CPRI CONN4 IP Functional BER RX Control Slot Enable Register
 */
union cavm_cprix_cn4ipx_rx_ber_cten_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rx_ber_cten_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t rx_ctrl_en7           : 1;  /**< [  7:  7](R/W) Enable Functional BER reception for Control Slot 7:
                                                                   0 = BER reception disabled.
                                                                   1 = BER reception enabled. */
        uint32_t rx_ctrl_en6           : 1;  /**< [  6:  6](R/W) Enable Functional BER reception for Control Slot 6. */
        uint32_t rx_ctrl_en5           : 1;  /**< [  5:  5](R/W) Enable Functional BER reception for Control Slot 5. */
        uint32_t rx_ctrl_en4           : 1;  /**< [  4:  4](R/W) Enable Functional BER reception for Control Slot 4. */
        uint32_t rx_ctrl_en3           : 1;  /**< [  3:  3](R/W) Enable Functional BER reception for Control Slot 3. */
        uint32_t rx_ctrl_en2           : 1;  /**< [  2:  2](R/W) Enable Functional BER reception for Control Slot 2. */
        uint32_t rx_ctrl_en1           : 1;  /**< [  1:  1](R/W) Enable Functional BER reception for Control Slot 1. */
        uint32_t rx_ctrl_en0           : 1;  /**< [  0:  0](R/W) Enable Functional BER reception for Control Slot 0. */
#else /* Word 0 - Little Endian */
        uint32_t rx_ctrl_en0           : 1;  /**< [  0:  0](R/W) Enable Functional BER reception for Control Slot 0. */
        uint32_t rx_ctrl_en1           : 1;  /**< [  1:  1](R/W) Enable Functional BER reception for Control Slot 1. */
        uint32_t rx_ctrl_en2           : 1;  /**< [  2:  2](R/W) Enable Functional BER reception for Control Slot 2. */
        uint32_t rx_ctrl_en3           : 1;  /**< [  3:  3](R/W) Enable Functional BER reception for Control Slot 3. */
        uint32_t rx_ctrl_en4           : 1;  /**< [  4:  4](R/W) Enable Functional BER reception for Control Slot 4. */
        uint32_t rx_ctrl_en5           : 1;  /**< [  5:  5](R/W) Enable Functional BER reception for Control Slot 5. */
        uint32_t rx_ctrl_en6           : 1;  /**< [  6:  6](R/W) Enable Functional BER reception for Control Slot 6. */
        uint32_t rx_ctrl_en7           : 1;  /**< [  7:  7](R/W) Enable Functional BER reception for Control Slot 7:
                                                                   0 = BER reception disabled.
                                                                   1 = BER reception enabled. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rx_ber_cten_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rx_ber_cten_lnx cavm_cprix_cn4ipx_rx_ber_cten_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RX_BER_CTEN_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RX_BER_CTEN_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x86400080816cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RX_BER_CTEN_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RX_BER_CTEN_LNX(a,b,c) cavm_cprix_cn4ipx_rx_ber_cten_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RX_BER_CTEN_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RX_BER_CTEN_LNX(a,b,c) "CPRIX_CN4IPX_RX_BER_CTEN_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RX_BER_CTEN_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RX_BER_CTEN_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rx_ber_frcnt_ln#
 *
 * CPRI CONN4 IP Functional BER Checked Frame Count Register
 */
union cavm_cprix_cn4ipx_rx_ber_frcnt_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rx_ber_frcnt_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t frame_count           : 32; /**< [ 31:  0](R/W) Count of the checked frames for PRBS, CJPAT, JSPAT, JTSPAT and Functional BER measurements.
                                                                 Counter value increments for each checked 10 ms master frame.
                                                                 Counter saturates to the maximum value. Writing 0x0 to the register clears the count. */
#else /* Word 0 - Little Endian */
        uint32_t frame_count           : 32; /**< [ 31:  0](R/W) Count of the checked frames for PRBS, CJPAT, JSPAT, JTSPAT and Functional BER measurements.
                                                                 Counter value increments for each checked 10 ms master frame.
                                                                 Counter saturates to the maximum value. Writing 0x0 to the register clears the count. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rx_ber_frcnt_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rx_ber_frcnt_lnx cavm_cprix_cn4ipx_rx_ber_frcnt_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RX_BER_FRCNT_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RX_BER_FRCNT_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000808170ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RX_BER_FRCNT_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RX_BER_FRCNT_LNX(a,b,c) cavm_cprix_cn4ipx_rx_ber_frcnt_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RX_BER_FRCNT_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RX_BER_FRCNT_LNX(a,b,c) "CPRIX_CN4IPX_RX_BER_FRCNT_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RX_BER_FRCNT_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RX_BER_FRCNT_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rx_blk_size_ln#
 *
 * CPRI CONN4 IP RX State Machine BLOCK_SIZE Register
 */
union cavm_cprix_cn4ipx_rx_blk_size_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rx_blk_size_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t block_size            : 16; /**< [ 15:  0](R/W) Number of bytes in a block.
                                                                 Defines the number of bytes that must be received without errors to declare a valid block.
                                                                 Value of BLOCK_SIZE must be even. Odd values are not supported. */
#else /* Word 0 - Little Endian */
        uint32_t block_size            : 16; /**< [ 15:  0](R/W) Number of bytes in a block.
                                                                 Defines the number of bytes that must be received without errors to declare a valid block.
                                                                 Value of BLOCK_SIZE must be even. Odd values are not supported. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rx_blk_size_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rx_blk_size_lnx cavm_cprix_cn4ipx_rx_blk_size_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RX_BLK_SIZE_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RX_BLK_SIZE_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000808008ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RX_BLK_SIZE_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RX_BLK_SIZE_LNX(a,b,c) cavm_cprix_cn4ipx_rx_blk_size_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RX_BLK_SIZE_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RX_BLK_SIZE_LNX(a,b,c) "CPRIX_CN4IPX_RX_BLK_SIZE_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RX_BLK_SIZE_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RX_BLK_SIZE_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rx_ckfifo_lvl_ln#
 *
 * CPRI CONN4 IP RX Clock Crossing FIFO fill level Register
 */
union cavm_cprix_cn4ipx_rx_ckfifo_lvl_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rx_ckfifo_lvl_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_9_31         : 23;
        uint32_t rx_ckfifo_lvl         : 9;  /**< [  8:  0](RO/H) RX clock crossing FIFO fill level. When the FIFO is synchronized, this register
                                                                 gets the initial value of RX_CKFIFO_THR. */
#else /* Word 0 - Little Endian */
        uint32_t rx_ckfifo_lvl         : 9;  /**< [  8:  0](RO/H) RX clock crossing FIFO fill level. When the FIFO is synchronized, this register
                                                                 gets the initial value of RX_CKFIFO_THR. */
        uint32_t reserved_9_31         : 23;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rx_ckfifo_lvl_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rx_ckfifo_lvl_lnx cavm_cprix_cn4ipx_rx_ckfifo_lvl_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RX_CKFIFO_LVL_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RX_CKFIFO_LVL_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x86400080804cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RX_CKFIFO_LVL_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RX_CKFIFO_LVL_LNX(a,b,c) cavm_cprix_cn4ipx_rx_ckfifo_lvl_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RX_CKFIFO_LVL_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RX_CKFIFO_LVL_LNX(a,b,c) "CPRIX_CN4IPX_RX_CKFIFO_LVL_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RX_CKFIFO_LVL_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RX_CKFIFO_LVL_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rx_ckfifo_thr_ln#
 *
 * CPRI CONN4 IP RX Clock Crossing FIFO initial fill level Register
 */
union cavm_cprix_cn4ipx_rx_ckfifo_thr_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rx_ckfifo_thr_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_29_31        : 3;
        uint32_t force_s               : 1;  /**< [ 28: 28](R/W/H) Force CPRX clock crossing FIFO to immediately adjust its fill level to the value
                                                                 of field CRX_CKFIFO_THR.
                                                                   0 = do not force.
                                                                   1 = force. */
        uint32_t reserved_25_27        : 3;
        uint32_t delta                 : 9;  /**< [ 24: 16](R/W) Clock crossing FIFO read pointer shift value to be forced.
                                                                 Value is two's complement. Adjustment is applied when one is written to FORCE field. */
        uint32_t reserved_9_15         : 7;
        uint32_t rx_ckfifo_thr         : 9;  /**< [  8:  0](R/W) RX clock crossing FIFO initial fill level. Minimum setting is 4.
                                                                 The maximum setting is 0x1FD. */
#else /* Word 0 - Little Endian */
        uint32_t rx_ckfifo_thr         : 9;  /**< [  8:  0](R/W) RX clock crossing FIFO initial fill level. Minimum setting is 4.
                                                                 The maximum setting is 0x1FD. */
        uint32_t reserved_9_15         : 7;
        uint32_t delta                 : 9;  /**< [ 24: 16](R/W) Clock crossing FIFO read pointer shift value to be forced.
                                                                 Value is two's complement. Adjustment is applied when one is written to FORCE field. */
        uint32_t reserved_25_27        : 3;
        uint32_t force_s               : 1;  /**< [ 28: 28](R/W/H) Force CPRX clock crossing FIFO to immediately adjust its fill level to the value
                                                                 of field CRX_CKFIFO_THR.
                                                                   0 = do not force.
                                                                   1 = force. */
        uint32_t reserved_29_31        : 3;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rx_ckfifo_thr_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rx_ckfifo_thr_lnx cavm_cprix_cn4ipx_rx_ckfifo_thr_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RX_CKFIFO_THR_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RX_CKFIFO_THR_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000808048ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RX_CKFIFO_THR_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RX_CKFIFO_THR_LNX(a,b,c) cavm_cprix_cn4ipx_rx_ckfifo_thr_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RX_CKFIFO_THR_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RX_CKFIFO_THR_LNX(a,b,c) "CPRIX_CN4IPX_RX_CKFIFO_THR_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RX_CKFIFO_THR_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RX_CKFIFO_THR_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rx_ctrl_ln#
 *
 * CPRI CONN4 IP RX Reception Control Register
 */
union cavm_cprix_cn4ipx_rx_ctrl_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rx_ctrl_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_14_31        : 18;
        uint32_t comma_in_sync         : 1;  /**< [ 13: 13](RO/H) Alignment status of the last received comma character:
                                                                   0 = Comma was received out of alignment (alignment changed).
                                                                   1 = Comma was received in current alignment (alignment stays the same). */
        uint32_t comma_shift_cnt       : 5;  /**< [ 12:  8](RO/H) Amount of bits shifted from serial data to get comma alignment. */
        uint32_t rx_k30_7_lcv          : 1;  /**< [  7:  7](R/W) Select if K30.7 characters are counted as LCVs:
                                                                   0 = K30.7 characters are not counted as LCVs.
                                                                   1 = K30.7 characters are counted as LCVs. */
        uint32_t rx_disp_lcv_sel       : 1;  /**< [  6:  6](R/W) Select if disparity errors are counted as LCVs:
                                                                   0 = Disparity errors are counted as LCVs.
                                                                   1 = Disparity errors are not counted as LCVs. */
        uint32_t rx_comma_h            : 1;  /**< [  5:  5](RO/H) Last aligned comma detected on higher 10 bits of incoming 20-bit data. */
        uint32_t rx_comma_l            : 1;  /**< [  4:  4](RO/H) Last aligned comma detected on lower 10 bits of incoming 20-bit data. */
        uint32_t rx_dec_lock_dis       : 1;  /**< [  3:  3](R/W) 10b/8b comma detect byte alignment locking disable:
                                                                   0 = Comma detect byte alignment locked when RX state machine is out of UNSYNC
                                                                 state (out of LOS in CPRI mode).
                                                                   1 = Comma detect byte alignment is always active. */
        uint32_t rx_fwd_ena            : 1;  /**< [  2:  2](RO/H) Message forwarding to switched router enabled:
                                                                   0 = Message forwarding is not enabled (out of link alignment or forwarding is disabled).
                                                                   1 = Messages are forwarded according to register RX_FW_TYPE_EN. */
        uint32_t rx_dis_fwd            : 1;  /**< [  1:  1](R/W) Disable message forwarding to switched router:
                                                                   0 = Normal operation. Messages are forwarded, if the link is properly aligned.
                                                                   1 = Message forwarding is disabled. Only Connectivity terminated messages are received. */
        uint32_t rx_rcv_ena            : 1;  /**< [  0:  0](R/W) Reception enable:
                                                                   0 = Receive Disable.
                                                                   1 = Receive Enable. */
#else /* Word 0 - Little Endian */
        uint32_t rx_rcv_ena            : 1;  /**< [  0:  0](R/W) Reception enable:
                                                                   0 = Receive Disable.
                                                                   1 = Receive Enable. */
        uint32_t rx_dis_fwd            : 1;  /**< [  1:  1](R/W) Disable message forwarding to switched router:
                                                                   0 = Normal operation. Messages are forwarded, if the link is properly aligned.
                                                                   1 = Message forwarding is disabled. Only Connectivity terminated messages are received. */
        uint32_t rx_fwd_ena            : 1;  /**< [  2:  2](RO/H) Message forwarding to switched router enabled:
                                                                   0 = Message forwarding is not enabled (out of link alignment or forwarding is disabled).
                                                                   1 = Messages are forwarded according to register RX_FW_TYPE_EN. */
        uint32_t rx_dec_lock_dis       : 1;  /**< [  3:  3](R/W) 10b/8b comma detect byte alignment locking disable:
                                                                   0 = Comma detect byte alignment locked when RX state machine is out of UNSYNC
                                                                 state (out of LOS in CPRI mode).
                                                                   1 = Comma detect byte alignment is always active. */
        uint32_t rx_comma_l            : 1;  /**< [  4:  4](RO/H) Last aligned comma detected on lower 10 bits of incoming 20-bit data. */
        uint32_t rx_comma_h            : 1;  /**< [  5:  5](RO/H) Last aligned comma detected on higher 10 bits of incoming 20-bit data. */
        uint32_t rx_disp_lcv_sel       : 1;  /**< [  6:  6](R/W) Select if disparity errors are counted as LCVs:
                                                                   0 = Disparity errors are counted as LCVs.
                                                                   1 = Disparity errors are not counted as LCVs. */
        uint32_t rx_k30_7_lcv          : 1;  /**< [  7:  7](R/W) Select if K30.7 characters are counted as LCVs:
                                                                   0 = K30.7 characters are not counted as LCVs.
                                                                   1 = K30.7 characters are counted as LCVs. */
        uint32_t comma_shift_cnt       : 5;  /**< [ 12:  8](RO/H) Amount of bits shifted from serial data to get comma alignment. */
        uint32_t comma_in_sync         : 1;  /**< [ 13: 13](RO/H) Alignment status of the last received comma character:
                                                                   0 = Comma was received out of alignment (alignment changed).
                                                                   1 = Comma was received in current alignment (alignment stays the same). */
        uint32_t reserved_14_31        : 18;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rx_ctrl_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rx_ctrl_lnx cavm_cprix_cn4ipx_rx_ctrl_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RX_CTRL_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RX_CTRL_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x86400080801cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RX_CTRL_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RX_CTRL_LNX(a,b,c) cavm_cprix_cn4ipx_rx_ctrl_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RX_CTRL_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RX_CTRL_LNX(a,b,c) "CPRIX_CN4IPX_RX_CTRL_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RX_CTRL_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RX_CTRL_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rx_debug_ln#
 *
 * CPRI CONN4 IP RX DEBUG Register
 */
union cavm_cprix_cn4ipx_rx_debug_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rx_debug_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_13_31        : 19;
        uint32_t rx_idle_seed_capt     : 1;  /**< [ 12: 12](RO/H) IDLE Seed captured and validated. */
        uint32_t rx_idle_seed_check    : 1;  /**< [ 11: 11](RO/H) IDLE seed validation ongoing. */
        uint32_t rx_idle_ack_det       : 1;  /**< [ 10: 10](RO/H) IDLE_ACK pattern detected. */
        uint32_t rx_idle_req_det       : 1;  /**< [  9:  9](RO/H) IDLE_REQ pattern detected. */
        uint32_t rx_idle_zero          : 1;  /**< [  8:  8](RO/H) All zero idle pattern received. */
        uint32_t reserved_7            : 1;
        uint32_t rx_debug_seed         : 7;  /**< [  6:  0](RO/H) Scrambling seed captured by receiver. */
#else /* Word 0 - Little Endian */
        uint32_t rx_debug_seed         : 7;  /**< [  6:  0](RO/H) Scrambling seed captured by receiver. */
        uint32_t reserved_7            : 1;
        uint32_t rx_idle_zero          : 1;  /**< [  8:  8](RO/H) All zero idle pattern received. */
        uint32_t rx_idle_req_det       : 1;  /**< [  9:  9](RO/H) IDLE_REQ pattern detected. */
        uint32_t rx_idle_ack_det       : 1;  /**< [ 10: 10](RO/H) IDLE_ACK pattern detected. */
        uint32_t rx_idle_seed_check    : 1;  /**< [ 11: 11](RO/H) IDLE seed validation ongoing. */
        uint32_t rx_idle_seed_capt     : 1;  /**< [ 12: 12](RO/H) IDLE Seed captured and validated. */
        uint32_t reserved_13_31        : 19;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rx_debug_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rx_debug_lnx cavm_cprix_cn4ipx_rx_debug_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RX_DEBUG_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RX_DEBUG_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000808050ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RX_DEBUG_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RX_DEBUG_LNX(a,b,c) cavm_cprix_cn4ipx_rx_debug_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RX_DEBUG_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RX_DEBUG_LNX(a,b,c) "CPRIX_CN4IPX_RX_DEBUG_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RX_DEBUG_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RX_DEBUG_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rx_fr_synct_ln#
 *
 * CPRI CONN4 IP RX State Machine FRAME_SYNC_T and FRAME_UNSYNC_T Parameter Register
 */
union cavm_cprix_cn4ipx_rx_fr_synct_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rx_fr_synct_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t frame_unsync_t        : 16; /**< [ 31: 16](R/W) The number of consecutive invalid message groups that must be received to
                                                                 transition the RX state machine from the FRAME_SYNC state to the
                                                                 WAIT_FOR_K28.7_IDLES state. */
        uint32_t frame_sync_t          : 16; /**< [ 15:  0](R/W) The number of consecutive valid message groups that must be received to
                                                                 transition the RX state machine from the  WAIT_FOR_K28.7_IDLES state to the
                                                                 FRAME_SYNC state. */
#else /* Word 0 - Little Endian */
        uint32_t frame_sync_t          : 16; /**< [ 15:  0](R/W) The number of consecutive valid message groups that must be received to
                                                                 transition the RX state machine from the  WAIT_FOR_K28.7_IDLES state to the
                                                                 FRAME_SYNC state. */
        uint32_t frame_unsync_t        : 16; /**< [ 31: 16](R/W) The number of consecutive invalid message groups that must be received to
                                                                 transition the RX state machine from the FRAME_SYNC state to the
                                                                 WAIT_FOR_K28.7_IDLES state. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rx_fr_synct_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rx_fr_synct_lnx cavm_cprix_cn4ipx_rx_fr_synct_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RX_FR_SYNCT_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RX_FR_SYNCT_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000808010ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RX_FR_SYNCT_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RX_FR_SYNCT_LNX(a,b,c) cavm_cprix_cn4ipx_rx_fr_synct_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RX_FR_SYNCT_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RX_FR_SYNCT_LNX(a,b,c) "CPRIX_CN4IPX_RX_FR_SYNCT_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RX_FR_SYNCT_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RX_FR_SYNCT_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rx_fw_typeen_ln#
 *
 * CPRI CONN4 IP RX Type Reception Enable for Message Forwarding Register
 */
union cavm_cprix_cn4ipx_rx_fw_typeen_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rx_fw_typeen_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t rx_fw_type_en         : 32; /**< [ 31:  0](R/W) Enable forwarding of received messages. Each bit maps to one of the possible RP3
                                                                 types as specified in Error! Reference source not found..
                                                                   0 = Message forwarding disabled.
                                                                   1 = Message forwarding enabled. */
#else /* Word 0 - Little Endian */
        uint32_t rx_fw_type_en         : 32; /**< [ 31:  0](R/W) Enable forwarding of received messages. Each bit maps to one of the possible RP3
                                                                 types as specified in Error! Reference source not found..
                                                                   0 = Message forwarding disabled.
                                                                   1 = Message forwarding enabled. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rx_fw_typeen_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rx_fw_typeen_lnx cavm_cprix_cn4ipx_rx_fw_typeen_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RX_FW_TYPEEN_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RX_FW_TYPEEN_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000808038ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RX_FW_TYPEEN_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RX_FW_TYPEEN_LNX(a,b,c) cavm_cprix_cn4ipx_rx_fw_typeen_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RX_FW_TYPEEN_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RX_FW_TYPEEN_LNX(a,b,c) "CPRIX_CN4IPX_RX_FW_TYPEEN_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RX_FW_TYPEEN_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RX_FW_TYPEEN_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rx_lcv_errcnt_ln#
 *
 * CPRI CONN4 IP RX LCV Error Count Register
 */
union cavm_cprix_cn4ipx_rx_lcv_errcnt_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rx_lcv_errcnt_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t rx_lcv_err_cnt        : 32; /**< [ 31:  0](RO/H) Number of byte errors coming from the 10b/8b decoder during RX_T_LCV.
                                                                 This is the value from the last counting window. */
#else /* Word 0 - Little Endian */
        uint32_t rx_lcv_err_cnt        : 32; /**< [ 31:  0](RO/H) Number of byte errors coming from the 10b/8b decoder during RX_T_LCV.
                                                                 This is the value from the last counting window. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rx_lcv_errcnt_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rx_lcv_errcnt_lnx cavm_cprix_cn4ipx_rx_lcv_errcnt_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RX_LCV_ERRCNT_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RX_LCV_ERRCNT_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000808028ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RX_LCV_ERRCNT_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RX_LCV_ERRCNT_LNX(a,b,c) cavm_cprix_cn4ipx_rx_lcv_errcnt_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RX_LCV_ERRCNT_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RX_LCV_ERRCNT_LNX(a,b,c) "CPRIX_CN4IPX_RX_LCV_ERRCNT_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RX_LCV_ERRCNT_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RX_LCV_ERRCNT_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rx_lcv_totcnt_ln#
 *
 * CPRI CONN4 IP RX LCV error total count Register
 */
union cavm_cprix_cn4ipx_rx_lcv_totcnt_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rx_lcv_totcnt_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t rx_lcv_err_cnt_tot    : 32; /**< [ 31:  0](R/W) Total number of byte errors coming from the 10b/8b decoder since last counter reset.
                                                                 Count is reset by writing 0x0 to the register. */
#else /* Word 0 - Little Endian */
        uint32_t rx_lcv_err_cnt_tot    : 32; /**< [ 31:  0](R/W) Total number of byte errors coming from the 10b/8b decoder since last counter reset.
                                                                 Count is reset by writing 0x0 to the register. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rx_lcv_totcnt_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rx_lcv_totcnt_lnx cavm_cprix_cn4ipx_rx_lcv_totcnt_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RX_LCV_TOTCNT_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RX_LCV_TOTCNT_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000808044ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RX_LCV_TOTCNT_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RX_LCV_TOTCNT_LNX(a,b,c) cavm_cprix_cn4ipx_rx_lcv_totcnt_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RX_LCV_TOTCNT_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RX_LCV_TOTCNT_LNX(a,b,c) "CPRIX_CN4IPX_RX_LCV_TOTCNT_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RX_LCV_TOTCNT_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RX_LCV_TOTCNT_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rx_max_off_ln#
 *
 * CPRI CONN4 IP RX MAX Offset Register
 */
union cavm_cprix_cn4ipx_rx_max_off_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rx_max_off_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t max_offset            : 7;  /**< [  6:  0](R/W) The maximum number of 307.2 MHz clocks after FCLK_PI that the K28.7 can arrive.
                                                                 To get the register value, the window size in bytes need to be multiplied by 1,
                                                                 2 and 4 for speeds 8x, 4x and 2x, respectively.
                                                                 Maximum allowed value is 0x50, corresponding to 20 byte window for 2x link. */
#else /* Word 0 - Little Endian */
        uint32_t max_offset            : 7;  /**< [  6:  0](R/W) The maximum number of 307.2 MHz clocks after FCLK_PI that the K28.7 can arrive.
                                                                 To get the register value, the window size in bytes need to be multiplied by 1,
                                                                 2 and 4 for speeds 8x, 4x and 2x, respectively.
                                                                 Maximum allowed value is 0x50, corresponding to 20 byte window for 2x link. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rx_max_off_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rx_max_off_lnx cavm_cprix_cn4ipx_rx_max_off_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RX_MAX_OFF_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RX_MAX_OFF_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000808020ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RX_MAX_OFF_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RX_MAX_OFF_LNX(a,b,c) cavm_cprix_cn4ipx_rx_max_off_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RX_MAX_OFF_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RX_MAX_OFF_LNX(a,b,c) "CPRIX_CN4IPX_RX_MAX_OFF_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RX_MAX_OFF_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RX_MAX_OFF_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rx_mcu_typeen_ln#
 *
 * CPRI CONN4 IP RX MCU Reception Enable Register
 */
union cavm_cprix_cn4ipx_rx_mcu_typeen_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rx_mcu_typeen_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t rx_mcu_type_en        : 32; /**< [ 31:  0](R/W) Enable Reception of messages to MCU Buffer. Each bit maps to one of the possible
                                                                 RP3 types as specified in Error! Reference source not found..
                                                                   0 = MCU reception disabled.
                                                                   1 = MCU reception enabled. */
#else /* Word 0 - Little Endian */
        uint32_t rx_mcu_type_en        : 32; /**< [ 31:  0](R/W) Enable Reception of messages to MCU Buffer. Each bit maps to one of the possible
                                                                 RP3 types as specified in Error! Reference source not found..
                                                                   0 = MCU reception disabled.
                                                                   1 = MCU reception enabled. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rx_mcu_typeen_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rx_mcu_typeen_lnx cavm_cprix_cn4ipx_rx_mcu_typeen_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RX_MCU_TYPEEN_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RX_MCU_TYPEEN_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000808034ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RX_MCU_TYPEEN_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RX_MCU_TYPEEN_LNX(a,b,c) cavm_cprix_cn4ipx_rx_mcu_typeen_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RX_MCU_TYPEEN_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RX_MCU_TYPEEN_LNX(a,b,c) "CPRIX_CN4IPX_RX_MCU_TYPEEN_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RX_MCU_TYPEEN_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RX_MCU_TYPEEN_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rx_msg_fwdtype_ln#
 *
 * CPRI CONN4 IP  Rx Message Forward Type Register
 */
union cavm_cprix_cn4ipx_rx_msg_fwdtype_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rx_msg_fwdtype_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t rx_msg_fwd_type_en    : 32; /**< [ 31:  0](R/W) Enable forwarding of received control messages to RP3 interface.
                                                                 Each bit maps to one of the possible RP3 types as specified in Error! Reference source not found..
                                                                   0 = Message forwarding disabled.
                                                                   1 = Message forwarding enabled. */
#else /* Word 0 - Little Endian */
        uint32_t rx_msg_fwd_type_en    : 32; /**< [ 31:  0](R/W) Enable forwarding of received control messages to RP3 interface.
                                                                 Each bit maps to one of the possible RP3 types as specified in Error! Reference source not found..
                                                                   0 = Message forwarding disabled.
                                                                   1 = Message forwarding enabled. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rx_msg_fwdtype_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rx_msg_fwdtype_lnx cavm_cprix_cn4ipx_rx_msg_fwdtype_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RX_MSG_FWDTYPE_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RX_MSG_FWDTYPE_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x8640008083c0ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RX_MSG_FWDTYPE_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RX_MSG_FWDTYPE_LNX(a,b,c) cavm_cprix_cn4ipx_rx_msg_fwdtype_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RX_MSG_FWDTYPE_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RX_MSG_FWDTYPE_LNX(a,b,c) "CPRIX_CN4IPX_RX_MSG_FWDTYPE_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RX_MSG_FWDTYPE_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RX_MSG_FWDTYPE_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rx_n_lcv_ln#
 *
 * CPRI CONN4 IP RX LCV Error Threshold Register
 */
union cavm_cprix_cn4ipx_rx_n_lcv_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rx_n_lcv_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t rx_n_lcv              : 32; /**< [ 31:  0](R/W) Threshold value for asserting  LCV_ERROR interrupt during period of RX_T_LCV. */
#else /* Word 0 - Little Endian */
        uint32_t rx_n_lcv              : 32; /**< [ 31:  0](R/W) Threshold value for asserting  LCV_ERROR interrupt during period of RX_T_LCV. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rx_n_lcv_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rx_n_lcv_lnx cavm_cprix_cn4ipx_rx_n_lcv_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RX_N_LCV_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RX_N_LCV_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000808030ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RX_N_LCV_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RX_N_LCV_LNX(a,b,c) cavm_cprix_cn4ipx_rx_n_lcv_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RX_N_LCV_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RX_N_LCV_LNX(a,b,c) "CPRIX_CN4IPX_RX_N_LCV_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RX_N_LCV_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RX_N_LCV_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rx_node_addr_ln#
 *
 * CPRI CONN4 IP RX_NODE_ADDR Register
 */
union cavm_cprix_cn4ipx_rx_node_addr_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rx_node_addr_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t node_addr             : 8;  /**< [  7:  0](R/W) Connectivity node address to select which messages are consumed inside Connectivity.
                                                                 Connectivity sub-node address is fixed as 00000'b. */
#else /* Word 0 - Little Endian */
        uint32_t node_addr             : 8;  /**< [  7:  0](R/W) Connectivity node address to select which messages are consumed inside Connectivity.
                                                                 Connectivity sub-node address is fixed as 00000'b. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rx_node_addr_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rx_node_addr_lnx cavm_cprix_cn4ipx_rx_node_addr_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RX_NODE_ADDR_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RX_NODE_ADDR_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000808000ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RX_NODE_ADDR_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RX_NODE_ADDR_LNX(a,b,c) cavm_cprix_cn4ipx_rx_node_addr_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RX_NODE_ADDR_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RX_NODE_ADDR_LNX(a,b,c) "CPRIX_CN4IPX_RX_NODE_ADDR_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RX_NODE_ADDR_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RX_NODE_ADDR_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rx_offset_ln#
 *
 * CPRI CONN4 IP RX Link Timing Parameter RX_OFFSET Register
 */
union cavm_cprix_cn4ipx_rx_offset_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rx_offset_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t rx_offset             : 8;  /**< [  7:  0](R/W) Offset from RX_FCLK_PI to reading RX data in 307.2 MHz clock periods. */
#else /* Word 0 - Little Endian */
        uint32_t rx_offset             : 8;  /**< [  7:  0](R/W) Offset from RX_FCLK_PI to reading RX data in 307.2 MHz clock periods. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rx_offset_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rx_offset_lnx cavm_cprix_cn4ipx_rx_offset_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RX_OFFSET_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RX_OFFSET_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x86400080806cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RX_OFFSET_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RX_OFFSET_LNX(a,b,c) cavm_cprix_cn4ipx_rx_offset_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RX_OFFSET_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RX_OFFSET_LNX(a,b,c) "CPRIX_CN4IPX_RX_OFFSET_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RX_OFFSET_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RX_OFFSET_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rx_pi_ln#
 *
 * CPRI CONN4 IP RX Link Timing Parameter PI Register
 */
union cavm_cprix_cn4ipx_rx_pi_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rx_pi_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t sign                  : 9;  /**< [ 31: 23](RO/H) These bits show the value of the sign bit (22) when read. Write to these bits has no effect. */
        uint32_t pi                    : 23; /**< [ 22:  0](R/W) Offset from BCN N2 wrap-around point to RX_FCLK_PI in 307.2 MHz clock periods.
                                                                 The value is represented as a signed, two's complement value. Bit 22 is a sign bit. */
#else /* Word 0 - Little Endian */
        uint32_t pi                    : 23; /**< [ 22:  0](R/W) Offset from BCN N2 wrap-around point to RX_FCLK_PI in 307.2 MHz clock periods.
                                                                 The value is represented as a signed, two's complement value. Bit 22 is a sign bit. */
        uint32_t sign                  : 9;  /**< [ 31: 23](RO/H) These bits show the value of the sign bit (22) when read. Write to these bits has no effect. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rx_pi_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rx_pi_lnx cavm_cprix_cn4ipx_rx_pi_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RX_PI_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RX_PI_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000808068ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RX_PI_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RX_PI_LNX(a,b,c) cavm_cprix_cn4ipx_rx_pi_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RX_PI_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RX_PI_LNX(a,b,c) "CPRIX_CN4IPX_RX_PI_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RX_PI_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RX_PI_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rx_pi_meas_ln#
 *
 * CPRI CONN4 IP RX_PI_MEAS Register
 */
union cavm_cprix_cn4ipx_rx_pi_meas_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rx_pi_meas_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_22_31        : 10;
        uint32_t rx_pi_meas            : 22; /**< [ 21:  0](RO/H) Amount of 307.2 MHz clock cycles between FCLK_PI and the received K28.7
                                                                 character.  The value is updated when the first K28.7 character is received
                                                                 after FCLK_PI, or FCLK_PI occurs without detecting a K28.7 character. */
#else /* Word 0 - Little Endian */
        uint32_t rx_pi_meas            : 22; /**< [ 21:  0](RO/H) Amount of 307.2 MHz clock cycles between FCLK_PI and the received K28.7
                                                                 character.  The value is updated when the first K28.7 character is received
                                                                 after FCLK_PI, or FCLK_PI occurs without detecting a K28.7 character. */
        uint32_t reserved_22_31        : 10;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rx_pi_meas_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rx_pi_meas_lnx cavm_cprix_cn4ipx_rx_pi_meas_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RX_PI_MEAS_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RX_PI_MEAS_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000808004ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RX_PI_MEAS_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RX_PI_MEAS_LNX(a,b,c) cavm_cprix_cn4ipx_rx_pi_meas_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RX_PI_MEAS_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RX_PI_MEAS_LNX(a,b,c) "CPRIX_CN4IPX_RX_PI_MEAS_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RX_PI_MEAS_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RX_PI_MEAS_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rx_rt_err_ln#
 *
 * CPRI CONN4 IP RX Routing Error address Register
 */
union cavm_cprix_cn4ipx_rx_rt_err_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rx_rt_err_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_13_31        : 19;
        uint32_t rt_err_addr           : 13; /**< [ 12:  0](RO/H) Address of the message causing routing error interrupt RX_MSG_RT_ERR. */
#else /* Word 0 - Little Endian */
        uint32_t rt_err_addr           : 13; /**< [ 12:  0](RO/H) Address of the message causing routing error interrupt RX_MSG_RT_ERR. */
        uint32_t reserved_13_31        : 19;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rx_rt_err_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rx_rt_err_lnx cavm_cprix_cn4ipx_rx_rt_err_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RX_RT_ERR_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RX_RT_ERR_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000808024ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RX_RT_ERR_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RX_RT_ERR_LNX(a,b,c) cavm_cprix_cn4ipx_rx_rt_err_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RX_RT_ERR_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RX_RT_ERR_LNX(a,b,c) "CPRIX_CN4IPX_RX_RT_ERR_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RX_RT_ERR_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RX_RT_ERR_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rx_sm_ctrl_ln#
 *
 * CPRI CONN4 IP RX State Machine Control Register
 */
union cavm_cprix_cn4ipx_rx_sm_ctrl_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rx_sm_ctrl_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_9_31         : 23;
        uint32_t force_state_hold      : 1;  /**< [  8:  8](R/W) Force RX state machine to STATE and hold the state:
                                                                   0 = RX state machine runs free.
                                                                   1 = RX state machine is forced to STATE, and the state is kept. */
        uint32_t reserved_5_7          : 3;
        uint32_t force_state_enable    : 1;  /**< [  4:  4](R/W/H) Force RX state machine to STATE and let it run normally afterwards:
                                                                   0 = RX state machine runs free.
                                                                   1 = RX state machine is forced to STATE and released. */
        uint32_t reserved_3            : 1;
        uint32_t state                 : 3;  /**< [  2:  0](R/W) RX state machine state:
                                                                   0x0 = UNSYNC.
                                                                   0x1 = WAIT_FOR_K28.7_IDLES.
                                                                   0x2 = WAIT_FOR_FRAME_SYNC_T.
                                                                   0x3 = FRAME_SYNC.
                                                                   0x4 = WAIT_FOR_SEED (in 8x speed only).
                                                                   0x5 = WAIT_FOR_ACK (in 8x speed only).
                                                                   0x6-0x7 = not used.
                                                                 When read, these bits return the actual state of the RX state machine. */
#else /* Word 0 - Little Endian */
        uint32_t state                 : 3;  /**< [  2:  0](R/W) RX state machine state:
                                                                   0x0 = UNSYNC.
                                                                   0x1 = WAIT_FOR_K28.7_IDLES.
                                                                   0x2 = WAIT_FOR_FRAME_SYNC_T.
                                                                   0x3 = FRAME_SYNC.
                                                                   0x4 = WAIT_FOR_SEED (in 8x speed only).
                                                                   0x5 = WAIT_FOR_ACK (in 8x speed only).
                                                                   0x6-0x7 = not used.
                                                                 When read, these bits return the actual state of the RX state machine. */
        uint32_t reserved_3            : 1;
        uint32_t force_state_enable    : 1;  /**< [  4:  4](R/W/H) Force RX state machine to STATE and let it run normally afterwards:
                                                                   0 = RX state machine runs free.
                                                                   1 = RX state machine is forced to STATE and released. */
        uint32_t reserved_5_7          : 3;
        uint32_t force_state_hold      : 1;  /**< [  8:  8](R/W) Force RX state machine to STATE and hold the state:
                                                                   0 = RX state machine runs free.
                                                                   1 = RX state machine is forced to STATE, and the state is kept. */
        uint32_t reserved_9_31         : 23;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rx_sm_ctrl_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rx_sm_ctrl_lnx cavm_cprix_cn4ipx_rx_sm_ctrl_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RX_SM_CTRL_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RX_SM_CTRL_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000808014ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RX_SM_CTRL_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RX_SM_CTRL_LNX(a,b,c) cavm_cprix_cn4ipx_rx_sm_ctrl_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RX_SM_CTRL_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RX_SM_CTRL_LNX(a,b,c) "CPRIX_CN4IPX_RX_SM_CTRL_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RX_SM_CTRL_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RX_SM_CTRL_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rx_synct_ln#
 *
 * CPRI CONN4 IP RX SYNC_T and UNSYNC_T PARAMETER  Register
 */
union cavm_cprix_cn4ipx_rx_synct_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rx_synct_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t unsync_t              : 16; /**< [ 31: 16](R/W) Number of consecutive invalid blocks that must be received to transition the RX
                                                                 state machine to the UNSYNC state. */
        uint32_t sync_t                : 16; /**< [ 15:  0](R/W) Number of consecutive valid blocks that must be received to transition the RX
                                                                 state machine from the UNSYNC state to the WAIT_FOR_K28.7_IDLES. */
#else /* Word 0 - Little Endian */
        uint32_t sync_t                : 16; /**< [ 15:  0](R/W) Number of consecutive valid blocks that must be received to transition the RX
                                                                 state machine from the UNSYNC state to the WAIT_FOR_K28.7_IDLES. */
        uint32_t unsync_t              : 16; /**< [ 31: 16](R/W) Number of consecutive invalid blocks that must be received to transition the RX
                                                                 state machine to the UNSYNC state. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rx_synct_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rx_synct_lnx cavm_cprix_cn4ipx_rx_synct_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RX_SYNCT_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RX_SYNCT_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x86400080800cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RX_SYNCT_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RX_SYNCT_LNX(a,b,c) cavm_cprix_cn4ipx_rx_synct_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RX_SYNCT_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RX_SYNCT_LNX(a,b,c) "CPRIX_CN4IPX_RX_SYNCT_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RX_SYNCT_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RX_SYNCT_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rx_t_lcv_ln#
 *
 * CPRI CONN4 IP RX Window for Measuring LCV Error Register
 */
union cavm_cprix_cn4ipx_rx_t_lcv_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rx_t_lcv_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t rx_t_lcv              : 32; /**< [ 31:  0](R/W) Window for counting 10b/8b errors for LCV_ERROR detection in bytes. */
#else /* Word 0 - Little Endian */
        uint32_t rx_t_lcv              : 32; /**< [ 31:  0](R/W) Window for counting 10b/8b errors for LCV_ERROR detection in bytes. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rx_t_lcv_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rx_t_lcv_lnx cavm_cprix_cn4ipx_rx_t_lcv_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RX_T_LCV_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RX_T_LCV_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x86400080802cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RX_T_LCV_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RX_T_LCV_LNX(a,b,c) cavm_cprix_cn4ipx_rx_t_lcv_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RX_T_LCV_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RX_T_LCV_LNX(a,b,c) "CPRIX_CN4IPX_RX_T_LCV_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RX_T_LCV_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RX_T_LCV_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rx_test_mode_ln#
 *
 * CPRI CONN4 IP RX Test Pattern Control Register
 */
union cavm_cprix_cn4ipx_rx_test_mode_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rx_test_mode_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t rx_pat_type           : 4;  /**< [ 23: 20](R/W) Selects the test pattern type:

                                                                   0x0 = Normal mode, no test pattern.
                                                                   0x1 = Functional BER.
                                                                   0x2 = CJPAT.
                                                                   0x3 = not used.
                                                                   0x4 = JSPAT.
                                                                   0x5 = JTSPAT.
                                                                   0x8 = PRBS7.
                                                                   0x9 = PRBS7 inverted.
                                                                   0xA = PRBS23.
                                                                   0xB = PRBS23 inverted.
                                                                   0xC = PRBS9.
                                                                   0xD = PRBS9 inverted.

                                                                 Only BER mode can be used during normal operation. */
        uint32_t reserved_19           : 1;
        uint32_t rx_jtspat_act         : 1;  /**< [ 18: 18](RO/H) Status of JSTPAT mode. Indicates that the JTSPAT test is actively comparing values:
                                                                   0 = JTSPAT not received.
                                                                   1 = JTSPAT received. */
        uint32_t rx_jspat_act          : 1;  /**< [ 17: 17](RO/H) Status of JSPAT mode. Indicates that the JSPAT test is actively comparing values:
                                                                   0 = JSPAT not received.
                                                                   1 = JSPAT received. */
        uint32_t rx_cjpat_act          : 1;  /**< [ 16: 16](RO/H) Status of CJPAT mode. Indicates that the CJPAT test is actively comparing values:
                                                                   0 = CJPAT not received.
                                                                   1 = CJPAT received. */
        uint32_t rx_pat_error_count    : 16; /**< [ 15:  0](R/W) Error count value from selected pattern test mode.
                                                                 Counter saturates to the maximum value. Writing 0 to the counter clears the count. */
#else /* Word 0 - Little Endian */
        uint32_t rx_pat_error_count    : 16; /**< [ 15:  0](R/W) Error count value from selected pattern test mode.
                                                                 Counter saturates to the maximum value. Writing 0 to the counter clears the count. */
        uint32_t rx_cjpat_act          : 1;  /**< [ 16: 16](RO/H) Status of CJPAT mode. Indicates that the CJPAT test is actively comparing values:
                                                                   0 = CJPAT not received.
                                                                   1 = CJPAT received. */
        uint32_t rx_jspat_act          : 1;  /**< [ 17: 17](RO/H) Status of JSPAT mode. Indicates that the JSPAT test is actively comparing values:
                                                                   0 = JSPAT not received.
                                                                   1 = JSPAT received. */
        uint32_t rx_jtspat_act         : 1;  /**< [ 18: 18](RO/H) Status of JSTPAT mode. Indicates that the JTSPAT test is actively comparing values:
                                                                   0 = JTSPAT not received.
                                                                   1 = JTSPAT received. */
        uint32_t reserved_19           : 1;
        uint32_t rx_pat_type           : 4;  /**< [ 23: 20](R/W) Selects the test pattern type:

                                                                   0x0 = Normal mode, no test pattern.
                                                                   0x1 = Functional BER.
                                                                   0x2 = CJPAT.
                                                                   0x3 = not used.
                                                                   0x4 = JSPAT.
                                                                   0x5 = JTSPAT.
                                                                   0x8 = PRBS7.
                                                                   0x9 = PRBS7 inverted.
                                                                   0xA = PRBS23.
                                                                   0xB = PRBS23 inverted.
                                                                   0xC = PRBS9.
                                                                   0xD = PRBS9 inverted.

                                                                 Only BER mode can be used during normal operation. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rx_test_mode_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rx_test_mode_lnx cavm_cprix_cn4ipx_rx_test_mode_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RX_TEST_MODE_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RX_TEST_MODE_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x86400080803cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RX_TEST_MODE_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RX_TEST_MODE_LNX(a,b,c) cavm_cprix_cn4ipx_rx_test_mode_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RX_TEST_MODE_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RX_TEST_MODE_LNX(a,b,c) "CPRIX_CN4IPX_RX_TEST_MODE_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RX_TEST_MODE_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RX_TEST_MODE_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rx_trm_typeen_ln#
 *
 * CPRI CONN4 IP RX Type Based Termination Enable Register
 */
union cavm_cprix_cn4ipx_rx_trm_typeen_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rx_trm_typeen_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t rx_trm_type_en        : 32; /**< [ 31:  0](R/W) Enable termination of received messages based on type only, independent on
                                                                 reception/Connectivity address.
                                                                 Each bit maps to one of the possible RP3 types as specified in Error! Reference source not found..
                                                                   0 = Message terminated based on address/type.
                                                                   1 = Message terminated based on type only. */
#else /* Word 0 - Little Endian */
        uint32_t rx_trm_type_en        : 32; /**< [ 31:  0](R/W) Enable termination of received messages based on type only, independent on
                                                                 reception/Connectivity address.
                                                                 Each bit maps to one of the possible RP3 types as specified in Error! Reference source not found..
                                                                   0 = Message terminated based on address/type.
                                                                   1 = Message terminated based on type only. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rx_trm_typeen_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rx_trm_typeen_lnx cavm_cprix_cn4ipx_rx_trm_typeen_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RX_TRM_TYPEEN_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RX_TRM_TYPEEN_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000808040ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RX_TRM_TYPEEN_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RX_TRM_TYPEEN_LNX(a,b,c) cavm_cprix_cn4ipx_rx_trm_typeen_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RX_TRM_TYPEEN_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RX_TRM_TYPEEN_LNX(a,b,c) "CPRIX_CN4IPX_RX_TRM_TYPEEN_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RX_TRM_TYPEEN_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RX_TRM_TYPEEN_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rxtx_ber_achdh#_ln#
 *
 * CPRI CONN4 IP RXTX Functional BER AxC 16 to AxC 31 Header Register
 */
union cavm_cprix_cn4ipx_rxtx_ber_achdhx_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rxtx_ber_achdhx_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t addr                  : 13; /**< [ 23: 11](R/W) Address field of the Functional BER messages.
                                                                 Bits 23:16 correspond to the node address, and bits 15:11 to the sub-node address.
                                                                 In TX, this value is used for transmitted messages.
                                                                 In receiver, this value is used for checking the received messages. */
        uint32_t type_s                : 5;  /**< [ 10:  6](R/W) Type field of the Functional BER messages.
                                                                 In TX, this value is used for transmitted messages.
                                                                 In receiver, this value is used for checking the received messages. */
        uint32_t reserved_0_5          : 6;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0_5          : 6;
        uint32_t type_s                : 5;  /**< [ 10:  6](R/W) Type field of the Functional BER messages.
                                                                 In TX, this value is used for transmitted messages.
                                                                 In receiver, this value is used for checking the received messages. */
        uint32_t addr                  : 13; /**< [ 23: 11](R/W) Address field of the Functional BER messages.
                                                                 Bits 23:16 correspond to the node address, and bits 15:11 to the sub-node address.
                                                                 In TX, this value is used for transmitted messages.
                                                                 In receiver, this value is used for checking the received messages. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rxtx_ber_achdhx_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rxtx_ber_achdhx_lnx cavm_cprix_cn4ipx_rxtx_ber_achdhx_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RXTX_BER_ACHDHX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RXTX_BER_ACHDHX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=15) && (d<=1)))
        return 0x864000808100ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 4ll * ((c) & 0xf) + 0x1000ll * ((d) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RXTX_BER_ACHDHX_LNX", 4, a, b, c, d, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RXTX_BER_ACHDHX_LNX(a,b,c,d) cavm_cprix_cn4ipx_rxtx_ber_achdhx_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RXTX_BER_ACHDHX_LNX(a,b,c,d) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RXTX_BER_ACHDHX_LNX(a,b,c,d) "CPRIX_CN4IPX_RXTX_BER_ACHDHX_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RXTX_BER_ACHDHX_LNX(a,b,c,d) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RXTX_BER_ACHDHX_LNX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) cpri#_cn4ip#_rxtx_ber_achdl#_ln#
 *
 * CPRI CONN4 IP RXTX Functional BER AxC 0 to AxC 15 Header Register
 */
union cavm_cprix_cn4ipx_rxtx_ber_achdlx_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rxtx_ber_achdlx_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t addr                  : 13; /**< [ 23: 11](R/W) Address field of the Functional BER messages.
                                                                 Bits 23:16 correspond to the node address, and bits 15:11 to the sub-node address.
                                                                 In TX, this value is used for transmitted messages.
                                                                 In receiver, this value is used for checking the received messages. */
        uint32_t type_s                : 5;  /**< [ 10:  6](R/W) Type field of the Functional BER messages.
                                                                 In TX, this value is used for transmitted messages.
                                                                 In receiver, this value is used for checking the received messages. */
        uint32_t reserved_0_5          : 6;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0_5          : 6;
        uint32_t type_s                : 5;  /**< [ 10:  6](R/W) Type field of the Functional BER messages.
                                                                 In TX, this value is used for transmitted messages.
                                                                 In receiver, this value is used for checking the received messages. */
        uint32_t addr                  : 13; /**< [ 23: 11](R/W) Address field of the Functional BER messages.
                                                                 Bits 23:16 correspond to the node address, and bits 15:11 to the sub-node address.
                                                                 In TX, this value is used for transmitted messages.
                                                                 In receiver, this value is used for checking the received messages. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rxtx_ber_achdlx_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rxtx_ber_achdlx_lnx cavm_cprix_cn4ipx_rxtx_ber_achdlx_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RXTX_BER_ACHDLX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RXTX_BER_ACHDLX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=15) && (d<=1)))
        return 0x8640008080c0ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 4ll * ((c) & 0xf) + 0x1000ll * ((d) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RXTX_BER_ACHDLX_LNX", 4, a, b, c, d, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RXTX_BER_ACHDLX_LNX(a,b,c,d) cavm_cprix_cn4ipx_rxtx_ber_achdlx_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RXTX_BER_ACHDLX_LNX(a,b,c,d) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RXTX_BER_ACHDLX_LNX(a,b,c,d) "CPRIX_CN4IPX_RXTX_BER_ACHDLX_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RXTX_BER_ACHDLX_LNX(a,b,c,d) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RXTX_BER_ACHDLX_LNX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) cpri#_cn4ip#_rxtx_ber_cthd#_ln#
 *
 * CPRI CONN4 IP RXTX Functional BER Control Slot 0 to 7 Header Register
 */
union cavm_cprix_cn4ipx_rxtx_ber_cthdx_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rxtx_ber_cthdx_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t addr                  : 13; /**< [ 23: 11](R/W) Address field of the Functional BER messages.
                                                                 Bits 23:16 correspond to the node address, and bits 15:11 to the sub-node address.
                                                                 In TX, this value is used for transmitted messages.
                                                                 In receiver, this value is used for checking the received messages. */
        uint32_t type_s                : 5;  /**< [ 10:  6](R/W) Type field of the Functional BER messages.
                                                                 In TX, this value is used for transmitted messages.
                                                                 In receiver, this value is used for checking the received messages. */
        uint32_t tstamp                : 6;  /**< [  5:  0](R/W) Timestamp field of the Functional BER messages.
                                                                 In TX, this value is used for transmitted messages.
                                                                 In receiver, this value is used for checking the received messages. */
#else /* Word 0 - Little Endian */
        uint32_t tstamp                : 6;  /**< [  5:  0](R/W) Timestamp field of the Functional BER messages.
                                                                 In TX, this value is used for transmitted messages.
                                                                 In receiver, this value is used for checking the received messages. */
        uint32_t type_s                : 5;  /**< [ 10:  6](R/W) Type field of the Functional BER messages.
                                                                 In TX, this value is used for transmitted messages.
                                                                 In receiver, this value is used for checking the received messages. */
        uint32_t addr                  : 13; /**< [ 23: 11](R/W) Address field of the Functional BER messages.
                                                                 Bits 23:16 correspond to the node address, and bits 15:11 to the sub-node address.
                                                                 In TX, this value is used for transmitted messages.
                                                                 In receiver, this value is used for checking the received messages. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rxtx_ber_cthdx_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rxtx_ber_cthdx_lnx cavm_cprix_cn4ipx_rxtx_ber_cthdx_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RXTX_BER_CTHDX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RXTX_BER_CTHDX_LNX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=7) && (d<=1)))
        return 0x864000808140ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 4ll * ((c) & 0x7) + 0x1000ll * ((d) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RXTX_BER_CTHDX_LNX", 4, a, b, c, d, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RXTX_BER_CTHDX_LNX(a,b,c,d) cavm_cprix_cn4ipx_rxtx_ber_cthdx_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RXTX_BER_CTHDX_LNX(a,b,c,d) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RXTX_BER_CTHDX_LNX(a,b,c,d) "CPRIX_CN4IPX_RXTX_BER_CTHDX_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RXTX_BER_CTHDX_LNX(a,b,c,d) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RXTX_BER_CTHDX_LNX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) cpri#_cn4ip#_rxtx_int_clr_ln#
 *
 * CPRI CONN4 IP RXTX Interrupt Event Clear Register
 */
union cavm_cprix_cn4ipx_rxtx_int_clr_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rxtx_int_clr_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_21_31        : 11;
        uint32_t rx_axc_error          : 1;  /**< [ 20: 20](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT:
                                                                     0 = no effect.
                                                                     1 = Interrupt clear. */
        uint32_t tx_tim_call           : 1;  /**< [ 19: 19](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
        uint32_t tx_ol_coll            : 1;  /**< [ 18: 18](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
        uint32_t tx_tr_coll            : 1;  /**< [ 17: 17](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
        uint32_t sum_uf_err            : 1;  /**< [ 16: 16](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
        uint32_t sum_of_err            : 1;  /**< [ 15: 15](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
        uint32_t sum_col               : 1;  /**< [ 14: 14](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
        uint32_t sum_ts_err            : 1;  /**< [ 13: 13](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
        uint32_t sum_type_err          : 1;  /**< [ 12: 12](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
        uint32_t sum_addr_err          : 1;  /**< [ 11: 11](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_lcv_error          : 1;  /**< [ 10: 10](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_align_err          : 1;  /**< [  9:  9](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_msg_uf             : 1;  /**< [  8:  8](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_msg_of             : 1;  /**< [  7:  7](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_msg_hd_error       : 1;  /**< [  6:  6](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_msg_rt_err         : 1;  /**< [  5:  5](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_quality            : 1;  /**< [  4:  4](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_los                : 1;  /**< [  3:  3](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_fs_change          : 1;  /**< [  2:  2](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_st_change          : 1;  /**< [  1:  1](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_clk_error          : 1;  /**< [  0:  0](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
#else /* Word 0 - Little Endian */
        uint32_t rx_clk_error          : 1;  /**< [  0:  0](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_st_change          : 1;  /**< [  1:  1](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_fs_change          : 1;  /**< [  2:  2](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_los                : 1;  /**< [  3:  3](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_quality            : 1;  /**< [  4:  4](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_msg_rt_err         : 1;  /**< [  5:  5](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_msg_hd_error       : 1;  /**< [  6:  6](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_msg_of             : 1;  /**< [  7:  7](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_msg_uf             : 1;  /**< [  8:  8](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_align_err          : 1;  /**< [  9:  9](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_lcv_error          : 1;  /**< [ 10: 10](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
        uint32_t sum_addr_err          : 1;  /**< [ 11: 11](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
        uint32_t sum_type_err          : 1;  /**< [ 12: 12](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
        uint32_t sum_ts_err            : 1;  /**< [ 13: 13](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
        uint32_t sum_col               : 1;  /**< [ 14: 14](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
        uint32_t sum_of_err            : 1;  /**< [ 15: 15](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
        uint32_t sum_uf_err            : 1;  /**< [ 16: 16](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
        uint32_t tx_tr_coll            : 1;  /**< [ 17: 17](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
        uint32_t tx_ol_coll            : 1;  /**< [ 18: 18](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
        uint32_t tx_tim_call           : 1;  /**< [ 19: 19](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_axc_error          : 1;  /**< [ 20: 20](R/W1C/H) Clear for corresponding interrupt status bits in RXTX_INT:
                                                                     0 = no effect.
                                                                     1 = Interrupt clear. */
        uint32_t reserved_21_31        : 11;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rxtx_int_clr_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rxtx_int_clr_lnx cavm_cprix_cn4ipx_rxtx_int_clr_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RXTX_INT_CLR_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RXTX_INT_CLR_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x8640008080acll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RXTX_INT_CLR_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RXTX_INT_CLR_LNX(a,b,c) cavm_cprix_cn4ipx_rxtx_int_clr_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RXTX_INT_CLR_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RXTX_INT_CLR_LNX(a,b,c) "CPRIX_CN4IPX_RXTX_INT_CLR_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RXTX_INT_CLR_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RXTX_INT_CLR_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rxtx_int_mask_ln#
 *
 * CPRI CONN4 IP RXTX Interrupt Mask Register
 */
union cavm_cprix_cn4ipx_rxtx_int_mask_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rxtx_int_mask_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_21_31        : 11;
        uint32_t rx_axc_error          : 1;  /**< [ 20: 20](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t tx_tim_call           : 1;  /**< [ 19: 19](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t tx_ol_coll            : 1;  /**< [ 18: 18](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t tx_tr_coll            : 1;  /**< [ 17: 17](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t sum_uf_err            : 1;  /**< [ 16: 16](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t sum_of_err            : 1;  /**< [ 15: 15](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t sum_col               : 1;  /**< [ 14: 14](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t sum_ts_err            : 1;  /**< [ 13: 13](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t sum_type_err          : 1;  /**< [ 12: 12](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t sum_addr_err          : 1;  /**< [ 11: 11](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_lcv_error          : 1;  /**< [ 10: 10](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_align_err          : 1;  /**< [  9:  9](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_msg_uf             : 1;  /**< [  8:  8](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_msg_of             : 1;  /**< [  7:  7](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_msg_hd_error       : 1;  /**< [  6:  6](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_msg_rt_err         : 1;  /**< [  5:  5](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_quality            : 1;  /**< [  4:  4](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_los                : 1;  /**< [  3:  3](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_fs_change          : 1;  /**< [  2:  2](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_st_change          : 1;  /**< [  1:  1](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_clk_error          : 1;  /**< [  0:  0](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
#else /* Word 0 - Little Endian */
        uint32_t rx_clk_error          : 1;  /**< [  0:  0](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_st_change          : 1;  /**< [  1:  1](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_fs_change          : 1;  /**< [  2:  2](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_los                : 1;  /**< [  3:  3](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_quality            : 1;  /**< [  4:  4](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_msg_rt_err         : 1;  /**< [  5:  5](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_msg_hd_error       : 1;  /**< [  6:  6](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_msg_of             : 1;  /**< [  7:  7](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_msg_uf             : 1;  /**< [  8:  8](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_align_err          : 1;  /**< [  9:  9](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_lcv_error          : 1;  /**< [ 10: 10](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t sum_addr_err          : 1;  /**< [ 11: 11](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t sum_type_err          : 1;  /**< [ 12: 12](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t sum_ts_err            : 1;  /**< [ 13: 13](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t sum_col               : 1;  /**< [ 14: 14](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t sum_of_err            : 1;  /**< [ 15: 15](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t sum_uf_err            : 1;  /**< [ 16: 16](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t tx_tr_coll            : 1;  /**< [ 17: 17](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t tx_ol_coll            : 1;  /**< [ 18: 18](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t tx_tim_call           : 1;  /**< [ 19: 19](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_axc_error          : 1;  /**< [ 20: 20](R/W) Mask for corresponding interrupt status bits in RXTX_INT. */
        uint32_t reserved_21_31        : 11;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rxtx_int_mask_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rxtx_int_mask_lnx cavm_cprix_cn4ipx_rxtx_int_mask_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RXTX_INT_MASK_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RXTX_INT_MASK_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x8640008080b4ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RXTX_INT_MASK_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RXTX_INT_MASK_LNX(a,b,c) cavm_cprix_cn4ipx_rxtx_int_mask_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RXTX_INT_MASK_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RXTX_INT_MASK_LNX(a,b,c) "CPRIX_CN4IPX_RXTX_INT_MASK_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RXTX_INT_MASK_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RXTX_INT_MASK_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rxtx_int_set_ln#
 *
 * CPRI CONN4 IP RXTX Interrupt Event Set Register
 */
union cavm_cprix_cn4ipx_rxtx_int_set_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rxtx_int_set_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_21_31        : 11;
        uint32_t rx_axc_error          : 1;  /**< [ 20: 20](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT:
                                                                     0 = no effect.
                                                                     1 = Interrupt set. */
        uint32_t tx_tim_call           : 1;  /**< [ 19: 19](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
        uint32_t tx_ol_coll            : 1;  /**< [ 18: 18](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
        uint32_t tx_tr_coll            : 1;  /**< [ 17: 17](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
        uint32_t sum_uf_err            : 1;  /**< [ 16: 16](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
        uint32_t sum_of_err            : 1;  /**< [ 15: 15](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
        uint32_t sum_col               : 1;  /**< [ 14: 14](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
        uint32_t sum_ts_err            : 1;  /**< [ 13: 13](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
        uint32_t sum_type_err          : 1;  /**< [ 12: 12](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
        uint32_t sum_addr_err          : 1;  /**< [ 11: 11](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_lcv_error          : 1;  /**< [ 10: 10](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_align_err          : 1;  /**< [  9:  9](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_msg_uf             : 1;  /**< [  8:  8](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_msg_of             : 1;  /**< [  7:  7](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_msg_hd_error       : 1;  /**< [  6:  6](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_msg_rt_err         : 1;  /**< [  5:  5](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_quality            : 1;  /**< [  4:  4](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_los                : 1;  /**< [  3:  3](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_fs_change          : 1;  /**< [  2:  2](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_st_change          : 1;  /**< [  1:  1](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_clk_error          : 1;  /**< [  0:  0](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
#else /* Word 0 - Little Endian */
        uint32_t rx_clk_error          : 1;  /**< [  0:  0](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_st_change          : 1;  /**< [  1:  1](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_fs_change          : 1;  /**< [  2:  2](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_los                : 1;  /**< [  3:  3](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_quality            : 1;  /**< [  4:  4](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_msg_rt_err         : 1;  /**< [  5:  5](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_msg_hd_error       : 1;  /**< [  6:  6](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_msg_of             : 1;  /**< [  7:  7](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_msg_uf             : 1;  /**< [  8:  8](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_align_err          : 1;  /**< [  9:  9](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_lcv_error          : 1;  /**< [ 10: 10](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
        uint32_t sum_addr_err          : 1;  /**< [ 11: 11](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
        uint32_t sum_type_err          : 1;  /**< [ 12: 12](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
        uint32_t sum_ts_err            : 1;  /**< [ 13: 13](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
        uint32_t sum_col               : 1;  /**< [ 14: 14](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
        uint32_t sum_of_err            : 1;  /**< [ 15: 15](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
        uint32_t sum_uf_err            : 1;  /**< [ 16: 16](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
        uint32_t tx_tr_coll            : 1;  /**< [ 17: 17](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
        uint32_t tx_ol_coll            : 1;  /**< [ 18: 18](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
        uint32_t tx_tim_call           : 1;  /**< [ 19: 19](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT. */
        uint32_t rx_axc_error          : 1;  /**< [ 20: 20](R/W1S/H) Set for corresponding interrupt status bits in RXTX_INT:
                                                                     0 = no effect.
                                                                     1 = Interrupt set. */
        uint32_t reserved_21_31        : 11;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rxtx_int_set_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rxtx_int_set_lnx cavm_cprix_cn4ipx_rxtx_int_set_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RXTX_INT_SET_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RXTX_INT_SET_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x8640008080b0ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RXTX_INT_SET_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RXTX_INT_SET_LNX(a,b,c) cavm_cprix_cn4ipx_rxtx_int_set_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RXTX_INT_SET_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RXTX_INT_SET_LNX(a,b,c) "CPRIX_CN4IPX_RXTX_INT_SET_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RXTX_INT_SET_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RXTX_INT_SET_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rxtx_int_sts_ln#
 *
 * CPRI CONN4 IP RXTX Interrupt Status Register
 */
union cavm_cprix_cn4ipx_rxtx_int_sts_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rxtx_int_sts_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_21_31        : 11;
        uint32_t rx_axc_error          : 1;  /**< [ 20: 20](RO/H) Timeout or timestamp mismatch detected in Rx AxC reception, check RX_AXC_STAT*
                                                                 registers for more information of the interrupt source.
                                                                   0 = No interrupt.
                                                                   1 = Interrupt. */
        uint32_t tx_tim_call           : 1;  /**< [ 19: 19](RO/H) Timing collision.
                                                                 Data is received with different timing than expected (RX and TX timing parameters do not match). */
        uint32_t tx_ol_coll            : 1;  /**< [ 18: 18](RO/H) Overload collision.
                                                                 Transmitter detected more data coming from summing than the current link rate can support. */
        uint32_t tx_tr_coll            : 1;  /**< [ 17: 17](RO/H) Transmission Rule collision.
                                                                 Transmitter detected an RP3 message from summing coincident with a transmission rule. */
        uint32_t sum_uf_err            : 1;  /**< [ 16: 16](RO/H) Summing underflow.
                                                                 Summing result saturated to minimum value. */
        uint32_t sum_of_err            : 1;  /**< [ 15: 15](RO/H) Summing overflow.
                                                                 Summing result saturated to maximum value. */
        uint32_t sum_col               : 1;  /**< [ 14: 14](RO/H) Summing module detected more than one enabled input port when summing is not
                                                                 enabled for the current message type. */
        uint32_t sum_ts_err            : 1;  /**< [ 13: 13](RO/H) Summing module detected messages to be summed with mismatched TimeStamp field in header. */
        uint32_t sum_type_err          : 1;  /**< [ 12: 12](RO/H) Summing module detected messages to be summed with mismatched Type field in header. */
        uint32_t sum_addr_err          : 1;  /**< [ 11: 11](RO/H) Summing module detected messages to be summed with mismatched Address field in header. */
        uint32_t rx_lcv_error          : 1;  /**< [ 10: 10](RO/H) 8b10b byte error counter has hit the threshold count
                                                                   0 = Interrupt not active
                                                                   1 = Interrupt active */
        uint32_t rx_align_err          : 1;  /**< [  9:  9](RO/H) There has been a K28.7 received outside of the allowed window. */
        uint32_t rx_msg_uf             : 1;  /**< [  8:  8](RO/H) There has been an underflow condition in the message buffer. */
        uint32_t rx_msg_of             : 1;  /**< [  7:  7](RO/H) There has been an overflow condition in the message buffer. */
        uint32_t rx_msg_hd_error       : 1;  /**< [  6:  6](RO/H) There has been a LCV error in the header of a message. */
        uint32_t rx_msg_rt_err         : 1;  /**< [  5:  5](RO/H) There has been a message routed nowhere in the RX.
                                                                 The address of the message causing interrupt is stored in register RX_RT_ERR_ADDR. */
        uint32_t rx_quality            : 1;  /**< [  4:  4](RO/H) There has been a change in the SRX_QUALITY_STATUS from OK to not OK. */
        uint32_t rx_los                : 1;  /**< [  3:  3](RO/H) There has been a loss of signal in the RX state machine (RX state machine has
                                                                 changed into UNSYNC state). */
        uint32_t rx_fs_change          : 1;  /**< [  2:  2](RO/H) RX state machine has changed from FRAME_SYNC state. */
        uint32_t rx_st_change          : 1;  /**< [  1:  1](RO/H) There has been a change of state in the RX state machine. */
        uint32_t rx_clk_error          : 1;  /**< [  0:  0](RO/H) There has been a buffer under run or overrun in the clock crossing logic. */
#else /* Word 0 - Little Endian */
        uint32_t rx_clk_error          : 1;  /**< [  0:  0](RO/H) There has been a buffer under run or overrun in the clock crossing logic. */
        uint32_t rx_st_change          : 1;  /**< [  1:  1](RO/H) There has been a change of state in the RX state machine. */
        uint32_t rx_fs_change          : 1;  /**< [  2:  2](RO/H) RX state machine has changed from FRAME_SYNC state. */
        uint32_t rx_los                : 1;  /**< [  3:  3](RO/H) There has been a loss of signal in the RX state machine (RX state machine has
                                                                 changed into UNSYNC state). */
        uint32_t rx_quality            : 1;  /**< [  4:  4](RO/H) There has been a change in the SRX_QUALITY_STATUS from OK to not OK. */
        uint32_t rx_msg_rt_err         : 1;  /**< [  5:  5](RO/H) There has been a message routed nowhere in the RX.
                                                                 The address of the message causing interrupt is stored in register RX_RT_ERR_ADDR. */
        uint32_t rx_msg_hd_error       : 1;  /**< [  6:  6](RO/H) There has been a LCV error in the header of a message. */
        uint32_t rx_msg_of             : 1;  /**< [  7:  7](RO/H) There has been an overflow condition in the message buffer. */
        uint32_t rx_msg_uf             : 1;  /**< [  8:  8](RO/H) There has been an underflow condition in the message buffer. */
        uint32_t rx_align_err          : 1;  /**< [  9:  9](RO/H) There has been a K28.7 received outside of the allowed window. */
        uint32_t rx_lcv_error          : 1;  /**< [ 10: 10](RO/H) 8b10b byte error counter has hit the threshold count
                                                                   0 = Interrupt not active
                                                                   1 = Interrupt active */
        uint32_t sum_addr_err          : 1;  /**< [ 11: 11](RO/H) Summing module detected messages to be summed with mismatched Address field in header. */
        uint32_t sum_type_err          : 1;  /**< [ 12: 12](RO/H) Summing module detected messages to be summed with mismatched Type field in header. */
        uint32_t sum_ts_err            : 1;  /**< [ 13: 13](RO/H) Summing module detected messages to be summed with mismatched TimeStamp field in header. */
        uint32_t sum_col               : 1;  /**< [ 14: 14](RO/H) Summing module detected more than one enabled input port when summing is not
                                                                 enabled for the current message type. */
        uint32_t sum_of_err            : 1;  /**< [ 15: 15](RO/H) Summing overflow.
                                                                 Summing result saturated to maximum value. */
        uint32_t sum_uf_err            : 1;  /**< [ 16: 16](RO/H) Summing underflow.
                                                                 Summing result saturated to minimum value. */
        uint32_t tx_tr_coll            : 1;  /**< [ 17: 17](RO/H) Transmission Rule collision.
                                                                 Transmitter detected an RP3 message from summing coincident with a transmission rule. */
        uint32_t tx_ol_coll            : 1;  /**< [ 18: 18](RO/H) Overload collision.
                                                                 Transmitter detected more data coming from summing than the current link rate can support. */
        uint32_t tx_tim_call           : 1;  /**< [ 19: 19](RO/H) Timing collision.
                                                                 Data is received with different timing than expected (RX and TX timing parameters do not match). */
        uint32_t rx_axc_error          : 1;  /**< [ 20: 20](RO/H) Timeout or timestamp mismatch detected in Rx AxC reception, check RX_AXC_STAT*
                                                                 registers for more information of the interrupt source.
                                                                   0 = No interrupt.
                                                                   1 = Interrupt. */
        uint32_t reserved_21_31        : 11;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rxtx_int_sts_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rxtx_int_sts_lnx cavm_cprix_cn4ipx_rxtx_int_sts_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RXTX_INT_STS_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RXTX_INT_STS_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x8640008080a8ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RXTX_INT_STS_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RXTX_INT_STS_LNX(a,b,c) cavm_cprix_cn4ipx_rxtx_int_sts_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RXTX_INT_STS_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RXTX_INT_STS_LNX(a,b,c) "CPRIX_CN4IPX_RXTX_INT_STS_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RXTX_INT_STS_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RXTX_INT_STS_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rxtx_intmskclr_ln#
 *
 * CPRI CONN4 IP RXTX Interrupt Mask Clear Register
 */
union cavm_cprix_cn4ipx_rxtx_intmskclr_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rxtx_intmskclr_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_21_31        : 11;
        uint32_t rx_axc_error          : 1;  /**< [ 20: 20](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK.
                                                                     0 = no effect.
                                                                     1 = Interrupt mask clear. */
        uint32_t tx_tim_call           : 1;  /**< [ 19: 19](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t tx_ol_coll            : 1;  /**< [ 18: 18](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t tx_tr_coll            : 1;  /**< [ 17: 17](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t sum_uf_err            : 1;  /**< [ 16: 16](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t sum_of_err            : 1;  /**< [ 15: 15](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t sum_col               : 1;  /**< [ 14: 14](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t sum_ts_err            : 1;  /**< [ 13: 13](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t sum_type_err          : 1;  /**< [ 12: 12](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t sum_addr_err          : 1;  /**< [ 11: 11](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_lcv_error          : 1;  /**< [ 10: 10](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_align_err          : 1;  /**< [  9:  9](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_msg_uf             : 1;  /**< [  8:  8](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_msg_of             : 1;  /**< [  7:  7](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_msg_hd_error       : 1;  /**< [  6:  6](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_msg_rt_err         : 1;  /**< [  5:  5](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_quality            : 1;  /**< [  4:  4](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_los                : 1;  /**< [  3:  3](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_fs_change          : 1;  /**< [  2:  2](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_st_change          : 1;  /**< [  1:  1](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_clk_error          : 1;  /**< [  0:  0](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
#else /* Word 0 - Little Endian */
        uint32_t rx_clk_error          : 1;  /**< [  0:  0](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_st_change          : 1;  /**< [  1:  1](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_fs_change          : 1;  /**< [  2:  2](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_los                : 1;  /**< [  3:  3](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_quality            : 1;  /**< [  4:  4](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_msg_rt_err         : 1;  /**< [  5:  5](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_msg_hd_error       : 1;  /**< [  6:  6](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_msg_of             : 1;  /**< [  7:  7](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_msg_uf             : 1;  /**< [  8:  8](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_align_err          : 1;  /**< [  9:  9](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_lcv_error          : 1;  /**< [ 10: 10](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t sum_addr_err          : 1;  /**< [ 11: 11](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t sum_type_err          : 1;  /**< [ 12: 12](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t sum_ts_err            : 1;  /**< [ 13: 13](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t sum_col               : 1;  /**< [ 14: 14](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t sum_of_err            : 1;  /**< [ 15: 15](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t sum_uf_err            : 1;  /**< [ 16: 16](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t tx_tr_coll            : 1;  /**< [ 17: 17](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t tx_ol_coll            : 1;  /**< [ 18: 18](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t tx_tim_call           : 1;  /**< [ 19: 19](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_axc_error          : 1;  /**< [ 20: 20](R/W1C/H) Clear for corresponding interrupt mask bits in RXTX_INT_MASK.
                                                                     0 = no effect.
                                                                     1 = Interrupt mask clear. */
        uint32_t reserved_21_31        : 11;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rxtx_intmskclr_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rxtx_intmskclr_lnx cavm_cprix_cn4ipx_rxtx_intmskclr_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RXTX_INTMSKCLR_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RXTX_INTMSKCLR_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x8640008080b8ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RXTX_INTMSKCLR_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RXTX_INTMSKCLR_LNX(a,b,c) cavm_cprix_cn4ipx_rxtx_intmskclr_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RXTX_INTMSKCLR_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RXTX_INTMSKCLR_LNX(a,b,c) "CPRIX_CN4IPX_RXTX_INTMSKCLR_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RXTX_INTMSKCLR_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RXTX_INTMSKCLR_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rxtx_intmskset_ln#
 *
 * CPRI CONN4 IP RXTX Interrupt Mask SET Register
 */
union cavm_cprix_cn4ipx_rxtx_intmskset_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rxtx_intmskset_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_21_31        : 11;
        uint32_t rx_axc_error          : 1;  /**< [ 20: 20](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK.
                                                                     0 = no effect
                                                                     1 = Interrupt mask set */
        uint32_t tx_tim_call           : 1;  /**< [ 19: 19](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t tx_ol_coll            : 1;  /**< [ 18: 18](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t tx_tr_coll            : 1;  /**< [ 17: 17](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t sum_uf_err            : 1;  /**< [ 16: 16](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t sum_of_err            : 1;  /**< [ 15: 15](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t sum_col               : 1;  /**< [ 14: 14](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t sum_ts_err            : 1;  /**< [ 13: 13](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t sum_type_err          : 1;  /**< [ 12: 12](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t sum_addr_err          : 1;  /**< [ 11: 11](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_lcv_error          : 1;  /**< [ 10: 10](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_align_err          : 1;  /**< [  9:  9](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_msg_uf             : 1;  /**< [  8:  8](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_msg_of             : 1;  /**< [  7:  7](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_msg_hd_error       : 1;  /**< [  6:  6](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_msg_rt_err         : 1;  /**< [  5:  5](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_quality            : 1;  /**< [  4:  4](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_los                : 1;  /**< [  3:  3](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_fs_change          : 1;  /**< [  2:  2](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_st_change          : 1;  /**< [  1:  1](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_clk_error          : 1;  /**< [  0:  0](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
#else /* Word 0 - Little Endian */
        uint32_t rx_clk_error          : 1;  /**< [  0:  0](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_st_change          : 1;  /**< [  1:  1](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_fs_change          : 1;  /**< [  2:  2](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_los                : 1;  /**< [  3:  3](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_quality            : 1;  /**< [  4:  4](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_msg_rt_err         : 1;  /**< [  5:  5](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_msg_hd_error       : 1;  /**< [  6:  6](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_msg_of             : 1;  /**< [  7:  7](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_msg_uf             : 1;  /**< [  8:  8](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_align_err          : 1;  /**< [  9:  9](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_lcv_error          : 1;  /**< [ 10: 10](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t sum_addr_err          : 1;  /**< [ 11: 11](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t sum_type_err          : 1;  /**< [ 12: 12](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t sum_ts_err            : 1;  /**< [ 13: 13](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t sum_col               : 1;  /**< [ 14: 14](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t sum_of_err            : 1;  /**< [ 15: 15](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t sum_uf_err            : 1;  /**< [ 16: 16](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t tx_tr_coll            : 1;  /**< [ 17: 17](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t tx_ol_coll            : 1;  /**< [ 18: 18](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t tx_tim_call           : 1;  /**< [ 19: 19](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK. */
        uint32_t rx_axc_error          : 1;  /**< [ 20: 20](R/W1S/H) Set for corresponding interrupt mask bits in RXTX_INT_MASK.
                                                                     0 = no effect
                                                                     1 = Interrupt mask set */
        uint32_t reserved_21_31        : 11;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rxtx_intmskset_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rxtx_intmskset_lnx cavm_cprix_cn4ipx_rxtx_intmskset_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RXTX_INTMSKSET_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RXTX_INTMSKSET_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x8640008080bcll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RXTX_INTMSKSET_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RXTX_INTMSKSET_LNX(a,b,c) cavm_cprix_cn4ipx_rxtx_intmskset_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RXTX_INTMSKSET_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RXTX_INTMSKSET_LNX(a,b,c) "CPRIX_CN4IPX_RXTX_INTMSKSET_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RXTX_INTMSKSET_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RXTX_INTMSKSET_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_rxtx_loop_ln#
 *
 * CPRI CONN4 IP RXTX Loopback Enable Register
 */
union cavm_cprix_cn4ipx_rxtx_loop_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_rxtx_loop_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t rxtx_loop             : 1;  /**< [  0:  0](R/W) Enable loopback from RX to TX:
                                                                   0 = Loopback disabled.
                                                                   1 = Loopback enabled. */
#else /* Word 0 - Little Endian */
        uint32_t rxtx_loop             : 1;  /**< [  0:  0](R/W) Enable loopback from RX to TX:
                                                                   0 = Loopback disabled.
                                                                   1 = Loopback enabled. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_rxtx_loop_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_rxtx_loop_lnx cavm_cprix_cn4ipx_rxtx_loop_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_RXTX_LOOP_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_RXTX_LOOP_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x8640008080a4ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_RXTX_LOOP_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_RXTX_LOOP_LNX(a,b,c) cavm_cprix_cn4ipx_rxtx_loop_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_RXTX_LOOP_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_RXTX_LOOP_LNX(a,b,c) "CPRIX_CN4IPX_RXTX_LOOP_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_RXTX_LOOP_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_RXTX_LOOP_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_sfn_length
 *
 * CPRI CONN4 IP System Frame Number Length Register
 */
union cavm_cprix_cn4ipx_sfn_length
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_sfn_length_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t rp1_len_wcdma         : 1;  /**< [  7:  7](R/W) Length of WCDMA Frame Number for generated RP1 burst.
                                                                   0 = SFN is sent unaltered.
                                                                   1 = SFN is truncated to 12 bits. */
        uint32_t rp1_len_rp3           : 1;  /**< [  6:  6](R/W) Length of RP3 Frame Number for generated RP1 burst.
                                                                   0 = SFN is sent unaltered.
                                                                   1 = SFN is truncated to 12 bits. */
        uint32_t reserved_3_5          : 3;
        uint32_t rp3_length            : 3;  /**< [  2:  0](R/W) Length of Frame Number for generated RP3 type FCB messages.
                                                                   0 = SFN is sent unaltered.
                                                                   1 = SFN is truncated to 12 bits.
                                                                 There is an independent bit for each link. */
#else /* Word 0 - Little Endian */
        uint32_t rp3_length            : 3;  /**< [  2:  0](R/W) Length of Frame Number for generated RP3 type FCB messages.
                                                                   0 = SFN is sent unaltered.
                                                                   1 = SFN is truncated to 12 bits.
                                                                 There is an independent bit for each link. */
        uint32_t reserved_3_5          : 3;
        uint32_t rp1_len_rp3           : 1;  /**< [  6:  6](R/W) Length of RP3 Frame Number for generated RP1 burst.
                                                                   0 = SFN is sent unaltered.
                                                                   1 = SFN is truncated to 12 bits. */
        uint32_t rp1_len_wcdma         : 1;  /**< [  7:  7](R/W) Length of WCDMA Frame Number for generated RP1 burst.
                                                                   0 = SFN is sent unaltered.
                                                                   1 = SFN is truncated to 12 bits. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_sfn_length_s cn; */
};
typedef union cavm_cprix_cn4ipx_sfn_length cavm_cprix_cn4ipx_sfn_length_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_SFN_LENGTH(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_SFN_LENGTH(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f0e4ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_SFN_LENGTH", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_SFN_LENGTH(a,b) cavm_cprix_cn4ipx_sfn_length_t
#define bustype_CAVM_CPRIX_CN4IPX_SFN_LENGTH(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_SFN_LENGTH(a,b) "CPRIX_CN4IPX_SFN_LENGTH"
#define busnum_CAVM_CPRIX_CN4IPX_SFN_LENGTH(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_SFN_LENGTH(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_srx_qual_cfg_ln#
 *
 * CPRI CONN4 IP SerDes Reception Qualifier Configuration Register
 */
union cavm_cprix_cn4ipx_srx_qual_cfg_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_srx_qual_cfg_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t repeat_s              : 8;  /**< [ 31: 24](R/W) Number of consecutive windows with number of LCVs less than configured threshold
                                                                 for asserting SRX_QUALITY signal indicating line is good.
                                                                   0..0xFF = valid. */
        uint32_t threshold             : 8;  /**< [ 23: 16](R/W) Threshold for acceptable number of LCVs within a window.
                                                                   0..0xFF = valid. */
        uint32_t window                : 16; /**< [ 15:  0](R/W) Number of clock cycles in a qualifier window. LCV errors are counted within this window.
                                                                 Actual number of cycles is the value of this field plus one.
                                                                   0..0xFFFF = valid. */
#else /* Word 0 - Little Endian */
        uint32_t window                : 16; /**< [ 15:  0](R/W) Number of clock cycles in a qualifier window. LCV errors are counted within this window.
                                                                 Actual number of cycles is the value of this field plus one.
                                                                   0..0xFFFF = valid. */
        uint32_t threshold             : 8;  /**< [ 23: 16](R/W) Threshold for acceptable number of LCVs within a window.
                                                                   0..0xFF = valid. */
        uint32_t repeat_s              : 8;  /**< [ 31: 24](R/W) Number of consecutive windows with number of LCVs less than configured threshold
                                                                 for asserting SRX_QUALITY signal indicating line is good.
                                                                   0..0xFF = valid. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_srx_qual_cfg_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_srx_qual_cfg_lnx cavm_cprix_cn4ipx_srx_qual_cfg_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_SRX_QUAL_CFG_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_SRX_QUAL_CFG_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000808184ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_SRX_QUAL_CFG_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_SRX_QUAL_CFG_LNX(a,b,c) cavm_cprix_cn4ipx_srx_qual_cfg_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_SRX_QUAL_CFG_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_SRX_QUAL_CFG_LNX(a,b,c) "CPRIX_CN4IPX_SRX_QUAL_CFG_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_SRX_QUAL_CFG_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_SRX_QUAL_CFG_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_srx_qual_en_ln#
 *
 * CPRI CONN4 IP SerDes Reception Qualifier Enable Register
 */
union cavm_cprix_cn4ipx_srx_qual_en_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_srx_qual_en_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t enable                : 1;  /**< [  0:  0](R/W) Enable Reception Qualifier.
                                                                   0 = disabled.
                                                                   1 = enabled. */
#else /* Word 0 - Little Endian */
        uint32_t enable                : 1;  /**< [  0:  0](R/W) Enable Reception Qualifier.
                                                                   0 = disabled.
                                                                   1 = enabled. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_srx_qual_en_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_srx_qual_en_lnx cavm_cprix_cn4ipx_srx_qual_en_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_SRX_QUAL_EN_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_SRX_QUAL_EN_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000808180ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_SRX_QUAL_EN_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_SRX_QUAL_EN_LNX(a,b,c) cavm_cprix_cn4ipx_srx_qual_en_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_SRX_QUAL_EN_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_SRX_QUAL_EN_LNX(a,b,c) "CPRIX_CN4IPX_SRX_QUAL_EN_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_SRX_QUAL_EN_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_SRX_QUAL_EN_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_srx_qual_sts_ln#
 *
 * CPRI CONN4 IP SerDes Reception Qualifier Status Register
 */
union cavm_cprix_cn4ipx_srx_qual_sts_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_srx_qual_sts_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t status                : 1;  /**< [  0:  0](RO/H) Reception Qualifier Status.
                                                                   0 = signal is not OK.
                                                                   1 = signal is OK. */
#else /* Word 0 - Little Endian */
        uint32_t status                : 1;  /**< [  0:  0](RO/H) Reception Qualifier Status.
                                                                   0 = signal is not OK.
                                                                   1 = signal is OK. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_srx_qual_sts_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_srx_qual_sts_lnx cavm_cprix_cn4ipx_srx_qual_sts_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_SRX_QUAL_STS_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_SRX_QUAL_STS_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000808188ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_SRX_QUAL_STS_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_SRX_QUAL_STS_LNX(a,b,c) cavm_cprix_cn4ipx_srx_qual_sts_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_SRX_QUAL_STS_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_SRX_QUAL_STS_LNX(a,b,c) "CPRIX_CN4IPX_SRX_QUAL_STS_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_SRX_QUAL_STS_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_SRX_QUAL_STS_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_buff_ctrl#
 *
 * CPRI CONN4 IP Stream Buffer control and status lookup for buffer 0 to 191 Register
 */
union cavm_cprix_cn4ipx_str_buff_ctrlx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_buff_ctrlx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_25_31        : 7;
        uint32_t ts_lat_ctrl           : 5;  /**< [ 24: 20](R/W) Initial fill latency control. Used only when BUF_MODE=11 or 10.
                                                                 Controls how many messages are filled into buffer before allowing reading from buffer.
                                                                   0x0 = 0 message.
                                                                   0x1 = 1 messages.
                                                                   0x2 = 2 messages.

                                                                   0x1F = 31 messages.

                                                                 Fill level must be smaller than size of buffer. */
        uint32_t reserved_17_19        : 3;
        uint32_t group_wrerr           : 1;  /**< [ 16: 16](R/W/H) Messages received into buffer from more than one link group (SUM_ENA=0).
                                                                   0 = Normal operation.
                                                                   1 = Error. Messages received from more than one link group in non-summing mode.
                                                                 This status sets interrupt. Stream operation is halted and it must be disabled
                                                                 and enabled to continue operation.
                                                                 Note: also related transmission rule(s) should be reinitialized. */
        uint32_t reserved_13_15        : 3;
        uint32_t ts_miss               : 1;  /**< [ 12: 12](R/W/H) Timestamps missing. Only used when BUF_MODE[1]=1 (timestamp enabled operation).
                                                                   0 = Normal operation.
                                                                   1 = Timestamp was incremented by more than 2 between consecutive incoming
                                                                 messages. This status sets an interrupt. */
        uint32_t ts_mism               : 1;  /**< [ 11: 11](R/W/H) Timestamp mismatch in buffer read.
                                                                   0 = Normal operation.
                                                                   1 = Timestamp in buffer is not matching the requested read timestamp. Message
                                                                 has been lost. This status sets an interrupt.
                                                                 If BUF_MODE[1] (FIFO mode) this means buffer overflow. */
        uint32_t write_active          : 2;  /**< [ 10:  9](RO/H) Buffer write side is receiving messages.
                                                                   0 = No messages received into buffer.
                                                                   1 = Messages received into buffer from link group 0.
                                                                   2 = Messages received into buffer from link group 1.
                                                                   3 = Messages received into buffer from link group 0 and link groups 1. */
        uint32_t read_active           : 1;  /**< [  8:  8](RO/H) Buffer read side receives message requests.
                                                                   0 = No messages requested from buffer.
                                                                   1 = Messages requested from buffer. */
        uint32_t reserved_4_7          : 4;
        uint32_t buf_size              : 2;  /**< [  3:  2](R/W) Size of Stream buffer:
                                                                   0 = 8 messages.
                                                                   1 = 16 messages.
                                                                   2 = 32 messages.
                                                                 When BUF_SIZE is 01, odd numbered streams must not be used or activated.
                                                                 When BUF_SIZE is 10, only stream with number divisible by four should be used or activated.
                                                                 BUF_SIZE bits are mirrored for odd and even numbered streams.
                                                                 Bits written to either address are returned from both addresses. */
        uint32_t buf_mode              : 2;  /**< [  1:  0](R/W) Stream buffer enable and stream mode:
                                                                   0 = stream is disabled.
                                                                   1 = Low latency FIFO operation.
                                                                   2 = Timestamp controlled operation.
                                                                   3 = Timestamp controlled, reserved for summing enabled (not supported). */
#else /* Word 0 - Little Endian */
        uint32_t buf_mode              : 2;  /**< [  1:  0](R/W) Stream buffer enable and stream mode:
                                                                   0 = stream is disabled.
                                                                   1 = Low latency FIFO operation.
                                                                   2 = Timestamp controlled operation.
                                                                   3 = Timestamp controlled, reserved for summing enabled (not supported). */
        uint32_t buf_size              : 2;  /**< [  3:  2](R/W) Size of Stream buffer:
                                                                   0 = 8 messages.
                                                                   1 = 16 messages.
                                                                   2 = 32 messages.
                                                                 When BUF_SIZE is 01, odd numbered streams must not be used or activated.
                                                                 When BUF_SIZE is 10, only stream with number divisible by four should be used or activated.
                                                                 BUF_SIZE bits are mirrored for odd and even numbered streams.
                                                                 Bits written to either address are returned from both addresses. */
        uint32_t reserved_4_7          : 4;
        uint32_t read_active           : 1;  /**< [  8:  8](RO/H) Buffer read side receives message requests.
                                                                   0 = No messages requested from buffer.
                                                                   1 = Messages requested from buffer. */
        uint32_t write_active          : 2;  /**< [ 10:  9](RO/H) Buffer write side is receiving messages.
                                                                   0 = No messages received into buffer.
                                                                   1 = Messages received into buffer from link group 0.
                                                                   2 = Messages received into buffer from link group 1.
                                                                   3 = Messages received into buffer from link group 0 and link groups 1. */
        uint32_t ts_mism               : 1;  /**< [ 11: 11](R/W/H) Timestamp mismatch in buffer read.
                                                                   0 = Normal operation.
                                                                   1 = Timestamp in buffer is not matching the requested read timestamp. Message
                                                                 has been lost. This status sets an interrupt.
                                                                 If BUF_MODE[1] (FIFO mode) this means buffer overflow. */
        uint32_t ts_miss               : 1;  /**< [ 12: 12](R/W/H) Timestamps missing. Only used when BUF_MODE[1]=1 (timestamp enabled operation).
                                                                   0 = Normal operation.
                                                                   1 = Timestamp was incremented by more than 2 between consecutive incoming
                                                                 messages. This status sets an interrupt. */
        uint32_t reserved_13_15        : 3;
        uint32_t group_wrerr           : 1;  /**< [ 16: 16](R/W/H) Messages received into buffer from more than one link group (SUM_ENA=0).
                                                                   0 = Normal operation.
                                                                   1 = Error. Messages received from more than one link group in non-summing mode.
                                                                 This status sets interrupt. Stream operation is halted and it must be disabled
                                                                 and enabled to continue operation.
                                                                 Note: also related transmission rule(s) should be reinitialized. */
        uint32_t reserved_17_19        : 3;
        uint32_t ts_lat_ctrl           : 5;  /**< [ 24: 20](R/W) Initial fill latency control. Used only when BUF_MODE=11 or 10.
                                                                 Controls how many messages are filled into buffer before allowing reading from buffer.
                                                                   0x0 = 0 message.
                                                                   0x1 = 1 messages.
                                                                   0x2 = 2 messages.

                                                                   0x1F = 31 messages.

                                                                 Fill level must be smaller than size of buffer. */
        uint32_t reserved_25_31        : 7;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_buff_ctrlx_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_buff_ctrlx cavm_cprix_cn4ipx_str_buff_ctrlx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_BUFF_CTRLX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_BUFF_CTRLX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=191)))
        return 0x864000810008ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10ll * ((c) & 0xff);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_BUFF_CTRLX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_BUFF_CTRLX(a,b,c) cavm_cprix_cn4ipx_str_buff_ctrlx_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_BUFF_CTRLX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_BUFF_CTRLX(a,b,c) "CPRIX_CN4IPX_STR_BUFF_CTRLX"
#define busnum_CAVM_CPRIX_CN4IPX_STR_BUFF_CTRLX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_BUFF_CTRLX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_dbm_bm1_0h#
 *
 * CPRI CONN4 IP Stream Router Transmission Rule Dual Bit Map 1 bits (31:0) for DBM
 * rule 0, link group 0 Register
 */
union cavm_cprix_cn4ipx_str_dbm_bm1_0hx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_dbm_bm1_0hx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t bit_map_1_31_0        : 32; /**< [ 31:  0](R/W) Least Significant 32 bit value of Bit Map 1 (bits 31:0). The Bit Map is read
                                                                 starting from the leftmost (MSb) bit. */
#else /* Word 0 - Little Endian */
        uint32_t bit_map_1_31_0        : 32; /**< [ 31:  0](R/W) Least Significant 32 bit value of Bit Map 1 (bits 31:0). The Bit Map is read
                                                                 starting from the leftmost (MSb) bit. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_dbm_bm1_0hx_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_dbm_bm1_0hx cavm_cprix_cn4ipx_str_dbm_bm1_0hx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_DBM_BM1_0HX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_DBM_BM1_0HX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=3)))
        return 0x864000819e00ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x20ll * ((c) & 0x3);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_DBM_BM1_0HX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_0HX(a,b,c) cavm_cprix_cn4ipx_str_dbm_bm1_0hx_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_0HX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_0HX(a,b,c) "CPRIX_CN4IPX_STR_DBM_BM1_0HX"
#define busnum_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_0HX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_0HX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_dbm_bm1_0l#
 *
 * CPRI CONN4 IP Stream Router Transmission Rule Dual Bit Map 1 bits (31:0) for DBM
 * rule 0, link group 0 Register
 */
union cavm_cprix_cn4ipx_str_dbm_bm1_0lx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_dbm_bm1_0lx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t bit_map_1_31_0        : 32; /**< [ 31:  0](R/W) Least Significant 32 bit value of Bit Map 1 (bits 31:0). The Bit Map is read
                                                                 starting from the leftmost (MSb) bit. */
#else /* Word 0 - Little Endian */
        uint32_t bit_map_1_31_0        : 32; /**< [ 31:  0](R/W) Least Significant 32 bit value of Bit Map 1 (bits 31:0). The Bit Map is read
                                                                 starting from the leftmost (MSb) bit. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_dbm_bm1_0lx_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_dbm_bm1_0lx cavm_cprix_cn4ipx_str_dbm_bm1_0lx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_DBM_BM1_0LX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_DBM_BM1_0LX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=3)))
        return 0x864000819c80ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x20ll * ((c) & 0x3);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_DBM_BM1_0LX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_0LX(a,b,c) cavm_cprix_cn4ipx_str_dbm_bm1_0lx_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_0LX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_0LX(a,b,c) "CPRIX_CN4IPX_STR_DBM_BM1_0LX"
#define busnum_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_0LX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_0LX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_dbm_bm1_0m#
 *
 * CPRI CONN4 IP Stream Router Transmission Rule Dual Bit Map 1 bits (31:0) for DBM
 * rule 0, link group 0 Register
 */
union cavm_cprix_cn4ipx_str_dbm_bm1_0mx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_dbm_bm1_0mx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t bit_map_1_31_0        : 32; /**< [ 31:  0](R/W) Least Significant 32 bit value of Bit Map 1 (bits 31:0). The Bit Map is read
                                                                 starting from the leftmost (MSb) bit. */
#else /* Word 0 - Little Endian */
        uint32_t bit_map_1_31_0        : 32; /**< [ 31:  0](R/W) Least Significant 32 bit value of Bit Map 1 (bits 31:0). The Bit Map is read
                                                                 starting from the leftmost (MSb) bit. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_dbm_bm1_0mx_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_dbm_bm1_0mx cavm_cprix_cn4ipx_str_dbm_bm1_0mx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_DBM_BM1_0MX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_DBM_BM1_0MX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=7)))
        return 0x864000819d00ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x20ll * ((c) & 0x7);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_DBM_BM1_0MX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_0MX(a,b,c) cavm_cprix_cn4ipx_str_dbm_bm1_0mx_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_0MX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_0MX(a,b,c) "CPRIX_CN4IPX_STR_DBM_BM1_0MX"
#define busnum_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_0MX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_0MX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_dbm_bm1_1h#
 *
 * CPRI CONN4 IP Stream Router Transmission Rule Dual Bit Map 1 bits (63:32) for DBM
 * rule 0, link group 0 Register
 */
union cavm_cprix_cn4ipx_str_dbm_bm1_1hx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_dbm_bm1_1hx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t bit_map_1_63_32       : 32; /**< [ 31:  0](R/W) Middle 32 bit value of Bit Map 1 (bits 63:32). The Bit Map is read starting from
                                                                 the leftmost (MSb) bit. */
#else /* Word 0 - Little Endian */
        uint32_t bit_map_1_63_32       : 32; /**< [ 31:  0](R/W) Middle 32 bit value of Bit Map 1 (bits 63:32). The Bit Map is read starting from
                                                                 the leftmost (MSb) bit. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_dbm_bm1_1hx_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_dbm_bm1_1hx cavm_cprix_cn4ipx_str_dbm_bm1_1hx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_DBM_BM1_1HX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_DBM_BM1_1HX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=3)))
        return 0x864000819e04ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x20ll * ((c) & 0x3);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_DBM_BM1_1HX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_1HX(a,b,c) cavm_cprix_cn4ipx_str_dbm_bm1_1hx_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_1HX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_1HX(a,b,c) "CPRIX_CN4IPX_STR_DBM_BM1_1HX"
#define busnum_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_1HX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_1HX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_dbm_bm1_1l#
 *
 * CPRI CONN4 IP Stream Router Transmission Rule Dual Bit Map 1 bits (63:32) for DBM
 * rule 0, link group 0 Register
 */
union cavm_cprix_cn4ipx_str_dbm_bm1_1lx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_dbm_bm1_1lx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t bit_map_1_63_32       : 32; /**< [ 31:  0](R/W) Middle 32 bit value of Bit Map 1 (bits 63:32). The Bit Map is read starting from
                                                                 the leftmost (MSb) bit */
#else /* Word 0 - Little Endian */
        uint32_t bit_map_1_63_32       : 32; /**< [ 31:  0](R/W) Middle 32 bit value of Bit Map 1 (bits 63:32). The Bit Map is read starting from
                                                                 the leftmost (MSb) bit */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_dbm_bm1_1lx_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_dbm_bm1_1lx cavm_cprix_cn4ipx_str_dbm_bm1_1lx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_DBM_BM1_1LX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_DBM_BM1_1LX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=3)))
        return 0x864000819c84ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x20ll * ((c) & 0x3);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_DBM_BM1_1LX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_1LX(a,b,c) cavm_cprix_cn4ipx_str_dbm_bm1_1lx_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_1LX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_1LX(a,b,c) "CPRIX_CN4IPX_STR_DBM_BM1_1LX"
#define busnum_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_1LX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_1LX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_dbm_bm1_1m#
 *
 * CPRI CONN4 IP Stream Router Transmission Rule Dual Bit Map 1 bits (63:32) for DBM
 * rule 0, link group 0 Register
 */
union cavm_cprix_cn4ipx_str_dbm_bm1_1mx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_dbm_bm1_1mx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t bit_map_1_63_32       : 32; /**< [ 31:  0](R/W) Middle 32 bit value of Bit Map 1 (bits 63:32). The Bit Map is read starting from
                                                                 the leftmost (MSb) bit. */
#else /* Word 0 - Little Endian */
        uint32_t bit_map_1_63_32       : 32; /**< [ 31:  0](R/W) Middle 32 bit value of Bit Map 1 (bits 63:32). The Bit Map is read starting from
                                                                 the leftmost (MSb) bit. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_dbm_bm1_1mx_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_dbm_bm1_1mx cavm_cprix_cn4ipx_str_dbm_bm1_1mx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_DBM_BM1_1MX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_DBM_BM1_1MX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=7)))
        return 0x864000819d04ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x20ll * ((c) & 0x7);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_DBM_BM1_1MX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_1MX(a,b,c) cavm_cprix_cn4ipx_str_dbm_bm1_1mx_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_1MX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_1MX(a,b,c) "CPRIX_CN4IPX_STR_DBM_BM1_1MX"
#define busnum_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_1MX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_1MX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_dbm_bm1_2h#
 *
 * CPRI CONN4 IP Stream Router Transmission Rule Dual Bit Map 1 bits (79:64) and
 * Multiplier for DBM rule 0, link group 0 Register
 */
union cavm_cprix_cn4ipx_str_dbm_bm1_2hx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_dbm_bm1_2hx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t bit_map_1_mult        : 8;  /**< [ 23: 16](R/W) BIT_MAP_1 is repeated BIT_MAP_1_MULT times before BIT_MAP_2 starts.
                                                                   0 = Invalid.
                                                                   1 = BIT_MAP_1 used once. If BIT_MAP_2_SIZE \> 0,  then BIT_MAP_2 is used. If
                                                                 BIT_MAP_2_SIZE = 0, then BIT_MAP_1_MULT should be set to 1.
                                                                   2 = BIT_MAP_1 used 2 times and then BIT_MAP_2 is used once.
                                                                   3 = BIT_MAP_1 used 3 times and then BIT_MAP_2 is used once. */
        uint32_t bit_map_1_79_64       : 16; /**< [ 15:  0](R/W) Upper 16 bit value of Bit Map 1 (bits 79:64). The Bit Map is read starting from
                                                                 the leftmost (MSb) bit. Bit map is written left justified (i.e. if bit map is 01
                                                                 binary, 0 is written to bit 79, 1 is written to bit 78, all other bits are don't
                                                                 cares. */
#else /* Word 0 - Little Endian */
        uint32_t bit_map_1_79_64       : 16; /**< [ 15:  0](R/W) Upper 16 bit value of Bit Map 1 (bits 79:64). The Bit Map is read starting from
                                                                 the leftmost (MSb) bit. Bit map is written left justified (i.e. if bit map is 01
                                                                 binary, 0 is written to bit 79, 1 is written to bit 78, all other bits are don't
                                                                 cares. */
        uint32_t bit_map_1_mult        : 8;  /**< [ 23: 16](R/W) BIT_MAP_1 is repeated BIT_MAP_1_MULT times before BIT_MAP_2 starts.
                                                                   0 = Invalid.
                                                                   1 = BIT_MAP_1 used once. If BIT_MAP_2_SIZE \> 0,  then BIT_MAP_2 is used. If
                                                                 BIT_MAP_2_SIZE = 0, then BIT_MAP_1_MULT should be set to 1.
                                                                   2 = BIT_MAP_1 used 2 times and then BIT_MAP_2 is used once.
                                                                   3 = BIT_MAP_1 used 3 times and then BIT_MAP_2 is used once. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_dbm_bm1_2hx_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_dbm_bm1_2hx cavm_cprix_cn4ipx_str_dbm_bm1_2hx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_DBM_BM1_2HX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_DBM_BM1_2HX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=3)))
        return 0x864000819e08ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x20ll * ((c) & 0x3);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_DBM_BM1_2HX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_2HX(a,b,c) cavm_cprix_cn4ipx_str_dbm_bm1_2hx_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_2HX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_2HX(a,b,c) "CPRIX_CN4IPX_STR_DBM_BM1_2HX"
#define busnum_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_2HX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_2HX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_dbm_bm1_2l#
 *
 * CPRI CONN4 IP Stream Router Transmission Rule Dual Bit Map 1 bits (79:64) and
 * Multiplier for DBM rule 0, link group 0 Register
 */
union cavm_cprix_cn4ipx_str_dbm_bm1_2lx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_dbm_bm1_2lx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t bit_map_1_mult        : 8;  /**< [ 23: 16](R/W) BIT_MAP_1 is repeated BIT_MAP_1_MULT times before BIT_MAP_2 starts.
                                                                   0 = Invalid.
                                                                   1 = BIT_MAP_1 used once. If BIT_MAP_2_SIZE \> 0,  then BIT_MAP_2 is used. If
                                                                 BIT_MAP_2_SIZE = 0, then BIT_MAP_1_MULT should be set to 1.
                                                                   2 = BIT_MAP_1 used 2 times and then BIT_MAP_2 is used once.
                                                                   3 = BIT_MAP_1 used 3 times and then BIT_MAP_2 is used once. */
        uint32_t bit_map_1_79_64       : 16; /**< [ 15:  0](R/W) Upper 16 bit value of Bit Map 1 (bits 79:64). The Bit Map is read starting from
                                                                 the leftmost (MSb) bit. Bit map is written left justified (i.e. if bit map is 01
                                                                 binary, 0 is written to bit 79, 1 is written to bit 78, all other bits are don't
                                                                 cares. */
#else /* Word 0 - Little Endian */
        uint32_t bit_map_1_79_64       : 16; /**< [ 15:  0](R/W) Upper 16 bit value of Bit Map 1 (bits 79:64). The Bit Map is read starting from
                                                                 the leftmost (MSb) bit. Bit map is written left justified (i.e. if bit map is 01
                                                                 binary, 0 is written to bit 79, 1 is written to bit 78, all other bits are don't
                                                                 cares. */
        uint32_t bit_map_1_mult        : 8;  /**< [ 23: 16](R/W) BIT_MAP_1 is repeated BIT_MAP_1_MULT times before BIT_MAP_2 starts.
                                                                   0 = Invalid.
                                                                   1 = BIT_MAP_1 used once. If BIT_MAP_2_SIZE \> 0,  then BIT_MAP_2 is used. If
                                                                 BIT_MAP_2_SIZE = 0, then BIT_MAP_1_MULT should be set to 1.
                                                                   2 = BIT_MAP_1 used 2 times and then BIT_MAP_2 is used once.
                                                                   3 = BIT_MAP_1 used 3 times and then BIT_MAP_2 is used once. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_dbm_bm1_2lx_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_dbm_bm1_2lx cavm_cprix_cn4ipx_str_dbm_bm1_2lx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_DBM_BM1_2LX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_DBM_BM1_2LX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=3)))
        return 0x864000819c88ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x20ll * ((c) & 0x3);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_DBM_BM1_2LX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_2LX(a,b,c) cavm_cprix_cn4ipx_str_dbm_bm1_2lx_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_2LX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_2LX(a,b,c) "CPRIX_CN4IPX_STR_DBM_BM1_2LX"
#define busnum_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_2LX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_2LX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_dbm_bm1_2m#
 *
 * CPRI CONN4 IP Stream Router Transmission Rule Dual Bit Map 1 bits (79:64) and
 * Multiplier for DBM rule 0, link group 0 Register
 */
union cavm_cprix_cn4ipx_str_dbm_bm1_2mx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_dbm_bm1_2mx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t bit_map_1_mult        : 8;  /**< [ 23: 16](R/W) BIT_MAP_1 is repeated BIT_MAP_1_MULT times before BIT_MAP_2 starts.
                                                                   0 = Invalid.
                                                                   1 = BIT_MAP_1 used once. If BIT_MAP_2_SIZE \> 0,  then BIT_MAP_2 is used. If
                                                                 BIT_MAP_2_SIZE = 0, then BIT_MAP_1_MULT should be set to 1.
                                                                   2 = BIT_MAP_1 used 2 times and then BIT_MAP_2 is used once.
                                                                   3 = BIT_MAP_1 used 3 times and then BIT_MAP_2 is used once. */
        uint32_t bit_map_1_79_64       : 16; /**< [ 15:  0](R/W) Upper 16 bit value of Bit Map 1 (bits 79:64). The Bit Map is read starting from
                                                                 the leftmost (MSb) bit. Bit map is written left justified (i.e. if bit map is 01
                                                                 binary, 0 is written to bit 79, 1 is written to bit 78, all other bits are don't
                                                                 cares. */
#else /* Word 0 - Little Endian */
        uint32_t bit_map_1_79_64       : 16; /**< [ 15:  0](R/W) Upper 16 bit value of Bit Map 1 (bits 79:64). The Bit Map is read starting from
                                                                 the leftmost (MSb) bit. Bit map is written left justified (i.e. if bit map is 01
                                                                 binary, 0 is written to bit 79, 1 is written to bit 78, all other bits are don't
                                                                 cares. */
        uint32_t bit_map_1_mult        : 8;  /**< [ 23: 16](R/W) BIT_MAP_1 is repeated BIT_MAP_1_MULT times before BIT_MAP_2 starts.
                                                                   0 = Invalid.
                                                                   1 = BIT_MAP_1 used once. If BIT_MAP_2_SIZE \> 0,  then BIT_MAP_2 is used. If
                                                                 BIT_MAP_2_SIZE = 0, then BIT_MAP_1_MULT should be set to 1.
                                                                   2 = BIT_MAP_1 used 2 times and then BIT_MAP_2 is used once.
                                                                   3 = BIT_MAP_1 used 3 times and then BIT_MAP_2 is used once. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_dbm_bm1_2mx_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_dbm_bm1_2mx cavm_cprix_cn4ipx_str_dbm_bm1_2mx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_DBM_BM1_2MX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_DBM_BM1_2MX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=7)))
        return 0x864000819d08ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x20ll * ((c) & 0x7);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_DBM_BM1_2MX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_2MX(a,b,c) cavm_cprix_cn4ipx_str_dbm_bm1_2mx_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_2MX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_2MX(a,b,c) "CPRIX_CN4IPX_STR_DBM_BM1_2MX"
#define busnum_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_2MX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_2MX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_dbm_bm1_3h#
 *
 * CPRI CONN4 IP Stream Router Transmission Rule Dual Bit Map 1 Size and Virtual
 * Channel for DBM rule 0, link group 0 Register
 */
union cavm_cprix_cn4ipx_str_dbm_bm1_3hx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_dbm_bm1_3hx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t x                     : 8;  /**< [ 23: 16](R/W) 0x00 = No dual bitmap rules used. 'virtual channel' in use is 0.
                                                                 0x01 = 1 virtual channel inside dual bitmap rule.

                                                                 0xFE = 254 virtual channels inside dual bitmap rule.
                                                                 0xFF = Not allowed configuration

                                                                 Depending on BIT_MAP configuration part of capacity used by not usable virtual
                                                                 channel X, when normally VC runs from 0X-1 */
        uint32_t reserved_7_15         : 9;
        uint32_t bit_map_1_size        : 7;  /**< [  6:  0](R/W) Number of bits at BIT_MAP_1. The Bit Map is read starting from the leftmost (MSb) bit.
                                                                   0 = Invalid.
                                                                   1 = 1 MSb of BIT_MAP_1 used.
                                                                   2 = 2 MSb of BIT_MAP_1 used.

                                                                  0x50 = All 80 BIT_MAP_1 bits used.
                                                                 Others = not allowed. */
#else /* Word 0 - Little Endian */
        uint32_t bit_map_1_size        : 7;  /**< [  6:  0](R/W) Number of bits at BIT_MAP_1. The Bit Map is read starting from the leftmost (MSb) bit.
                                                                   0 = Invalid.
                                                                   1 = 1 MSb of BIT_MAP_1 used.
                                                                   2 = 2 MSb of BIT_MAP_1 used.

                                                                  0x50 = All 80 BIT_MAP_1 bits used.
                                                                 Others = not allowed. */
        uint32_t reserved_7_15         : 9;
        uint32_t x                     : 8;  /**< [ 23: 16](R/W) 0x00 = No dual bitmap rules used. 'virtual channel' in use is 0.
                                                                 0x01 = 1 virtual channel inside dual bitmap rule.

                                                                 0xFE = 254 virtual channels inside dual bitmap rule.
                                                                 0xFF = Not allowed configuration

                                                                 Depending on BIT_MAP configuration part of capacity used by not usable virtual
                                                                 channel X, when normally VC runs from 0X-1 */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_dbm_bm1_3hx_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_dbm_bm1_3hx cavm_cprix_cn4ipx_str_dbm_bm1_3hx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_DBM_BM1_3HX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_DBM_BM1_3HX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=3)))
        return 0x864000819e0cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x20ll * ((c) & 0x3);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_DBM_BM1_3HX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_3HX(a,b,c) cavm_cprix_cn4ipx_str_dbm_bm1_3hx_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_3HX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_3HX(a,b,c) "CPRIX_CN4IPX_STR_DBM_BM1_3HX"
#define busnum_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_3HX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_3HX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_dbm_bm1_3l#
 *
 * CPRI CONN4 IP Stream Router Transmission Rule Dual Bit Map 1 Size and Virtual
 * Channel for DBM rule 0, link group 0 Register
 */
union cavm_cprix_cn4ipx_str_dbm_bm1_3lx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_dbm_bm1_3lx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t x                     : 8;  /**< [ 23: 16](R/W) 0x00 = No dual bitmap rules used. 'virtual channel' in use is 0.
                                                                 0x01 = 1 virtual channel inside dual bitmap rule.

                                                                 0xFE = 254 virtual channels inside dual bitmap rule.
                                                                 0xFF = Not allowed configuration.

                                                                 Depending on BIT_MAP configuration part of capacity used by not usable virtual
                                                                 channel X, when normally VC runs from 0X-1. */
        uint32_t reserved_7_15         : 9;
        uint32_t bit_map_1_size        : 7;  /**< [  6:  0](R/W) Number of bits at BIT_MAP_1. The Bit Map is read starting from the leftmost (MSb) bit.
                                                                   0 = Invalid.
                                                                   1 = 1 MSb of BIT_MAP_1 used.
                                                                   2 = 2 MSb of BIT_MAP_1 used.

                                                                  0x50 = All 80 BIT_MAP_1 bits used.
                                                                 Others = not allowed. */
#else /* Word 0 - Little Endian */
        uint32_t bit_map_1_size        : 7;  /**< [  6:  0](R/W) Number of bits at BIT_MAP_1. The Bit Map is read starting from the leftmost (MSb) bit.
                                                                   0 = Invalid.
                                                                   1 = 1 MSb of BIT_MAP_1 used.
                                                                   2 = 2 MSb of BIT_MAP_1 used.

                                                                  0x50 = All 80 BIT_MAP_1 bits used.
                                                                 Others = not allowed. */
        uint32_t reserved_7_15         : 9;
        uint32_t x                     : 8;  /**< [ 23: 16](R/W) 0x00 = No dual bitmap rules used. 'virtual channel' in use is 0.
                                                                 0x01 = 1 virtual channel inside dual bitmap rule.

                                                                 0xFE = 254 virtual channels inside dual bitmap rule.
                                                                 0xFF = Not allowed configuration.

                                                                 Depending on BIT_MAP configuration part of capacity used by not usable virtual
                                                                 channel X, when normally VC runs from 0X-1. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_dbm_bm1_3lx_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_dbm_bm1_3lx cavm_cprix_cn4ipx_str_dbm_bm1_3lx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_DBM_BM1_3LX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_DBM_BM1_3LX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=3)))
        return 0x864000819c8cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x20ll * ((c) & 0x3);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_DBM_BM1_3LX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_3LX(a,b,c) cavm_cprix_cn4ipx_str_dbm_bm1_3lx_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_3LX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_3LX(a,b,c) "CPRIX_CN4IPX_STR_DBM_BM1_3LX"
#define busnum_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_3LX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_3LX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_dbm_bm1_3m#
 *
 * CPRI CONN4 IP Stream Router Transmission Rule Dual Bit Map 1 Size and Virtual
 * Channel for DBM rule 0, link group 0 Register
 */
union cavm_cprix_cn4ipx_str_dbm_bm1_3mx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_dbm_bm1_3mx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t x                     : 8;  /**< [ 23: 16](R/W) 0x00 = No dual bitmap rules used. 'virtual channel' in use is 0.
                                                                 0x01 = 1 virtual channel inside dual bitmap rule.

                                                                 0xFE = 254 virtual channels inside dual bitmap rule.
                                                                 0xFF = Not allowed configuration.

                                                                 Depending on BIT_MAP configuration part of capacity used by not usable virtual
                                                                 channel X, when normally VC runs from 0X-1. */
        uint32_t reserved_7_15         : 9;
        uint32_t bit_map_1_size        : 7;  /**< [  6:  0](R/W) Number of bits at BIT_MAP_1. The Bit Map is read starting from the leftmost (MSb) bit.
                                                                   0 = Invalid.
                                                                   1 = 1 MSb of BIT_MAP_1 used.
                                                                   2 = 2 MSb of BIT_MAP_1 used.

                                                                  0x50 = All 80 BIT_MAP_1 bits used.
                                                                 Others = not allowed. */
#else /* Word 0 - Little Endian */
        uint32_t bit_map_1_size        : 7;  /**< [  6:  0](R/W) Number of bits at BIT_MAP_1. The Bit Map is read starting from the leftmost (MSb) bit.
                                                                   0 = Invalid.
                                                                   1 = 1 MSb of BIT_MAP_1 used.
                                                                   2 = 2 MSb of BIT_MAP_1 used.

                                                                  0x50 = All 80 BIT_MAP_1 bits used.
                                                                 Others = not allowed. */
        uint32_t reserved_7_15         : 9;
        uint32_t x                     : 8;  /**< [ 23: 16](R/W) 0x00 = No dual bitmap rules used. 'virtual channel' in use is 0.
                                                                 0x01 = 1 virtual channel inside dual bitmap rule.

                                                                 0xFE = 254 virtual channels inside dual bitmap rule.
                                                                 0xFF = Not allowed configuration.

                                                                 Depending on BIT_MAP configuration part of capacity used by not usable virtual
                                                                 channel X, when normally VC runs from 0X-1. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_dbm_bm1_3mx_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_dbm_bm1_3mx cavm_cprix_cn4ipx_str_dbm_bm1_3mx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_DBM_BM1_3MX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_DBM_BM1_3MX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=7)))
        return 0x864000819d0cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x20ll * ((c) & 0x7);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_DBM_BM1_3MX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_3MX(a,b,c) cavm_cprix_cn4ipx_str_dbm_bm1_3mx_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_3MX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_3MX(a,b,c) "CPRIX_CN4IPX_STR_DBM_BM1_3MX"
#define busnum_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_3MX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_DBM_BM1_3MX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_dbm_bm2_0h#
 *
 * CPRI CONN4 IP Stream Router Transmission Rule Dual Bit Map 2 bits (31:0) for DBM
 * rule 0, link group 0 Register
 */
union cavm_cprix_cn4ipx_str_dbm_bm2_0hx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_dbm_bm2_0hx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t bit_map_2_31_0        : 32; /**< [ 31:  0](R/W) Least Significant 32 bit value of Bit Map 2 (bits 31:0). The Bit Map is read
                                                                 starting from the leftmost (MSb) bit. */
#else /* Word 0 - Little Endian */
        uint32_t bit_map_2_31_0        : 32; /**< [ 31:  0](R/W) Least Significant 32 bit value of Bit Map 2 (bits 31:0). The Bit Map is read
                                                                 starting from the leftmost (MSb) bit. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_dbm_bm2_0hx_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_dbm_bm2_0hx cavm_cprix_cn4ipx_str_dbm_bm2_0hx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_DBM_BM2_0HX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_DBM_BM2_0HX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=3)))
        return 0x864000819e10ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x20ll * ((c) & 0x3);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_DBM_BM2_0HX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_DBM_BM2_0HX(a,b,c) cavm_cprix_cn4ipx_str_dbm_bm2_0hx_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_DBM_BM2_0HX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_DBM_BM2_0HX(a,b,c) "CPRIX_CN4IPX_STR_DBM_BM2_0HX"
#define busnum_CAVM_CPRIX_CN4IPX_STR_DBM_BM2_0HX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_DBM_BM2_0HX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_dbm_bm2_0l#
 *
 * CPRI CONN4 IP Stream Router Transmission Rule Dual Bit Map 2 bits (31:0) for DBM
 * rule 0, link group 0 Register
 */
union cavm_cprix_cn4ipx_str_dbm_bm2_0lx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_dbm_bm2_0lx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t bit_map_2_31_0        : 32; /**< [ 31:  0](R/W) Least Significant 32 bit value of Bit Map 2 (bits 31:0). The Bit Map is read
                                                                 starting from the leftmost (MSb) bit. */
#else /* Word 0 - Little Endian */
        uint32_t bit_map_2_31_0        : 32; /**< [ 31:  0](R/W) Least Significant 32 bit value of Bit Map 2 (bits 31:0). The Bit Map is read
                                                                 starting from the leftmost (MSb) bit. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_dbm_bm2_0lx_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_dbm_bm2_0lx cavm_cprix_cn4ipx_str_dbm_bm2_0lx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_DBM_BM2_0LX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_DBM_BM2_0LX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=3)))
        return 0x864000819c90ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x20ll * ((c) & 0x3);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_DBM_BM2_0LX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_DBM_BM2_0LX(a,b,c) cavm_cprix_cn4ipx_str_dbm_bm2_0lx_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_DBM_BM2_0LX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_DBM_BM2_0LX(a,b,c) "CPRIX_CN4IPX_STR_DBM_BM2_0LX"
#define busnum_CAVM_CPRIX_CN4IPX_STR_DBM_BM2_0LX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_DBM_BM2_0LX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_dbm_bm2_0m#
 *
 * CPRI CONN4 IP Stream Router Transmission Rule Dual Bit Map 2 bits (31:0) for DBM
 * rule 0, link group 0 Register
 */
union cavm_cprix_cn4ipx_str_dbm_bm2_0mx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_dbm_bm2_0mx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t bit_map_2_31_0        : 32; /**< [ 31:  0](R/W) Least Significant 32 bit value of Bit Map 2 (bits 31:0). The Bit Map is read
                                                                 starting from the leftmost (MSb) bit. */
#else /* Word 0 - Little Endian */
        uint32_t bit_map_2_31_0        : 32; /**< [ 31:  0](R/W) Least Significant 32 bit value of Bit Map 2 (bits 31:0). The Bit Map is read
                                                                 starting from the leftmost (MSb) bit. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_dbm_bm2_0mx_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_dbm_bm2_0mx cavm_cprix_cn4ipx_str_dbm_bm2_0mx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_DBM_BM2_0MX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_DBM_BM2_0MX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=7)))
        return 0x864000819d10ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x20ll * ((c) & 0x7);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_DBM_BM2_0MX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_DBM_BM2_0MX(a,b,c) cavm_cprix_cn4ipx_str_dbm_bm2_0mx_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_DBM_BM2_0MX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_DBM_BM2_0MX(a,b,c) "CPRIX_CN4IPX_STR_DBM_BM2_0MX"
#define busnum_CAVM_CPRIX_CN4IPX_STR_DBM_BM2_0MX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_DBM_BM2_0MX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_dbm_bm2_1h#
 *
 * CPRI CONN4 IP Stream Router Transmission Rule Dual Bit Map 2 bits (47:32) and Size
 * for DBM rule 0, link group 0 Register
 */
union cavm_cprix_cn4ipx_str_dbm_bm2_1hx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_dbm_bm2_1hx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_22_31        : 10;
        uint32_t bit_map_2_size        : 6;  /**< [ 21: 16](R/W) Number of bits at BIT_MAP_2. The Bit Map is read starting from the leftmost (MSb) bit.
                                                                   0 = BIT_MAP_2 not used. BIT_MAP_1_MULT should be set to 1.
                                                                   1 = 1 MSb of BIT_MAP_2 used.
                                                                   2 = 2 MSb of BIT_MAP_2 used.

                                                                  0x30 = All 48 BIT_MAP_2 bits used.
                                                                  others = not allowed. */
        uint32_t bit_map_2_47_32       : 16; /**< [ 15:  0](R/W) Upper 16 bit value of Bit Map 2 (bits 47:32). The Bit Map is read starting from
                                                                 the leftmost (MSb) bit. Bit map is written left justified (i.e. if bit map is 01
                                                                 binary, 0 is written to bit 47, 1 is written to bit 46, all other bits are don't
                                                                 cares. */
#else /* Word 0 - Little Endian */
        uint32_t bit_map_2_47_32       : 16; /**< [ 15:  0](R/W) Upper 16 bit value of Bit Map 2 (bits 47:32). The Bit Map is read starting from
                                                                 the leftmost (MSb) bit. Bit map is written left justified (i.e. if bit map is 01
                                                                 binary, 0 is written to bit 47, 1 is written to bit 46, all other bits are don't
                                                                 cares. */
        uint32_t bit_map_2_size        : 6;  /**< [ 21: 16](R/W) Number of bits at BIT_MAP_2. The Bit Map is read starting from the leftmost (MSb) bit.
                                                                   0 = BIT_MAP_2 not used. BIT_MAP_1_MULT should be set to 1.
                                                                   1 = 1 MSb of BIT_MAP_2 used.
                                                                   2 = 2 MSb of BIT_MAP_2 used.

                                                                  0x30 = All 48 BIT_MAP_2 bits used.
                                                                  others = not allowed. */
        uint32_t reserved_22_31        : 10;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_dbm_bm2_1hx_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_dbm_bm2_1hx cavm_cprix_cn4ipx_str_dbm_bm2_1hx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_DBM_BM2_1HX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_DBM_BM2_1HX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=3)))
        return 0x864000819e14ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x20ll * ((c) & 0x3);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_DBM_BM2_1HX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_DBM_BM2_1HX(a,b,c) cavm_cprix_cn4ipx_str_dbm_bm2_1hx_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_DBM_BM2_1HX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_DBM_BM2_1HX(a,b,c) "CPRIX_CN4IPX_STR_DBM_BM2_1HX"
#define busnum_CAVM_CPRIX_CN4IPX_STR_DBM_BM2_1HX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_DBM_BM2_1HX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_dbm_bm2_1l#
 *
 * CPRI CONN4 IP Stream Router Transmission Rule Dual Bit Map 2 bits (47:32) and Size
 * for DBM rule 0, link group 0 Register
 */
union cavm_cprix_cn4ipx_str_dbm_bm2_1lx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_dbm_bm2_1lx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_22_31        : 10;
        uint32_t bit_map_2_size        : 6;  /**< [ 21: 16](R/W) Number of bits at BIT_MAP_2. The Bit Map is read starting from the leftmost (MSb) bit.
                                                                   0 = BIT_MAP_2 not used. BIT_MAP_1_MULT should be set to 1.
                                                                   1 = 1 MSb of BIT_MAP_2 used.
                                                                   2 = 2 MSb of BIT_MAP_2 used.

                                                                  0x30 = All 48 BIT_MAP_2 bits used.
                                                                  others = not allowed. */
        uint32_t bit_map_2_47_32       : 16; /**< [ 15:  0](R/W) Upper 16 bit value of Bit Map 2 (bits 47:32). The Bit Map is read starting from
                                                                 the leftmost (MSb) bit. Bit map is written left justified (i.e. if bit map is 01
                                                                 binary, 0 is written to bit 47, 1 is written to bit 46, all other bits are don't
                                                                 cares. */
#else /* Word 0 - Little Endian */
        uint32_t bit_map_2_47_32       : 16; /**< [ 15:  0](R/W) Upper 16 bit value of Bit Map 2 (bits 47:32). The Bit Map is read starting from
                                                                 the leftmost (MSb) bit. Bit map is written left justified (i.e. if bit map is 01
                                                                 binary, 0 is written to bit 47, 1 is written to bit 46, all other bits are don't
                                                                 cares. */
        uint32_t bit_map_2_size        : 6;  /**< [ 21: 16](R/W) Number of bits at BIT_MAP_2. The Bit Map is read starting from the leftmost (MSb) bit.
                                                                   0 = BIT_MAP_2 not used. BIT_MAP_1_MULT should be set to 1.
                                                                   1 = 1 MSb of BIT_MAP_2 used.
                                                                   2 = 2 MSb of BIT_MAP_2 used.

                                                                  0x30 = All 48 BIT_MAP_2 bits used.
                                                                  others = not allowed. */
        uint32_t reserved_22_31        : 10;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_dbm_bm2_1lx_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_dbm_bm2_1lx cavm_cprix_cn4ipx_str_dbm_bm2_1lx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_DBM_BM2_1LX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_DBM_BM2_1LX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=3)))
        return 0x864000819c94ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x20ll * ((c) & 0x3);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_DBM_BM2_1LX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_DBM_BM2_1LX(a,b,c) cavm_cprix_cn4ipx_str_dbm_bm2_1lx_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_DBM_BM2_1LX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_DBM_BM2_1LX(a,b,c) "CPRIX_CN4IPX_STR_DBM_BM2_1LX"
#define busnum_CAVM_CPRIX_CN4IPX_STR_DBM_BM2_1LX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_DBM_BM2_1LX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_dbm_bm2_1m#
 *
 * CPRI CONN4 IP Stream Router Transmission Rule Dual Bit Map 2 bits (47:32) and Size
 * for DBM rule 0, link group 0 Register
 */
union cavm_cprix_cn4ipx_str_dbm_bm2_1mx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_dbm_bm2_1mx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_22_31        : 10;
        uint32_t bit_map_2_size        : 6;  /**< [ 21: 16](R/W) Number of bits at BIT_MAP_2. The Bit Map is read starting from the leftmost (MSb) bit.
                                                                   0 = BIT_MAP_2 not used. BIT_MAP_1_MULT should be set to 1.
                                                                   1 = 1 MSb of BIT_MAP_2 used.
                                                                   2 = 2 MSb of BIT_MAP_2 used.

                                                                  0x30 = All 48 BIT_MAP_2 bits used.
                                                                  others = not allowed. */
        uint32_t bit_map_2_47_32       : 16; /**< [ 15:  0](R/W) Upper 16 bit value of Bit Map 2 (bits 47:32). The Bit Map is read starting from
                                                                 the leftmost (MSb) bit. Bit map is written left justified (i.e. if bit map is 01
                                                                 binary, 0 is written to bit 47, 1 is written to bit 46, all other bits are don't
                                                                 cares. */
#else /* Word 0 - Little Endian */
        uint32_t bit_map_2_47_32       : 16; /**< [ 15:  0](R/W) Upper 16 bit value of Bit Map 2 (bits 47:32). The Bit Map is read starting from
                                                                 the leftmost (MSb) bit. Bit map is written left justified (i.e. if bit map is 01
                                                                 binary, 0 is written to bit 47, 1 is written to bit 46, all other bits are don't
                                                                 cares. */
        uint32_t bit_map_2_size        : 6;  /**< [ 21: 16](R/W) Number of bits at BIT_MAP_2. The Bit Map is read starting from the leftmost (MSb) bit.
                                                                   0 = BIT_MAP_2 not used. BIT_MAP_1_MULT should be set to 1.
                                                                   1 = 1 MSb of BIT_MAP_2 used.
                                                                   2 = 2 MSb of BIT_MAP_2 used.

                                                                  0x30 = All 48 BIT_MAP_2 bits used.
                                                                  others = not allowed. */
        uint32_t reserved_22_31        : 10;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_dbm_bm2_1mx_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_dbm_bm2_1mx cavm_cprix_cn4ipx_str_dbm_bm2_1mx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_DBM_BM2_1MX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_DBM_BM2_1MX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=7)))
        return 0x864000819d14ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x20ll * ((c) & 0x7);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_DBM_BM2_1MX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_DBM_BM2_1MX(a,b,c) cavm_cprix_cn4ipx_str_dbm_bm2_1mx_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_DBM_BM2_1MX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_DBM_BM2_1MX(a,b,c) "CPRIX_CN4IPX_STR_DBM_BM2_1MX"
#define busnum_CAVM_CPRIX_CN4IPX_STR_DBM_BM2_1MX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_DBM_BM2_1MX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_fill_level
 *
 * CPRI CONN4 IP Select stream id for fill level monitoring Register
 */
union cavm_cprix_cn4ipx_str_fill_level
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_fill_level_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_29_31        : 3;
        uint32_t min_lev               : 5;  /**< [ 28: 24](RO/H) Stream buffer min level during monitoring period. */
        uint32_t reserved_21_23        : 3;
        uint32_t max_lev               : 5;  /**< [ 20: 16](RO/H) Stream buffer max level during monitoring period. */
        uint32_t reserved_8_15         : 8;
        uint32_t stream_id             : 8;  /**< [  7:  0](R/W) Stream buffer id where level values are monitored. */
#else /* Word 0 - Little Endian */
        uint32_t stream_id             : 8;  /**< [  7:  0](R/W) Stream buffer id where level values are monitored. */
        uint32_t reserved_8_15         : 8;
        uint32_t max_lev               : 5;  /**< [ 20: 16](RO/H) Stream buffer max level during monitoring period. */
        uint32_t reserved_21_23        : 3;
        uint32_t min_lev               : 5;  /**< [ 28: 24](RO/H) Stream buffer min level during monitoring period. */
        uint32_t reserved_29_31        : 3;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_fill_level_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_fill_level cavm_cprix_cn4ipx_str_fill_level_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_FILL_LEVEL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_FILL_LEVEL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000812000ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_FILL_LEVEL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_FILL_LEVEL(a,b) cavm_cprix_cn4ipx_str_fill_level_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_FILL_LEVEL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_FILL_LEVEL(a,b) "CPRIX_CN4IPX_STR_FILL_LEVEL"
#define busnum_CAVM_CPRIX_CN4IPX_STR_FILL_LEVEL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_FILL_LEVEL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_insert#
 *
 * CPRI CONN4 IP Stream Router Message Insertion 0 Control and Status Register
 */
union cavm_cprix_cn4ipx_str_insertx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_insertx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t enable                : 1;  /**< [  0:  0](R/W1S/H) Insertion enable. When this bit written high, the RP3 message content residing
                                                                 in registers STR_INSERT_0/1/2/3/4 is inserted into the message data stream into
                                                                 Stream Router at the first instant when there is free capacity on the interface.
                                                                 Hardware deasserts the bit when message has been inserted into the message stream.
                                                                     0 = do not insert.
                                                                     1 = insert. */
#else /* Word 0 - Little Endian */
        uint32_t enable                : 1;  /**< [  0:  0](R/W1S/H) Insertion enable. When this bit written high, the RP3 message content residing
                                                                 in registers STR_INSERT_0/1/2/3/4 is inserted into the message data stream into
                                                                 Stream Router at the first instant when there is free capacity on the interface.
                                                                 Hardware deasserts the bit when message has been inserted into the message stream.
                                                                     0 = do not insert.
                                                                     1 = insert. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_insertx_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_insertx cavm_cprix_cn4ipx_str_insertx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_INSERTX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_INSERTX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000812114ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x40ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_INSERTX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_INSERTX(a,b,c) cavm_cprix_cn4ipx_str_insertx_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_INSERTX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_INSERTX(a,b,c) "CPRIX_CN4IPX_STR_INSERTX"
#define busnum_CAVM_CPRIX_CN4IPX_STR_INSERTX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_INSERTX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_insert_0#
 *
 * CPRI CONN4 IP Stream Router Message Insertion Data 0 of 4 Register
 */
union cavm_cprix_cn4ipx_str_insert_0x
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_insert_0x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t data_31_0             : 32; /**< [ 31:  0](R/W) Insertion message bits 31:0. */
#else /* Word 0 - Little Endian */
        uint32_t data_31_0             : 32; /**< [ 31:  0](R/W) Insertion message bits 31:0. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_insert_0x_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_insert_0x cavm_cprix_cn4ipx_str_insert_0x_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_INSERT_0X(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_INSERT_0X(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000812100ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x40ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_INSERT_0X", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_INSERT_0X(a,b,c) cavm_cprix_cn4ipx_str_insert_0x_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_INSERT_0X(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_INSERT_0X(a,b,c) "CPRIX_CN4IPX_STR_INSERT_0X"
#define busnum_CAVM_CPRIX_CN4IPX_STR_INSERT_0X(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_INSERT_0X(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_insert_1#
 *
 * CPRI CONN4 IP Stream Router Message Insertion Data 1 of 4 Register
 */
union cavm_cprix_cn4ipx_str_insert_1x
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_insert_1x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t data_63_32            : 32; /**< [ 31:  0](R/W) Insertion message bits 31:0. */
#else /* Word 0 - Little Endian */
        uint32_t data_63_32            : 32; /**< [ 31:  0](R/W) Insertion message bits 31:0. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_insert_1x_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_insert_1x cavm_cprix_cn4ipx_str_insert_1x_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_INSERT_1X(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_INSERT_1X(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000812104ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x40ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_INSERT_1X", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_INSERT_1X(a,b,c) cavm_cprix_cn4ipx_str_insert_1x_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_INSERT_1X(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_INSERT_1X(a,b,c) "CPRIX_CN4IPX_STR_INSERT_1X"
#define busnum_CAVM_CPRIX_CN4IPX_STR_INSERT_1X(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_INSERT_1X(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_insert_2#
 *
 * CPRI CONN4 IP Stream Router Message Insertion Data 2 of 4 Register
 */
union cavm_cprix_cn4ipx_str_insert_2x
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_insert_2x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t data_95_64            : 32; /**< [ 31:  0](R/W) Insertion message bits 31:0. */
#else /* Word 0 - Little Endian */
        uint32_t data_95_64            : 32; /**< [ 31:  0](R/W) Insertion message bits 31:0. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_insert_2x_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_insert_2x cavm_cprix_cn4ipx_str_insert_2x_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_INSERT_2X(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_INSERT_2X(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000812108ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x40ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_INSERT_2X", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_INSERT_2X(a,b,c) cavm_cprix_cn4ipx_str_insert_2x_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_INSERT_2X(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_INSERT_2X(a,b,c) "CPRIX_CN4IPX_STR_INSERT_2X"
#define busnum_CAVM_CPRIX_CN4IPX_STR_INSERT_2X(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_INSERT_2X(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_insert_3#
 *
 * CPRI CONN4 IP Stream Router Message Insertion Data 3 of 4 Register
 */
union cavm_cprix_cn4ipx_str_insert_3x
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_insert_3x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t data_127_96           : 32; /**< [ 31:  0](R/W) Insertion message bits 31:0. */
#else /* Word 0 - Little Endian */
        uint32_t data_127_96           : 32; /**< [ 31:  0](R/W) Insertion message bits 31:0. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_insert_3x_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_insert_3x cavm_cprix_cn4ipx_str_insert_3x_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_INSERT_3X(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_INSERT_3X(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x86400081210cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x40ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_INSERT_3X", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_INSERT_3X(a,b,c) cavm_cprix_cn4ipx_str_insert_3x_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_INSERT_3X(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_INSERT_3X(a,b,c) "CPRIX_CN4IPX_STR_INSERT_3X"
#define busnum_CAVM_CPRIX_CN4IPX_STR_INSERT_3X(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_INSERT_3X(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_insert_4#
 *
 * CPRI CONN4 IP Stream Router Message Insertion Data 4 of 4 Register
 */
union cavm_cprix_cn4ipx_str_insert_4x
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_insert_4x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t stream_id             : 8;  /**< [ 31: 24](R/W) Stream ID of target stream.
                                                                   0 .. 0xFF = valid. */
        uint32_t data_151_128          : 24; /**< [ 23:  0](R/W) Insertion message bits 31:0. */
#else /* Word 0 - Little Endian */
        uint32_t data_151_128          : 24; /**< [ 23:  0](R/W) Insertion message bits 31:0. */
        uint32_t stream_id             : 8;  /**< [ 31: 24](R/W) Stream ID of target stream.
                                                                   0 .. 0xFF = valid. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_insert_4x_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_insert_4x cavm_cprix_cn4ipx_str_insert_4x_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_INSERT_4X(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_INSERT_4X(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000812110ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x40ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_INSERT_4X", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_INSERT_4X(a,b,c) cavm_cprix_cn4ipx_str_insert_4x_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_INSERT_4X(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_INSERT_4X(a,b,c) "CPRIX_CN4IPX_STR_INSERT_4X"
#define busnum_CAVM_CPRIX_CN4IPX_STR_INSERT_4X(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_INSERT_4X(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_int_clr
 *
 * CPRI CONN4 IP Stream Routing Interrupt Event Clear Register
 */
union cavm_cprix_cn4ipx_str_int_clr
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_int_clr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t tr_col1               : 1;  /**< [  3:  3](R/W1C/H) Clear for corresponding interrupt status bits in STR_INT:
                                                                     0 = no effect.
                                                                     1 = Interrupt Clear. */
        uint32_t tr_col0               : 1;  /**< [  2:  2](R/W1C/H) Clear for corresponding interrupt status bits in STR_INT. */
        uint32_t buff_err              : 1;  /**< [  1:  1](R/W1C/H) Clear for corresponding interrupt status bits in STR_INT. */
        uint32_t map_coll              : 1;  /**< [  0:  0](R/W1C/H) Clear for corresponding interrupt status bits in STR_INT. */
#else /* Word 0 - Little Endian */
        uint32_t map_coll              : 1;  /**< [  0:  0](R/W1C/H) Clear for corresponding interrupt status bits in STR_INT. */
        uint32_t buff_err              : 1;  /**< [  1:  1](R/W1C/H) Clear for corresponding interrupt status bits in STR_INT. */
        uint32_t tr_col0               : 1;  /**< [  2:  2](R/W1C/H) Clear for corresponding interrupt status bits in STR_INT. */
        uint32_t tr_col1               : 1;  /**< [  3:  3](R/W1C/H) Clear for corresponding interrupt status bits in STR_INT:
                                                                     0 = no effect.
                                                                     1 = Interrupt Clear. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_int_clr_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_int_clr cavm_cprix_cn4ipx_str_int_clr_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_INT_CLR(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_INT_CLR(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000812044ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_INT_CLR", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_INT_CLR(a,b) cavm_cprix_cn4ipx_str_int_clr_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_INT_CLR(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_INT_CLR(a,b) "CPRIX_CN4IPX_STR_INT_CLR"
#define busnum_CAVM_CPRIX_CN4IPX_STR_INT_CLR(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_INT_CLR(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_int_mask
 *
 * CPRI CONN4 IP Stream Routing Interrupt Mask Register
 */
union cavm_cprix_cn4ipx_str_int_mask
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_int_mask_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t tr_col1               : 1;  /**< [  3:  3](R/W) Mask for corresponding interrupt status bits in STR_INT:
                                                                     0 = Interrupt enabled.
                                                                     1 = Interrupt Masked. */
        uint32_t tr_col0               : 1;  /**< [  2:  2](R/W) Mask for corresponding interrupt status bits in STR_INT. */
        uint32_t buff_err              : 1;  /**< [  1:  1](R/W) Mask for corresponding interrupt status bits in STR_INT. */
        uint32_t map_coll              : 1;  /**< [  0:  0](R/W) Mask for corresponding interrupt status bits in STR_INT. */
#else /* Word 0 - Little Endian */
        uint32_t map_coll              : 1;  /**< [  0:  0](R/W) Mask for corresponding interrupt status bits in STR_INT. */
        uint32_t buff_err              : 1;  /**< [  1:  1](R/W) Mask for corresponding interrupt status bits in STR_INT. */
        uint32_t tr_col0               : 1;  /**< [  2:  2](R/W) Mask for corresponding interrupt status bits in STR_INT. */
        uint32_t tr_col1               : 1;  /**< [  3:  3](R/W) Mask for corresponding interrupt status bits in STR_INT:
                                                                     0 = Interrupt enabled.
                                                                     1 = Interrupt Masked. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_int_mask_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_int_mask cavm_cprix_cn4ipx_str_int_mask_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_INT_MASK(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_INT_MASK(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400081204cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_INT_MASK", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_INT_MASK(a,b) cavm_cprix_cn4ipx_str_int_mask_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_INT_MASK(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_INT_MASK(a,b) "CPRIX_CN4IPX_STR_INT_MASK"
#define busnum_CAVM_CPRIX_CN4IPX_STR_INT_MASK(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_INT_MASK(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_int_mask_clr
 *
 * CPRI CONN4 IP Stream Routing Interrupt Mask Clear Register
 */
union cavm_cprix_cn4ipx_str_int_mask_clr
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_int_mask_clr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t tr_col1               : 1;  /**< [  3:  3](R/W1C/H) Mask clear for corresponding interrupt status bits in STR_INT:
                                                                     0 = No effect.
                                                                     1 = Mask Clear. */
        uint32_t tr_col0               : 1;  /**< [  2:  2](R/W1C/H) Mask clear for corresponding interrupt status bits in STR_INT. */
        uint32_t buff_err              : 1;  /**< [  1:  1](R/W1C/H) Mask clear for corresponding interrupt status bits in STR_INT. */
        uint32_t map_coll              : 1;  /**< [  0:  0](R/W1C/H) Mask clear for corresponding interrupt status bits in STR_INT. */
#else /* Word 0 - Little Endian */
        uint32_t map_coll              : 1;  /**< [  0:  0](R/W1C/H) Mask clear for corresponding interrupt status bits in STR_INT. */
        uint32_t buff_err              : 1;  /**< [  1:  1](R/W1C/H) Mask clear for corresponding interrupt status bits in STR_INT. */
        uint32_t tr_col0               : 1;  /**< [  2:  2](R/W1C/H) Mask clear for corresponding interrupt status bits in STR_INT. */
        uint32_t tr_col1               : 1;  /**< [  3:  3](R/W1C/H) Mask clear for corresponding interrupt status bits in STR_INT:
                                                                     0 = No effect.
                                                                     1 = Mask Clear. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_int_mask_clr_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_int_mask_clr cavm_cprix_cn4ipx_str_int_mask_clr_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_INT_MASK_CLR(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_INT_MASK_CLR(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000812050ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_INT_MASK_CLR", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_INT_MASK_CLR(a,b) cavm_cprix_cn4ipx_str_int_mask_clr_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_INT_MASK_CLR(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_INT_MASK_CLR(a,b) "CPRIX_CN4IPX_STR_INT_MASK_CLR"
#define busnum_CAVM_CPRIX_CN4IPX_STR_INT_MASK_CLR(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_INT_MASK_CLR(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_int_mask_set
 *
 * CPRI CONN4 IP Stream Routing Interrupt Mask Set Register
 */
union cavm_cprix_cn4ipx_str_int_mask_set
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_int_mask_set_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t tr_col1               : 1;  /**< [  3:  3](R/W1S/H) Mask set for corresponding interrupt status bits in STR_INT:
                                                                     0 = No effect.
                                                                     1 = Mask Set. */
        uint32_t tr_col0               : 1;  /**< [  2:  2](R/W1S/H) Mask set for corresponding interrupt status bits in STR_INT. */
        uint32_t buff_err              : 1;  /**< [  1:  1](R/W1S/H) Mask set for corresponding interrupt status bits in STR_INT. */
        uint32_t map_coll              : 1;  /**< [  0:  0](R/W1S/H) Mask set for corresponding interrupt status bits in STR_INT. */
#else /* Word 0 - Little Endian */
        uint32_t map_coll              : 1;  /**< [  0:  0](R/W1S/H) Mask set for corresponding interrupt status bits in STR_INT. */
        uint32_t buff_err              : 1;  /**< [  1:  1](R/W1S/H) Mask set for corresponding interrupt status bits in STR_INT. */
        uint32_t tr_col0               : 1;  /**< [  2:  2](R/W1S/H) Mask set for corresponding interrupt status bits in STR_INT. */
        uint32_t tr_col1               : 1;  /**< [  3:  3](R/W1S/H) Mask set for corresponding interrupt status bits in STR_INT:
                                                                     0 = No effect.
                                                                     1 = Mask Set. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_int_mask_set_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_int_mask_set cavm_cprix_cn4ipx_str_int_mask_set_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_INT_MASK_SET(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_INT_MASK_SET(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000812054ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_INT_MASK_SET", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_INT_MASK_SET(a,b) cavm_cprix_cn4ipx_str_int_mask_set_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_INT_MASK_SET(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_INT_MASK_SET(a,b) "CPRIX_CN4IPX_STR_INT_MASK_SET"
#define busnum_CAVM_CPRIX_CN4IPX_STR_INT_MASK_SET(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_INT_MASK_SET(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_int_set
 *
 * CPRI CONN4 IP Stream Routing Interrupt Event Set Register
 */
union cavm_cprix_cn4ipx_str_int_set
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_int_set_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t tr_col1               : 1;  /**< [  3:  3](R/W1S/H) Set for corresponding interrupt status bits in STR_INT:
                                                                     0 = no effect.
                                                                     1 = Interrupt Set. */
        uint32_t tr_col0               : 1;  /**< [  2:  2](R/W1S/H) Set for corresponding interrupt status bits in STR_INT. */
        uint32_t buff_err              : 1;  /**< [  1:  1](R/W1S/H) Set for corresponding interrupt status bits in STR_INT. */
        uint32_t map_coll              : 1;  /**< [  0:  0](R/W1S/H) Set for corresponding interrupt status bits in STR_INT. */
#else /* Word 0 - Little Endian */
        uint32_t map_coll              : 1;  /**< [  0:  0](R/W1S/H) Set for corresponding interrupt status bits in STR_INT. */
        uint32_t buff_err              : 1;  /**< [  1:  1](R/W1S/H) Set for corresponding interrupt status bits in STR_INT. */
        uint32_t tr_col0               : 1;  /**< [  2:  2](R/W1S/H) Set for corresponding interrupt status bits in STR_INT. */
        uint32_t tr_col1               : 1;  /**< [  3:  3](R/W1S/H) Set for corresponding interrupt status bits in STR_INT:
                                                                     0 = no effect.
                                                                     1 = Interrupt Set. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_int_set_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_int_set cavm_cprix_cn4ipx_str_int_set_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_INT_SET(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_INT_SET(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000812048ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_INT_SET", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_INT_SET(a,b) cavm_cprix_cn4ipx_str_int_set_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_INT_SET(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_INT_SET(a,b) "CPRIX_CN4IPX_STR_INT_SET"
#define busnum_CAVM_CPRIX_CN4IPX_STR_INT_SET(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_INT_SET(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_int_status
 *
 * CPRI CONN4 IP Stream Routing Interrupt Status Register
 */
union cavm_cprix_cn4ipx_str_int_status
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_int_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t tr_col1               : 1;  /**< [  3:  3](RO/H) Collision in TR in Link Group 1:
                                                                     0 = No Interrupt.
                                                                     1 = Active interrupt. */
        uint32_t tr_col0               : 1;  /**< [  2:  2](RO/H) Collision in TR in Link Group 0:
                                                                     0 = No Interrupt.
                                                                     1 = Active interrupt. */
        uint32_t buff_err              : 1;  /**< [  1:  1](RO/H) Error in stream routing buffer. */
        uint32_t map_coll              : 1;  /**< [  0:  0](RO/H) Collision in stream mapping. Multiple lookups active at the same time. */
#else /* Word 0 - Little Endian */
        uint32_t map_coll              : 1;  /**< [  0:  0](RO/H) Collision in stream mapping. Multiple lookups active at the same time. */
        uint32_t buff_err              : 1;  /**< [  1:  1](RO/H) Error in stream routing buffer. */
        uint32_t tr_col0               : 1;  /**< [  2:  2](RO/H) Collision in TR in Link Group 0:
                                                                     0 = No Interrupt.
                                                                     1 = Active interrupt. */
        uint32_t tr_col1               : 1;  /**< [  3:  3](RO/H) Collision in TR in Link Group 1:
                                                                     0 = No Interrupt.
                                                                     1 = Active interrupt. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_int_status_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_int_status cavm_cprix_cn4ipx_str_int_status_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_INT_STATUS(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_INT_STATUS(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000812040ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_INT_STATUS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_INT_STATUS(a,b) cavm_cprix_cn4ipx_str_int_status_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_INT_STATUS(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_INT_STATUS(a,b) "CPRIX_CN4IPX_STR_INT_STATUS"
#define busnum_CAVM_CPRIX_CN4IPX_STR_INT_STATUS(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_INT_STATUS(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_map_hdr#
 *
 * CPRI CONN4 IP Stream mapping header lookup for buffer 0 to 255 Register
 */
union cavm_cprix_cn4ipx_str_map_hdrx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_map_hdrx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_18_31        : 14;
        uint32_t map_addr              : 13; /**< [ 17:  5](R/W) RP3 header address for accepting message to this stream buffer. */
        uint32_t map_type              : 5;  /**< [  4:  0](R/W) RP3 header type for accepting message to this stream buffer. */
#else /* Word 0 - Little Endian */
        uint32_t map_type              : 5;  /**< [  4:  0](R/W) RP3 header type for accepting message to this stream buffer. */
        uint32_t map_addr              : 13; /**< [ 17:  5](R/W) RP3 header address for accepting message to this stream buffer. */
        uint32_t reserved_18_31        : 14;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_map_hdrx_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_map_hdrx cavm_cprix_cn4ipx_str_map_hdrx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_MAP_HDRX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_MAP_HDRX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=255)))
        return 0x864000810000ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10ll * ((c) & 0xff);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_MAP_HDRX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_MAP_HDRX(a,b,c) cavm_cprix_cn4ipx_str_map_hdrx_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_MAP_HDRX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_MAP_HDRX(a,b,c) "CPRIX_CN4IPX_STR_MAP_HDRX"
#define busnum_CAVM_CPRIX_CN4IPX_STR_MAP_HDRX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_MAP_HDRX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_map_link#
 *
 * CPRI CONN4 IP Stream mapping link selection lookup for buffer 0 to 255 Register
 */
union cavm_cprix_cn4ipx_str_map_linkx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_map_linkx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t map_link              : 4;  /**< [  3:  0](R/W) Link selection for accepting messages to this stream buffer.
                                                                 There is a separate bit for each link, where bit 0 corresponds to link 0, bit 1
                                                                 to link 1 and bit 3 corresponds to RP3 Uplink interface. Bit 2 is not used.

                                                                   0 = Messages from this link are not accepted to this buffer.
                                                                   1 = Messages from this link are accepted to this buffer.

                                                                 Note : Only RP3 uplink interface is valid in CONN004. */
#else /* Word 0 - Little Endian */
        uint32_t map_link              : 4;  /**< [  3:  0](R/W) Link selection for accepting messages to this stream buffer.
                                                                 There is a separate bit for each link, where bit 0 corresponds to link 0, bit 1
                                                                 to link 1 and bit 3 corresponds to RP3 Uplink interface. Bit 2 is not used.

                                                                   0 = Messages from this link are not accepted to this buffer.
                                                                   1 = Messages from this link are accepted to this buffer.

                                                                 Note : Only RP3 uplink interface is valid in CONN004. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_map_linkx_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_map_linkx cavm_cprix_cn4ipx_str_map_linkx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_MAP_LINKX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_MAP_LINKX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=255)))
        return 0x864000810004ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x10ll * ((c) & 0xff);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_MAP_LINKX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_MAP_LINKX(a,b,c) cavm_cprix_cn4ipx_str_map_linkx_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_MAP_LINKX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_MAP_LINKX(a,b,c) "CPRIX_CN4IPX_STR_MAP_LINKX"
#define busnum_CAVM_CPRIX_CN4IPX_STR_MAP_LINKX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_MAP_LINKX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_rx_bcn1
 *
 * CPRI CONN4 IP Stream Router Reception BCN timer 1 value Register
 */
union cavm_cprix_cn4ipx_str_rx_bcn1
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_rx_bcn1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t n1_lsb                : 8;  /**< [ 31: 24](RO/H) BCN timer N1 LSb value. */
        uint32_t n2                    : 24; /**< [ 23:  0](RO/H) BCN timer N2 value. 2 LSbs are always 0. */
#else /* Word 0 - Little Endian */
        uint32_t n2                    : 24; /**< [ 23:  0](RO/H) BCN timer N2 value. 2 LSbs are always 0. */
        uint32_t n1_lsb                : 8;  /**< [ 31: 24](RO/H) BCN timer N1 LSb value. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_rx_bcn1_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_rx_bcn1 cavm_cprix_cn4ipx_str_rx_bcn1_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_RX_BCN1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_RX_BCN1(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400081200cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_RX_BCN1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_RX_BCN1(a,b) cavm_cprix_cn4ipx_str_rx_bcn1_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_RX_BCN1(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_RX_BCN1(a,b) "CPRIX_CN4IPX_STR_RX_BCN1"
#define busnum_CAVM_CPRIX_CN4IPX_STR_RX_BCN1(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_RX_BCN1(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_rx_bcn2
 *
 * CPRI CONN4 IP Stream Router Reception BCN timer 2 value Register
 */
union cavm_cprix_cn4ipx_str_rx_bcn2
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_rx_bcn2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t n1_msb                : 32; /**< [ 31:  0](RO/H) Upper 32 bits  of BCN timer N1 value. */
#else /* Word 0 - Little Endian */
        uint32_t n1_msb                : 32; /**< [ 31:  0](RO/H) Upper 32 bits  of BCN timer N1 value. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_rx_bcn2_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_rx_bcn2 cavm_cprix_cn4ipx_str_rx_bcn2_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_RX_BCN2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_RX_BCN2(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000812010ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_RX_BCN2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_RX_BCN2(a,b) cavm_cprix_cn4ipx_str_rx_bcn2_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_RX_BCN2(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_RX_BCN2(a,b) "CPRIX_CN4IPX_STR_RX_BCN2"
#define busnum_CAVM_CPRIX_CN4IPX_STR_RX_BCN2(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_RX_BCN2(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_rx_lat
 *
 * CPRI CONN4 IP Stream Router Reception latency measurement control Register
 */
union cavm_cprix_cn4ipx_str_rx_lat
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_rx_lat_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_31           : 1;
        uint32_t meas_match            : 1;  /**< [ 30: 30](RO/H) RX Link received matching RP3 message.
                                                                   0 = BCN register values are invalid.
                                                                   1 = BCN register values are valid. */
        uint32_t meas_start            : 1;  /**< [ 29: 29](R/W/H) Start RX latency measurement.
                                                                   0 = no measurement in progress.
                                                                   1 = start measurement. */
        uint32_t reserved_26_28        : 3;
        uint32_t link_sel              : 2;  /**< [ 25: 24](R/W) RX Link to perform measurement.
                                                                 Valid values are 0 to 1. */
        uint32_t addr                  : 13; /**< [ 23: 11](R/W) RP3 Address to match for latency measurements. */
        uint32_t type_s                : 5;  /**< [ 10:  6](R/W) RP3 type to match for latency measurements. */
        uint32_t tstamp                : 6;  /**< [  5:  0](R/W) RP3 timestamp to match for latency measurements. */
#else /* Word 0 - Little Endian */
        uint32_t tstamp                : 6;  /**< [  5:  0](R/W) RP3 timestamp to match for latency measurements. */
        uint32_t type_s                : 5;  /**< [ 10:  6](R/W) RP3 type to match for latency measurements. */
        uint32_t addr                  : 13; /**< [ 23: 11](R/W) RP3 Address to match for latency measurements. */
        uint32_t link_sel              : 2;  /**< [ 25: 24](R/W) RX Link to perform measurement.
                                                                 Valid values are 0 to 1. */
        uint32_t reserved_26_28        : 3;
        uint32_t meas_start            : 1;  /**< [ 29: 29](R/W/H) Start RX latency measurement.
                                                                   0 = no measurement in progress.
                                                                   1 = start measurement. */
        uint32_t meas_match            : 1;  /**< [ 30: 30](RO/H) RX Link received matching RP3 message.
                                                                   0 = BCN register values are invalid.
                                                                   1 = BCN register values are valid. */
        uint32_t reserved_31           : 1;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_rx_lat_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_rx_lat cavm_cprix_cn4ipx_str_rx_lat_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_RX_LAT(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_RX_LAT(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000812008ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_RX_LAT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_RX_LAT(a,b) cavm_cprix_cn4ipx_str_rx_lat_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_RX_LAT(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_RX_LAT(a,b) "CPRIX_CN4IPX_STR_RX_LAT"
#define busnum_CAVM_CPRIX_CN4IPX_STR_RX_LAT(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_RX_LAT(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_tr_ctrl#
 *
 * CPRI CONN4 IP Stream Router Transmission Rule Control Register
 */
union cavm_cprix_cn4ipx_str_tr_ctrlx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_tr_ctrlx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t tstamp_start          : 6;  /**< [ 31: 26](R/W) User programmable initial timestamp value for this transmission rule if enabled. */
        uint32_t reserved_25           : 1;
        uint32_t stream_id             : 8;  /**< [ 24: 17](R/W) STREAM BUFFER ID to which transmission rule applies. */
        uint32_t j                     : 8;  /**< [ 16:  9](R/W) Virtual Channel to transmit message. Valid values are 0 to value in field X in
                                                                 the shared STR_DBM_BM register. */
        uint32_t reserved_6_8          : 3;
        uint32_t link                  : 2;  /**< [  5:  4](R/W) Destination RP3(-01) TX Link. */
        uint32_t use_dbm               : 1;  /**< [  3:  3](R/W) Enable TR to use DBM. */
        uint32_t reinit_ts             : 1;  /**< [  2:  2](R/W/H) Commands TR to re-initialize requested timestamp generation. */
        uint32_t use_tstamp_start      : 1;  /**< [  1:  1](R/W) Use user programmable TSTAMP_START.
                                                                   0 = use initial value from stream buffer.
                                                                   1 = use initial value from TSTAMP_START field. */
        uint32_t slot                  : 1;  /**< [  0:  0](R/W) RP3 frame message type selection for transmission rule.
                                                                   0 = RP3 frame data slots used.
                                                                   1 = RP3 frame control slots used. */
#else /* Word 0 - Little Endian */
        uint32_t slot                  : 1;  /**< [  0:  0](R/W) RP3 frame message type selection for transmission rule.
                                                                   0 = RP3 frame data slots used.
                                                                   1 = RP3 frame control slots used. */
        uint32_t use_tstamp_start      : 1;  /**< [  1:  1](R/W) Use user programmable TSTAMP_START.
                                                                   0 = use initial value from stream buffer.
                                                                   1 = use initial value from TSTAMP_START field. */
        uint32_t reinit_ts             : 1;  /**< [  2:  2](R/W/H) Commands TR to re-initialize requested timestamp generation. */
        uint32_t use_dbm               : 1;  /**< [  3:  3](R/W) Enable TR to use DBM. */
        uint32_t link                  : 2;  /**< [  5:  4](R/W) Destination RP3(-01) TX Link. */
        uint32_t reserved_6_8          : 3;
        uint32_t j                     : 8;  /**< [ 16:  9](R/W) Virtual Channel to transmit message. Valid values are 0 to value in field X in
                                                                 the shared STR_DBM_BM register. */
        uint32_t stream_id             : 8;  /**< [ 24: 17](R/W) STREAM BUFFER ID to which transmission rule applies. */
        uint32_t reserved_25           : 1;
        uint32_t tstamp_start          : 6;  /**< [ 31: 26](R/W) User programmable initial timestamp value for this transmission rule if enabled. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_tr_ctrlx_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_tr_ctrlx cavm_cprix_cn4ipx_str_tr_ctrlx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_TR_CTRLX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_TR_CTRLX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=191)))
        return 0x864000818000ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 8ll * ((c) & 0xff);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_TR_CTRLX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_TR_CTRLX(a,b,c) cavm_cprix_cn4ipx_str_tr_ctrlx_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_TR_CTRLX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_TR_CTRLX(a,b,c) "CPRIX_CN4IPX_STR_TR_CTRLX"
#define busnum_CAVM_CPRIX_CN4IPX_STR_TR_CTRLX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_TR_CTRLX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_tr_mi#
 *
 * CPRI CONN4 IP Stream Router Transmission Rule Modulo/Index Register
 */
union cavm_cprix_cn4ipx_str_tr_mix
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_tr_mix_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t modulo_i              : 16; /**< [ 31: 16](R/W) Modulo rule index value. */
        uint32_t modulo_m              : 16; /**< [ 15:  0](R/W) Modulo rule's modulo value.
                                                                      0x0 = rule is disabled.
                                                                      0x1 = Every slot used.
                                                                      0x2 = Every other slot used
                                                                      0x3 = Every third slot used

                                                                  0xFFFF  = Modulo 65535 used. */
#else /* Word 0 - Little Endian */
        uint32_t modulo_m              : 16; /**< [ 15:  0](R/W) Modulo rule's modulo value.
                                                                      0x0 = rule is disabled.
                                                                      0x1 = Every slot used.
                                                                      0x2 = Every other slot used
                                                                      0x3 = Every third slot used

                                                                  0xFFFF  = Modulo 65535 used. */
        uint32_t modulo_i              : 16; /**< [ 31: 16](R/W) Modulo rule index value. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_tr_mix_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_tr_mix cavm_cprix_cn4ipx_str_tr_mix_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_TR_MIX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_TR_MIX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=191)))
        return 0x864000818004ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 8ll * ((c) & 0xff);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_TR_MIX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_TR_MIX(a,b,c) cavm_cprix_cn4ipx_str_tr_mix_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_TR_MIX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_TR_MIX(a,b,c) "CPRIX_CN4IPX_STR_TR_MIX"
#define busnum_CAVM_CPRIX_CN4IPX_STR_TR_MIX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_TR_MIX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_ts_err
 *
 * CPRI CONN4 IP Timestamp Error Register
 */
union cavm_cprix_cn4ipx_str_ts_err
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_ts_err_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_26_31        : 6;
        uint32_t ts_link               : 2;  /**< [ 25: 24](RO/H) Link number 0 or 1. */
        uint32_t ts_req                : 6;  /**< [ 23: 18](RO/H) Requested Timestamp. */
        uint32_t ts_buf                : 6;  /**< [ 17: 12](RO/H) Timestamp in buffer when error occurred. */
        uint32_t reserved_8_11         : 4;
        uint32_t stream_id             : 8;  /**< [  7:  0](R/W) Stream buffer id where timestamp error is monitored. */
#else /* Word 0 - Little Endian */
        uint32_t stream_id             : 8;  /**< [  7:  0](R/W) Stream buffer id where timestamp error is monitored. */
        uint32_t reserved_8_11         : 4;
        uint32_t ts_buf                : 6;  /**< [ 17: 12](RO/H) Timestamp in buffer when error occurred. */
        uint32_t ts_req                : 6;  /**< [ 23: 18](RO/H) Requested Timestamp. */
        uint32_t ts_link               : 2;  /**< [ 25: 24](RO/H) Link number 0 or 1. */
        uint32_t reserved_26_31        : 6;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_ts_err_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_ts_err cavm_cprix_cn4ipx_str_ts_err_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_TS_ERR(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_TS_ERR(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000812004ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_TS_ERR", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_TS_ERR(a,b) cavm_cprix_cn4ipx_str_ts_err_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_TS_ERR(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_TS_ERR(a,b) "CPRIX_CN4IPX_STR_TS_ERR"
#define busnum_CAVM_CPRIX_CN4IPX_STR_TS_ERR(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_TS_ERR(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_tx_bcn1
 *
 * CPRI CONN4 IP Stream Router Transmission BCN timer 1 value Register
 */
union cavm_cprix_cn4ipx_str_tx_bcn1
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_tx_bcn1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t n1_lsb                : 8;  /**< [ 31: 24](RO/H) BCN timer N1 LSb value. */
        uint32_t n2                    : 24; /**< [ 23:  0](RO/H) BCN timer N2 value. 2 LSbs are always 0. */
#else /* Word 0 - Little Endian */
        uint32_t n2                    : 24; /**< [ 23:  0](RO/H) BCN timer N2 value. 2 LSbs are always 0. */
        uint32_t n1_lsb                : 8;  /**< [ 31: 24](RO/H) BCN timer N1 LSb value. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_tx_bcn1_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_tx_bcn1 cavm_cprix_cn4ipx_str_tx_bcn1_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_TX_BCN1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_TX_BCN1(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000812018ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_TX_BCN1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_TX_BCN1(a,b) cavm_cprix_cn4ipx_str_tx_bcn1_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_TX_BCN1(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_TX_BCN1(a,b) "CPRIX_CN4IPX_STR_TX_BCN1"
#define busnum_CAVM_CPRIX_CN4IPX_STR_TX_BCN1(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_TX_BCN1(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_tx_bcn2
 *
 * CPRI CONN4 IP Stream Router Transmission BCN timer 2 value Register
 */
union cavm_cprix_cn4ipx_str_tx_bcn2
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_tx_bcn2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t n1_msb                : 32; /**< [ 31:  0](RO/H) Upper 32 bits  of BCN timer N1 value. */
#else /* Word 0 - Little Endian */
        uint32_t n1_msb                : 32; /**< [ 31:  0](RO/H) Upper 32 bits  of BCN timer N1 value. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_tx_bcn2_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_tx_bcn2 cavm_cprix_cn4ipx_str_tx_bcn2_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_TX_BCN2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_TX_BCN2(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400081201cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_TX_BCN2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_TX_BCN2(a,b) cavm_cprix_cn4ipx_str_tx_bcn2_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_TX_BCN2(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_TX_BCN2(a,b) "CPRIX_CN4IPX_STR_TX_BCN2"
#define busnum_CAVM_CPRIX_CN4IPX_STR_TX_BCN2(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_TX_BCN2(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_str_tx_lat
 *
 * CPRI CONN4 IP Stream Router Transmission latency measurement control Register
 */
union cavm_cprix_cn4ipx_str_tx_lat
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_str_tx_lat_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t rx_trig               : 1;  /**< [ 31: 31](R/W) Gate start of TX latency measurement with STR_RX_LAT's MEAS_MATCH=1.
                                                                   0 = ignore STR_RX_LAT's MEAS_MATCH.
                                                                   1 = wait until STR_RX_LAT's MEAS_MATCH=1 to start measurement. */
        uint32_t meas_match            : 1;  /**< [ 30: 30](RO/H) TX Link detected matching RP3 message.
                                                                   0 = BCN register values are invalid.
                                                                   1 = BCN register values are valid. */
        uint32_t meas_start            : 1;  /**< [ 29: 29](R/W/H) Start TX latency measurement.
                                                                   0 = no measurement in progress.
                                                                   1 = start measurement. */
        uint32_t reserved_26_28        : 3;
        uint32_t link_sel              : 2;  /**< [ 25: 24](R/W) TX Link to perform measurement.
                                                                 Valid values are 0 to 1. */
        uint32_t addr                  : 13; /**< [ 23: 11](R/W) RP3 Address to match for latency measurements. */
        uint32_t type_s                : 5;  /**< [ 10:  6](R/W) RP3 type to match for latency measurements. */
        uint32_t tstamp                : 6;  /**< [  5:  0](R/W) RP3 timestamp to match for latency measurements. */
#else /* Word 0 - Little Endian */
        uint32_t tstamp                : 6;  /**< [  5:  0](R/W) RP3 timestamp to match for latency measurements. */
        uint32_t type_s                : 5;  /**< [ 10:  6](R/W) RP3 type to match for latency measurements. */
        uint32_t addr                  : 13; /**< [ 23: 11](R/W) RP3 Address to match for latency measurements. */
        uint32_t link_sel              : 2;  /**< [ 25: 24](R/W) TX Link to perform measurement.
                                                                 Valid values are 0 to 1. */
        uint32_t reserved_26_28        : 3;
        uint32_t meas_start            : 1;  /**< [ 29: 29](R/W/H) Start TX latency measurement.
                                                                   0 = no measurement in progress.
                                                                   1 = start measurement. */
        uint32_t meas_match            : 1;  /**< [ 30: 30](RO/H) TX Link detected matching RP3 message.
                                                                   0 = BCN register values are invalid.
                                                                   1 = BCN register values are valid. */
        uint32_t rx_trig               : 1;  /**< [ 31: 31](R/W) Gate start of TX latency measurement with STR_RX_LAT's MEAS_MATCH=1.
                                                                   0 = ignore STR_RX_LAT's MEAS_MATCH.
                                                                   1 = wait until STR_RX_LAT's MEAS_MATCH=1 to start measurement. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_str_tx_lat_s cn; */
};
typedef union cavm_cprix_cn4ipx_str_tx_lat cavm_cprix_cn4ipx_str_tx_lat_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_STR_TX_LAT(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_STR_TX_LAT(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000812014ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_STR_TX_LAT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_STR_TX_LAT(a,b) cavm_cprix_cn4ipx_str_tx_lat_t
#define bustype_CAVM_CPRIX_CN4IPX_STR_TX_LAT(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_STR_TX_LAT(a,b) "CPRIX_CN4IPX_STR_TX_LAT"
#define busnum_CAVM_CPRIX_CN4IPX_STR_TX_LAT(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_STR_TX_LAT(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_sum_type_ln#
 *
 * CPRI CONN4 IP Summing Types Register
 */
union cavm_cprix_cn4ipx_sum_type_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_sum_type_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t summing_allowed_for_type : 32;/**< [ 31:  0](R/W) Allow summing for given type.
                                                                 Each bit maps to one of the possible RP3 types as specified in Error! Reference source not found.
                                                                   0 = Summing not allowed.
                                                                   1 = Summing allowed. */
#else /* Word 0 - Little Endian */
        uint32_t summing_allowed_for_type : 32;/**< [ 31:  0](R/W) Allow summing for given type.
                                                                 Each bit maps to one of the possible RP3 types as specified in Error! Reference source not found.
                                                                   0 = Summing not allowed.
                                                                   1 = Summing allowed. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_sum_type_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_sum_type_lnx cavm_cprix_cn4ipx_sum_type_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_SUM_TYPE_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_SUM_TYPE_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x8640008080a0ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_SUM_TYPE_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_SUM_TYPE_LNX(a,b,c) cavm_cprix_cn4ipx_sum_type_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_SUM_TYPE_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_SUM_TYPE_LNX(a,b,c) "CPRIX_CN4IPX_SUM_TYPE_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_SUM_TYPE_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_SUM_TYPE_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_testm_ctrl
 *
 * CPRI CONN4 IP TESTMODE CONTROL Register
 */
union cavm_cprix_cn4ipx_testm_ctrl
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_testm_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t test_n_mg_64          : 1;  /**< [  2:  2](R/W) Shorten the master frame for simulation speedup.
                                                                   0 = Normal operation.
                                                                   1 = N_MG parameter is set to 64 and the master frame shortened accordingly. */
        uint32_t test_scr_dis          : 1;  /**< [  1:  1](R/W) Disable descrambling and IDLE state transitions from 8x speed RX links (operate like lower speeds):
                                                                   0 = Normal operation.
                                                                   1 = Disable descrambling. */
        uint32_t test_n_mg_16          : 1;  /**< [  0:  0](R/W) Shorten the master frame for simulation speedup.
                                                                   0 = Normal operation.
                                                                   1 = N_MG parameter is set to 16 and the master frame shortened accordingly. */
#else /* Word 0 - Little Endian */
        uint32_t test_n_mg_16          : 1;  /**< [  0:  0](R/W) Shorten the master frame for simulation speedup.
                                                                   0 = Normal operation.
                                                                   1 = N_MG parameter is set to 16 and the master frame shortened accordingly. */
        uint32_t test_scr_dis          : 1;  /**< [  1:  1](R/W) Disable descrambling and IDLE state transitions from 8x speed RX links (operate like lower speeds):
                                                                   0 = Normal operation.
                                                                   1 = Disable descrambling. */
        uint32_t test_n_mg_64          : 1;  /**< [  2:  2](R/W) Shorten the master frame for simulation speedup.
                                                                   0 = Normal operation.
                                                                   1 = N_MG parameter is set to 64 and the master frame shortened accordingly. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_testm_ctrl_s cn; */
};
typedef union cavm_cprix_cn4ipx_testm_ctrl cavm_cprix_cn4ipx_testm_ctrl_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_TESTM_CTRL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_TESTM_CTRL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080103cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_TESTM_CTRL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_TESTM_CTRL(a,b) cavm_cprix_cn4ipx_testm_ctrl_t
#define bustype_CAVM_CPRIX_CN4IPX_TESTM_CTRL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_TESTM_CTRL(a,b) "CPRIX_CN4IPX_TESTM_CTRL"
#define busnum_CAVM_CPRIX_CN4IPX_TESTM_CTRL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_TESTM_CTRL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_timer_ctrl
 *
 * CPRI CONN4 IP Timer Synchronization Control Register
 */
union cavm_cprix_cn4ipx_timer_ctrl
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_timer_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t link_sel              : 2;  /**< [  5:  4](R/W) Synchronization link select for CPRI:
                                                                   0x0 = link 0.
                                                                   0x1 = link 1.
                                                                   0x2 = link 2.
                                                                   0x3 = not used. */
        uint32_t reserved_3            : 1;
        uint32_t sync_src              : 2;  /**< [  2:  1](R/W) Synchronization source select:
                                                                   0 = Select and start free running mode.
                                                                   1 = RP1 burst.
                                                                   2 = FCB message.
                                                                   3 = CPRI. */
        uint32_t rp1_burst_en          : 1;  /**< [  0:  0](R/W) RP1 synchronization burst receive enable.
                                                                   0 = disabled.
                                                                   1 = enabled. */
#else /* Word 0 - Little Endian */
        uint32_t rp1_burst_en          : 1;  /**< [  0:  0](R/W) RP1 synchronization burst receive enable.
                                                                   0 = disabled.
                                                                   1 = enabled. */
        uint32_t sync_src              : 2;  /**< [  2:  1](R/W) Synchronization source select:
                                                                   0 = Select and start free running mode.
                                                                   1 = RP1 burst.
                                                                   2 = FCB message.
                                                                   3 = CPRI. */
        uint32_t reserved_3            : 1;
        uint32_t link_sel              : 2;  /**< [  5:  4](R/W) Synchronization link select for CPRI:
                                                                   0x0 = link 0.
                                                                   0x1 = link 1.
                                                                   0x2 = link 2.
                                                                   0x3 = not used. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_timer_ctrl_s cn; */
};
typedef union cavm_cprix_cn4ipx_timer_ctrl cavm_cprix_cn4ipx_timer_ctrl_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_TIMER_CTRL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_TIMER_CTRL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f000ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_TIMER_CTRL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_TIMER_CTRL(a,b) cavm_cprix_cn4ipx_timer_ctrl_t
#define bustype_CAVM_CPRIX_CN4IPX_TIMER_CTRL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_TIMER_CTRL(a,b) "CPRIX_CN4IPX_TIMER_CTRL"
#define busnum_CAVM_CPRIX_CN4IPX_TIMER_CTRL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_TIMER_CTRL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_trace_ctrl
 *
 * CPRI CONN4 IP TRACE CTRL Register
 */
union cavm_cprix_cn4ipx_trace_ctrl
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_trace_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t scratch               : 3;  /**< [ 14: 12](R/W) Scratch. */
        uint32_t reserved_9_11         : 3;
        uint32_t trace_ena             : 1;  /**< [  8:  8](R/W) Enabling of RP3-01 data trace:
                                                                   0 = trace disabled.
                                                                   1 = trace enabled. */
        uint32_t reserved_7            : 1;
        uint32_t source_sel            : 2;  /**< [  6:  5](R/W) Selection of trace data source from selected link:
                                                                   00 = RP3-01 RX link input data.
                                                                   01 = RP3-01 RX link input data before descrambling.
                                                                   10 = RP3-01 TX link output data.
                                                                   11 = RP3-01 TX link output data before scrambling. */
        uint32_t reserved_1_4          : 4;
        uint32_t link_sel              : 1;  /**< [  0:  0](R/W) Link selection of trace data source:
                                                                   0 = RP3-01 link 0.
                                                                   1 = RP3-01 link 1. */
#else /* Word 0 - Little Endian */
        uint32_t link_sel              : 1;  /**< [  0:  0](R/W) Link selection of trace data source:
                                                                   0 = RP3-01 link 0.
                                                                   1 = RP3-01 link 1. */
        uint32_t reserved_1_4          : 4;
        uint32_t source_sel            : 2;  /**< [  6:  5](R/W) Selection of trace data source from selected link:
                                                                   00 = RP3-01 RX link input data.
                                                                   01 = RP3-01 RX link input data before descrambling.
                                                                   10 = RP3-01 TX link output data.
                                                                   11 = RP3-01 TX link output data before scrambling. */
        uint32_t reserved_7            : 1;
        uint32_t trace_ena             : 1;  /**< [  8:  8](R/W) Enabling of RP3-01 data trace:
                                                                   0 = trace disabled.
                                                                   1 = trace enabled. */
        uint32_t reserved_9_11         : 3;
        uint32_t scratch               : 3;  /**< [ 14: 12](R/W) Scratch. */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_trace_ctrl_s cn; */
};
typedef union cavm_cprix_cn4ipx_trace_ctrl cavm_cprix_cn4ipx_trace_ctrl_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_TRACE_CTRL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_TRACE_CTRL(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000801004ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_TRACE_CTRL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_TRACE_CTRL(a,b) cavm_cprix_cn4ipx_trace_ctrl_t
#define bustype_CAVM_CPRIX_CN4IPX_TRACE_CTRL(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_TRACE_CTRL(a,b) "CPRIX_CN4IPX_TRACE_CTRL"
#define busnum_CAVM_CPRIX_CN4IPX_TRACE_CTRL(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_TRACE_CTRL(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_tx_ber_acen_ln#
 *
 * CPRI CONN4 IP Functional BER TX Antenna Carrier Enable Register
 */
union cavm_cprix_cn4ipx_tx_ber_acen_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_tx_ber_acen_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t tx_carr_en31          : 1;  /**< [ 31: 31](R/W) Enable Functional BER generation for Antenna Carrier 31.
                                                                   0 = BER generation disabled.
                                                                   1 = BER generation enabled. */
        uint32_t tx_carr_en30          : 1;  /**< [ 30: 30](R/W) Enable Functional BER generation for Antenna Carrier 30. */
        uint32_t tx_carr_en29          : 1;  /**< [ 29: 29](R/W) Enable Functional BER generation for Antenna Carrier 29. */
        uint32_t tx_carr_en28          : 1;  /**< [ 28: 28](R/W) Enable Functional BER generation for Antenna Carrier 28. */
        uint32_t tx_carr_en27          : 1;  /**< [ 27: 27](R/W) Enable Functional BER generation for Antenna Carrier 27. */
        uint32_t tx_carr_en26          : 1;  /**< [ 26: 26](R/W) Enable Functional BER generation for Antenna Carrier 26. */
        uint32_t tx_carr_en25          : 1;  /**< [ 25: 25](R/W) Enable Functional BER generation for Antenna Carrier 25. */
        uint32_t tx_carr_en24          : 1;  /**< [ 24: 24](R/W) Enable Functional BER generation for Antenna Carrier 24. */
        uint32_t tx_carr_en23          : 1;  /**< [ 23: 23](R/W) Enable Functional BER generation for Antenna Carrier 23. */
        uint32_t tx_carr_en22          : 1;  /**< [ 22: 22](R/W) Enable Functional BER generation for Antenna Carrier 22. */
        uint32_t tx_carr_en21          : 1;  /**< [ 21: 21](R/W) Enable Functional BER generation for Antenna Carrier 21. */
        uint32_t tx_carr_en20          : 1;  /**< [ 20: 20](R/W) Enable Functional BER generation for Antenna Carrier 20. */
        uint32_t tx_carr_en19          : 1;  /**< [ 19: 19](R/W) Enable Functional BER generation for Antenna Carrier 19. */
        uint32_t tx_carr_en18          : 1;  /**< [ 18: 18](R/W) Enable Functional BER generation for Antenna Carrier 18. */
        uint32_t tx_carr_en17          : 1;  /**< [ 17: 17](R/W) Enable Functional BER generation for Antenna Carrier 17. */
        uint32_t tx_carr_en16          : 1;  /**< [ 16: 16](R/W) Enable Functional BER generation for Antenna Carrier 16. */
        uint32_t tx_carr_en15          : 1;  /**< [ 15: 15](R/W) Enable Functional BER generation for Antenna Carrier 15. */
        uint32_t tx_carr_en14          : 1;  /**< [ 14: 14](R/W) Enable Functional BER generation for Antenna Carrier 14. */
        uint32_t tx_carr_en13          : 1;  /**< [ 13: 13](R/W) Enable Functional BER generation for Antenna Carrier 13. */
        uint32_t tx_carr_en12          : 1;  /**< [ 12: 12](R/W) Enable Functional BER generation for Antenna Carrier 12. */
        uint32_t tx_carr_en11          : 1;  /**< [ 11: 11](R/W) Enable Functional BER generation for Antenna Carrier 11. */
        uint32_t tx_carr_en10          : 1;  /**< [ 10: 10](R/W) Enable Functional BER generation for Antenna Carrier 10. */
        uint32_t tx_carr_en9           : 1;  /**< [  9:  9](R/W) Enable Functional BER generation for Antenna Carrier 9. */
        uint32_t tx_carr_en8           : 1;  /**< [  8:  8](R/W) Enable Functional BER generation for Antenna Carrier 8. */
        uint32_t tx_carr_en7           : 1;  /**< [  7:  7](R/W) Enable Functional BER generation for Antenna Carrier 7. */
        uint32_t tx_carr_en6           : 1;  /**< [  6:  6](R/W) Enable Functional BER generation for Antenna Carrier 6. */
        uint32_t tx_carr_en5           : 1;  /**< [  5:  5](R/W) Enable Functional BER generation for Antenna Carrier 5. */
        uint32_t tx_carr_en4           : 1;  /**< [  4:  4](R/W) Enable Functional BER generation for Antenna Carrier 4. */
        uint32_t tx_carr_en3           : 1;  /**< [  3:  3](R/W) Enable Functional BER generation for Antenna Carrier 3. */
        uint32_t tx_carr_en2           : 1;  /**< [  2:  2](R/W) Enable Functional BER generation for Antenna Carrier 2. */
        uint32_t tx_carr_en1           : 1;  /**< [  1:  1](R/W) Enable Functional BER generation for Antenna Carrier 1. */
        uint32_t tx_carr_en0           : 1;  /**< [  0:  0](R/W) Enable Functional BER generation for Antenna Carrier 0. */
#else /* Word 0 - Little Endian */
        uint32_t tx_carr_en0           : 1;  /**< [  0:  0](R/W) Enable Functional BER generation for Antenna Carrier 0. */
        uint32_t tx_carr_en1           : 1;  /**< [  1:  1](R/W) Enable Functional BER generation for Antenna Carrier 1. */
        uint32_t tx_carr_en2           : 1;  /**< [  2:  2](R/W) Enable Functional BER generation for Antenna Carrier 2. */
        uint32_t tx_carr_en3           : 1;  /**< [  3:  3](R/W) Enable Functional BER generation for Antenna Carrier 3. */
        uint32_t tx_carr_en4           : 1;  /**< [  4:  4](R/W) Enable Functional BER generation for Antenna Carrier 4. */
        uint32_t tx_carr_en5           : 1;  /**< [  5:  5](R/W) Enable Functional BER generation for Antenna Carrier 5. */
        uint32_t tx_carr_en6           : 1;  /**< [  6:  6](R/W) Enable Functional BER generation for Antenna Carrier 6. */
        uint32_t tx_carr_en7           : 1;  /**< [  7:  7](R/W) Enable Functional BER generation for Antenna Carrier 7. */
        uint32_t tx_carr_en8           : 1;  /**< [  8:  8](R/W) Enable Functional BER generation for Antenna Carrier 8. */
        uint32_t tx_carr_en9           : 1;  /**< [  9:  9](R/W) Enable Functional BER generation for Antenna Carrier 9. */
        uint32_t tx_carr_en10          : 1;  /**< [ 10: 10](R/W) Enable Functional BER generation for Antenna Carrier 10. */
        uint32_t tx_carr_en11          : 1;  /**< [ 11: 11](R/W) Enable Functional BER generation for Antenna Carrier 11. */
        uint32_t tx_carr_en12          : 1;  /**< [ 12: 12](R/W) Enable Functional BER generation for Antenna Carrier 12. */
        uint32_t tx_carr_en13          : 1;  /**< [ 13: 13](R/W) Enable Functional BER generation for Antenna Carrier 13. */
        uint32_t tx_carr_en14          : 1;  /**< [ 14: 14](R/W) Enable Functional BER generation for Antenna Carrier 14. */
        uint32_t tx_carr_en15          : 1;  /**< [ 15: 15](R/W) Enable Functional BER generation for Antenna Carrier 15. */
        uint32_t tx_carr_en16          : 1;  /**< [ 16: 16](R/W) Enable Functional BER generation for Antenna Carrier 16. */
        uint32_t tx_carr_en17          : 1;  /**< [ 17: 17](R/W) Enable Functional BER generation for Antenna Carrier 17. */
        uint32_t tx_carr_en18          : 1;  /**< [ 18: 18](R/W) Enable Functional BER generation for Antenna Carrier 18. */
        uint32_t tx_carr_en19          : 1;  /**< [ 19: 19](R/W) Enable Functional BER generation for Antenna Carrier 19. */
        uint32_t tx_carr_en20          : 1;  /**< [ 20: 20](R/W) Enable Functional BER generation for Antenna Carrier 20. */
        uint32_t tx_carr_en21          : 1;  /**< [ 21: 21](R/W) Enable Functional BER generation for Antenna Carrier 21. */
        uint32_t tx_carr_en22          : 1;  /**< [ 22: 22](R/W) Enable Functional BER generation for Antenna Carrier 22. */
        uint32_t tx_carr_en23          : 1;  /**< [ 23: 23](R/W) Enable Functional BER generation for Antenna Carrier 23. */
        uint32_t tx_carr_en24          : 1;  /**< [ 24: 24](R/W) Enable Functional BER generation for Antenna Carrier 24. */
        uint32_t tx_carr_en25          : 1;  /**< [ 25: 25](R/W) Enable Functional BER generation for Antenna Carrier 25. */
        uint32_t tx_carr_en26          : 1;  /**< [ 26: 26](R/W) Enable Functional BER generation for Antenna Carrier 26. */
        uint32_t tx_carr_en27          : 1;  /**< [ 27: 27](R/W) Enable Functional BER generation for Antenna Carrier 27. */
        uint32_t tx_carr_en28          : 1;  /**< [ 28: 28](R/W) Enable Functional BER generation for Antenna Carrier 28. */
        uint32_t tx_carr_en29          : 1;  /**< [ 29: 29](R/W) Enable Functional BER generation for Antenna Carrier 29. */
        uint32_t tx_carr_en30          : 1;  /**< [ 30: 30](R/W) Enable Functional BER generation for Antenna Carrier 30. */
        uint32_t tx_carr_en31          : 1;  /**< [ 31: 31](R/W) Enable Functional BER generation for Antenna Carrier 31.
                                                                   0 = BER generation disabled.
                                                                   1 = BER generation enabled. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_tx_ber_acen_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_tx_ber_acen_lnx cavm_cprix_cn4ipx_tx_ber_acen_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_TX_BER_ACEN_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_TX_BER_ACEN_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000808160ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_TX_BER_ACEN_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_TX_BER_ACEN_LNX(a,b,c) cavm_cprix_cn4ipx_tx_ber_acen_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_TX_BER_ACEN_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_TX_BER_ACEN_LNX(a,b,c) "CPRIX_CN4IPX_TX_BER_ACEN_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_TX_BER_ACEN_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_TX_BER_ACEN_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_tx_ber_cten_ln#
 *
 * CPRI CONN4 IP Functional BER TX Control Slot Enable Register
 */
union cavm_cprix_cn4ipx_tx_ber_cten_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_tx_ber_cten_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tx_ctrl_en7           : 1;  /**< [  7:  7](R/W) Enable Functional BER generation for Control Slot 7.
                                                                   0 = BER generation disabled.
                                                                   1 = BER generation enabled. */
        uint32_t tx_ctrl_en6           : 1;  /**< [  6:  6](R/W) Enable Functional BER generation for Control Slot 6. */
        uint32_t tx_ctrl_en5           : 1;  /**< [  5:  5](R/W) Enable Functional BER generation for Control Slot 5. */
        uint32_t tx_ctrl_en4           : 1;  /**< [  4:  4](R/W) Enable Functional BER generation for Control Slot 4. */
        uint32_t tx_ctrl_en3           : 1;  /**< [  3:  3](R/W) Enable Functional BER generation for Control Slot 3. */
        uint32_t tx_ctrl_en2           : 1;  /**< [  2:  2](R/W) Enable Functional BER generation for Control Slot 2. */
        uint32_t tx_ctrl_en1           : 1;  /**< [  1:  1](R/W) Enable Functional BER generation for Control Slot 1. */
        uint32_t tx_ctrl_en0           : 1;  /**< [  0:  0](R/W) Enable Functional BER generation for Control Slot 0. */
#else /* Word 0 - Little Endian */
        uint32_t tx_ctrl_en0           : 1;  /**< [  0:  0](R/W) Enable Functional BER generation for Control Slot 0. */
        uint32_t tx_ctrl_en1           : 1;  /**< [  1:  1](R/W) Enable Functional BER generation for Control Slot 1. */
        uint32_t tx_ctrl_en2           : 1;  /**< [  2:  2](R/W) Enable Functional BER generation for Control Slot 2. */
        uint32_t tx_ctrl_en3           : 1;  /**< [  3:  3](R/W) Enable Functional BER generation for Control Slot 3. */
        uint32_t tx_ctrl_en4           : 1;  /**< [  4:  4](R/W) Enable Functional BER generation for Control Slot 4. */
        uint32_t tx_ctrl_en5           : 1;  /**< [  5:  5](R/W) Enable Functional BER generation for Control Slot 5. */
        uint32_t tx_ctrl_en6           : 1;  /**< [  6:  6](R/W) Enable Functional BER generation for Control Slot 6. */
        uint32_t tx_ctrl_en7           : 1;  /**< [  7:  7](R/W) Enable Functional BER generation for Control Slot 7.
                                                                   0 = BER generation disabled.
                                                                   1 = BER generation enabled. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_tx_ber_cten_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_tx_ber_cten_lnx cavm_cprix_cn4ipx_tx_ber_cten_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_TX_BER_CTEN_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_TX_BER_CTEN_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000808164ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_TX_BER_CTEN_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_TX_BER_CTEN_LNX(a,b,c) cavm_cprix_cn4ipx_tx_ber_cten_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_TX_BER_CTEN_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_TX_BER_CTEN_LNX(a,b,c) "CPRIX_CN4IPX_TX_BER_CTEN_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_TX_BER_CTEN_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_TX_BER_CTEN_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_tx_ctrl_tr_ln#
 *
 * CPRI CONN4 IP TX Control Message Transmission Rule Register
 */
union cavm_cprix_cn4ipx_tx_ctrl_tr_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_tx_ctrl_tr_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t i                     : 16; /**< [ 31: 16](R/W) Index. */
        uint32_t m                     : 16; /**< [ 15:  0](R/W) Modulo. */
#else /* Word 0 - Little Endian */
        uint32_t m                     : 16; /**< [ 15:  0](R/W) Modulo. */
        uint32_t i                     : 16; /**< [ 31: 16](R/W) Index. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_tx_ctrl_tr_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_tx_ctrl_tr_lnx cavm_cprix_cn4ipx_tx_ctrl_tr_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_TX_CTRL_TR_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_TX_CTRL_TR_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000808090ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_TX_CTRL_TR_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_TX_CTRL_TR_LNX(a,b,c) cavm_cprix_cn4ipx_tx_ctrl_tr_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_TX_CTRL_TR_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_TX_CTRL_TR_LNX(a,b,c) "CPRIX_CN4IPX_TX_CTRL_TR_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_TX_CTRL_TR_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_TX_CTRL_TR_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_tx_eth_tr_ln#
 *
 * CPRI CONN4 IP TX Ethernet Message Transmission Rule Register
 */
union cavm_cprix_cn4ipx_tx_eth_tr_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_tx_eth_tr_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t i                     : 16; /**< [ 31: 16](R/W) Index. */
        uint32_t m                     : 16; /**< [ 15:  0](R/W) Modulo.
                                                                 Modulo 0 disables the rule. */
#else /* Word 0 - Little Endian */
        uint32_t m                     : 16; /**< [ 15:  0](R/W) Modulo.
                                                                 Modulo 0 disables the rule. */
        uint32_t i                     : 16; /**< [ 31: 16](R/W) Index. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_tx_eth_tr_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_tx_eth_tr_lnx cavm_cprix_cn4ipx_tx_eth_tr_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_TX_ETH_TR_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_TX_ETH_TR_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x86400080808cll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_TX_ETH_TR_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_TX_ETH_TR_LNX(a,b,c) cavm_cprix_cn4ipx_tx_eth_tr_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_TX_ETH_TR_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_TX_ETH_TR_LNX(a,b,c) "CPRIX_CN4IPX_TX_ETH_TR_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_TX_ETH_TR_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_TX_ETH_TR_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_tx_eth_tr_sel_ln#
 *
 * CPRI CONN4 IP TX Ethernet Message Transmission Rule Select Register
 */
union cavm_cprix_cn4ipx_tx_eth_tr_sel_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_tx_eth_tr_sel_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t eth_tr_sel            : 1;  /**< [  0:  0](R/W) Select the message slot counter that is used for Ethernet message transmission.
                                                                   0 = Data message slot.
                                                                   1 = Control message slot. */
#else /* Word 0 - Little Endian */
        uint32_t eth_tr_sel            : 1;  /**< [  0:  0](R/W) Select the message slot counter that is used for Ethernet message transmission.
                                                                   0 = Data message slot.
                                                                   1 = Control message slot. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_tx_eth_tr_sel_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_tx_eth_tr_sel_lnx cavm_cprix_cn4ipx_tx_eth_tr_sel_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_TX_ETH_TR_SEL_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_TX_ETH_TR_SEL_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000808088ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_TX_ETH_TR_SEL_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_TX_ETH_TR_SEL_LNX(a,b,c) cavm_cprix_cn4ipx_tx_eth_tr_sel_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_TX_ETH_TR_SEL_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_TX_ETH_TR_SEL_LNX(a,b,c) "CPRIX_CN4IPX_TX_ETH_TR_SEL_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_TX_ETH_TR_SEL_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_TX_ETH_TR_SEL_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_tx_fifo_ctl_ln#
 *
 * CPRI CONN4 IP TX Fifo Control Register
 */
union cavm_cprix_cn4ipx_tx_fifo_ctl_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_tx_fifo_ctl_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t clear                 : 1;  /**< [  0:  0](R/W) Synchronously clear TX FIFO control logic.
                                                                     0 = disabled.
                                                                     1 = clear. */
#else /* Word 0 - Little Endian */
        uint32_t clear                 : 1;  /**< [  0:  0](R/W) Synchronously clear TX FIFO control logic.
                                                                     0 = disabled.
                                                                     1 = clear. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_tx_fifo_ctl_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_tx_fifo_ctl_lnx cavm_cprix_cn4ipx_tx_fifo_ctl_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_TX_FIFO_CTL_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_TX_FIFO_CTL_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000808084ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_TX_FIFO_CTL_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_TX_FIFO_CTL_LNX(a,b,c) cavm_cprix_cn4ipx_tx_fifo_ctl_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_TX_FIFO_CTL_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_TX_FIFO_CTL_LNX(a,b,c) "CPRIX_CN4IPX_TX_FIFO_CTL_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_TX_FIFO_CTL_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_TX_FIFO_CTL_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_tx_offset_ln#
 *
 * CPRI CONN4 IP TX Link Timing Parameter TX_OFFSET Register
 */
union cavm_cprix_cn4ipx_tx_offset_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_tx_offset_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t tx_rx_offset          : 7;  /**< [  6:  0](R/W) Offset from TX_RX_OFFSET to reading TX data in 307.2 MHz clock periods. */
#else /* Word 0 - Little Endian */
        uint32_t tx_rx_offset          : 7;  /**< [  6:  0](R/W) Offset from TX_RX_OFFSET to reading TX data in 307.2 MHz clock periods. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_tx_offset_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_tx_offset_lnx cavm_cprix_cn4ipx_tx_offset_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_TX_OFFSET_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_TX_OFFSET_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000808078ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_TX_OFFSET_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_TX_OFFSET_LNX(a,b,c) cavm_cprix_cn4ipx_tx_offset_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_TX_OFFSET_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_TX_OFFSET_LNX(a,b,c) "CPRIX_CN4IPX_TX_OFFSET_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_TX_OFFSET_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_TX_OFFSET_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_tx_pi_ln#
 *
 * CPRI CONN4 IP TX Link Timing Parameter PI Register
 */
union cavm_cprix_cn4ipx_tx_pi_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_tx_pi_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t sign                  : 9;  /**< [ 31: 23](RO/H) These bits show the value of the sign bit (22) when read. Write to these bits has no effect. */
        uint32_t pi                    : 23; /**< [ 22:  0](R/W) Offset from BCN N2 wrap-around point to TX_FCLK_PI in 307.2 MHz clock periods.
                                                                 The value is represented as a signed, two's complement value. Bit 22 is a sign bit. */
#else /* Word 0 - Little Endian */
        uint32_t pi                    : 23; /**< [ 22:  0](R/W) Offset from BCN N2 wrap-around point to TX_FCLK_PI in 307.2 MHz clock periods.
                                                                 The value is represented as a signed, two's complement value. Bit 22 is a sign bit. */
        uint32_t sign                  : 9;  /**< [ 31: 23](RO/H) These bits show the value of the sign bit (22) when read. Write to these bits has no effect. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_tx_pi_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_tx_pi_lnx cavm_cprix_cn4ipx_tx_pi_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_TX_PI_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_TX_PI_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000808070ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_TX_PI_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_TX_PI_LNX(a,b,c) cavm_cprix_cn4ipx_tx_pi_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_TX_PI_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_TX_PI_LNX(a,b,c) "CPRIX_CN4IPX_TX_PI_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_TX_PI_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_TX_PI_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_tx_rx_offset_ln#
 *
 * CPRI CONN4 IP TX Link Timing Parameter TX_RX_OFFSET Register
 */
union cavm_cprix_cn4ipx_tx_rx_offset_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_tx_rx_offset_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tx_rx_offset          : 8;  /**< [  7:  0](R/W) Offset from TX_FCLK_PI to receiving RX data in 307.2 MHz clock periods. */
#else /* Word 0 - Little Endian */
        uint32_t tx_rx_offset          : 8;  /**< [  7:  0](R/W) Offset from TX_FCLK_PI to receiving RX data in 307.2 MHz clock periods. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_tx_rx_offset_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_tx_rx_offset_lnx cavm_cprix_cn4ipx_tx_rx_offset_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_TX_RX_OFFSET_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_TX_RX_OFFSET_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000808074ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_TX_RX_OFFSET_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_TX_RX_OFFSET_LNX(a,b,c) cavm_cprix_cn4ipx_tx_rx_offset_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_TX_RX_OFFSET_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_TX_RX_OFFSET_LNX(a,b,c) "CPRIX_CN4IPX_TX_RX_OFFSET_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_TX_RX_OFFSET_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_TX_RX_OFFSET_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_tx_scr_seed_ln#
 *
 * CPRI CONN4 IP TX  Scrambling Seed Register
 */
union cavm_cprix_cn4ipx_tx_scr_seed_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_tx_scr_seed_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t tx_scr_seed           : 7;  /**< [  6:  0](R/W) Sets the scrambling seed to be used for TX. Used only for 8x speed.
                                                                 Bit 0 corresponds to seed bit X1.
                                                                 Values for TX links should be set from the table below in the given order, to
                                                                 minimize crosstalk between links.
                                                                 Index X7 X6 X5 X4 X3 X2 X1
                                                                   0    0  0  0  0  0  0  1
                                                                   1    0  0  0  0  0  1  1
                                                                   2    0  0  0  0  1  0  1
                                                                   3    0  0  0  1  1  1  1
                                                                   4    0  0  1  0  0  0  1
                                                                   5    0  1  1  0  0  1  1
                                                                   6    1  0  1  0  1  0  0
                                                                   7    1  1  1  1  1  0  1
                                                                   8    0  0  0  0  1  1  1
                                                                   9    0  0  0  1  0  0  1
                                                                   10   0  0  1  1  0  1  1
                                                                   11   0  1  0  1  1  0  1
                                                                   12   1  1  1  0  1  1  0
                                                                   13   0  0  1  1  0  1  0
                                                                   14   0  1  0  1  1  1  0
                                                                   15   1  1  1  0  0  1  1
                                                                   16   0  0  1  0  1  0  1
                                                                   17   0  1  1  1  1  1  1 */
#else /* Word 0 - Little Endian */
        uint32_t tx_scr_seed           : 7;  /**< [  6:  0](R/W) Sets the scrambling seed to be used for TX. Used only for 8x speed.
                                                                 Bit 0 corresponds to seed bit X1.
                                                                 Values for TX links should be set from the table below in the given order, to
                                                                 minimize crosstalk between links.
                                                                 Index X7 X6 X5 X4 X3 X2 X1
                                                                   0    0  0  0  0  0  0  1
                                                                   1    0  0  0  0  0  1  1
                                                                   2    0  0  0  0  1  0  1
                                                                   3    0  0  0  1  1  1  1
                                                                   4    0  0  1  0  0  0  1
                                                                   5    0  1  1  0  0  1  1
                                                                   6    1  0  1  0  1  0  0
                                                                   7    1  1  1  1  1  0  1
                                                                   8    0  0  0  0  1  1  1
                                                                   9    0  0  0  1  0  0  1
                                                                   10   0  0  1  1  0  1  1
                                                                   11   0  1  0  1  1  0  1
                                                                   12   1  1  1  0  1  1  0
                                                                   13   0  0  1  1  0  1  0
                                                                   14   0  1  0  1  1  1  0
                                                                   15   1  1  1  0  0  1  1
                                                                   16   0  0  1  0  1  0  1
                                                                   17   0  1  1  1  1  1  1 */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_tx_scr_seed_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_tx_scr_seed_lnx cavm_cprix_cn4ipx_tx_scr_seed_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_TX_SCR_SEED_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_TX_SCR_SEED_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000808098ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_TX_SCR_SEED_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_TX_SCR_SEED_LNX(a,b,c) cavm_cprix_cn4ipx_tx_scr_seed_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_TX_SCR_SEED_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_TX_SCR_SEED_LNX(a,b,c) "CPRIX_CN4IPX_TX_SCR_SEED_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_TX_SCR_SEED_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_TX_SCR_SEED_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_tx_state_ln#
 *
 * CPRI CONN4 IP TX State Machine Register
 */
union cavm_cprix_cn4ipx_tx_state_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_tx_state_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t tx_rx_offset          : 3;  /**< [  2:  0](R/W) SW implementation of the RP3 TX state machine.
                                                                 TX block will decode the following states as described in the RP3 specification:
                                                                   0x0 = OFF.
                                                                   0x1 = IDLE.
                                                                   0x2 = FRAME_TX.
                                                                   0x3 = Not Used.
                                                                   0x4 = IDLE_REQ (8x speed only).
                                                                   0x5 = IDLE_ACK (8x speed only).
                                                                   0x6-0x7 = Not Used. */
#else /* Word 0 - Little Endian */
        uint32_t tx_rx_offset          : 3;  /**< [  2:  0](R/W) SW implementation of the RP3 TX state machine.
                                                                 TX block will decode the following states as described in the RP3 specification:
                                                                   0x0 = OFF.
                                                                   0x1 = IDLE.
                                                                   0x2 = FRAME_TX.
                                                                   0x3 = Not Used.
                                                                   0x4 = IDLE_REQ (8x speed only).
                                                                   0x5 = IDLE_ACK (8x speed only).
                                                                   0x6-0x7 = Not Used. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_tx_state_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_tx_state_lnx cavm_cprix_cn4ipx_tx_state_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_TX_STATE_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_TX_STATE_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000808080ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_TX_STATE_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_TX_STATE_LNX(a,b,c) cavm_cprix_cn4ipx_tx_state_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_TX_STATE_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_TX_STATE_LNX(a,b,c) "CPRIX_CN4IPX_TX_STATE_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_TX_STATE_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_TX_STATE_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_tx_test_mode_ln#
 *
 * CPRI CONN4 IP TX Test Mode Control Register
 */
union cavm_cprix_cn4ipx_tx_test_mode_lnx
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_tx_test_mode_lnx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t tx_pat_type           : 4;  /**< [  3:  0](R/W) Selects the test pattern type:
                                                                   0x0 = Normal mode, no test pattern.
                                                                   0x1 = Functional BER.
                                                                   0x2 = CJPAT.
                                                                   0x4 = JSPAT.
                                                                   0x5 = JTSPAT.
                                                                   0x8 = PRBS7.
                                                                   0x9 = PRBS7 inverted.
                                                                   0xA = PRBS23.
                                                                   0xB = PRBS23 inverted.
                                                                   0xC = PRBS9.
                                                                   0xD = PRBS9 inverted.

                                                                 Only functional BER mode can be used during normal operation. */
#else /* Word 0 - Little Endian */
        uint32_t tx_pat_type           : 4;  /**< [  3:  0](R/W) Selects the test pattern type:
                                                                   0x0 = Normal mode, no test pattern.
                                                                   0x1 = Functional BER.
                                                                   0x2 = CJPAT.
                                                                   0x4 = JSPAT.
                                                                   0x5 = JTSPAT.
                                                                   0x8 = PRBS7.
                                                                   0x9 = PRBS7 inverted.
                                                                   0xA = PRBS23.
                                                                   0xB = PRBS23 inverted.
                                                                   0xC = PRBS9.
                                                                   0xD = PRBS9 inverted.

                                                                 Only functional BER mode can be used during normal operation. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_tx_test_mode_lnx_s cn; */
};
typedef union cavm_cprix_cn4ipx_tx_test_mode_lnx cavm_cprix_cn4ipx_tx_test_mode_lnx_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_TX_TEST_MODE_LNX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_TX_TEST_MODE_LNX(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=1)))
        return 0x864000808094ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1) + 0x1000ll * ((c) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_TX_TEST_MODE_LNX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_TX_TEST_MODE_LNX(a,b,c) cavm_cprix_cn4ipx_tx_test_mode_lnx_t
#define bustype_CAVM_CPRIX_CN4IPX_TX_TEST_MODE_LNX(a,b,c) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_TX_TEST_MODE_LNX(a,b,c) "CPRIX_CN4IPX_TX_TEST_MODE_LNX"
#define busnum_CAVM_CPRIX_CN4IPX_TX_TEST_MODE_LNX(a,b,c) (a)
#define arguments_CAVM_CPRIX_CN4IPX_TX_TEST_MODE_LNX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) cpri#_cn4ip#_wcdma_in1_0
 *
 * CPRI CONN4 IP WCDMA Timer initial N1 0 Register
 */
union cavm_cprix_cn4ipx_wcdma_in1_0
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_wcdma_in1_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_12_31        : 20;
        uint32_t n1_0                  : 12; /**< [ 11:  0](R/W) Timer initial N1 value to which timer is synced.
                                                                 The value is represented as an unsigned 40-bit value, this register has 12 LSBs. */
#else /* Word 0 - Little Endian */
        uint32_t n1_0                  : 12; /**< [ 11:  0](R/W) Timer initial N1 value to which timer is synced.
                                                                 The value is represented as an unsigned 40-bit value, this register has 12 LSBs. */
        uint32_t reserved_12_31        : 20;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_wcdma_in1_0_s cn; */
};
typedef union cavm_cprix_cn4ipx_wcdma_in1_0 cavm_cprix_cn4ipx_wcdma_in1_0_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_WCDMA_IN1_0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_WCDMA_IN1_0(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f0dcll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_WCDMA_IN1_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_WCDMA_IN1_0(a,b) cavm_cprix_cn4ipx_wcdma_in1_0_t
#define bustype_CAVM_CPRIX_CN4IPX_WCDMA_IN1_0(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_WCDMA_IN1_0(a,b) "CPRIX_CN4IPX_WCDMA_IN1_0"
#define busnum_CAVM_CPRIX_CN4IPX_WCDMA_IN1_0(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_WCDMA_IN1_0(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_wcdma_in1_1
 *
 * CPRI CONN4 IP WCDMA Timer initial N1 1 Register
 */
union cavm_cprix_cn4ipx_wcdma_in1_1
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_wcdma_in1_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t n1_1                  : 28; /**< [ 27:  0](R/W) Timer initial N1 value to which timer is synced.
                                                                 The value is represented as an unsigned 40-bit value, this register has 28 MSBs. */
#else /* Word 0 - Little Endian */
        uint32_t n1_1                  : 28; /**< [ 27:  0](R/W) Timer initial N1 value to which timer is synced.
                                                                 The value is represented as an unsigned 40-bit value, this register has 28 MSBs. */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_wcdma_in1_1_s cn; */
};
typedef union cavm_cprix_cn4ipx_wcdma_in1_1 cavm_cprix_cn4ipx_wcdma_in1_1_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_WCDMA_IN1_1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_WCDMA_IN1_1(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f0e0ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_WCDMA_IN1_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_WCDMA_IN1_1(a,b) cavm_cprix_cn4ipx_wcdma_in1_1_t
#define bustype_CAVM_CPRIX_CN4IPX_WCDMA_IN1_1(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_WCDMA_IN1_1(a,b) "CPRIX_CN4IPX_WCDMA_IN1_1"
#define busnum_CAVM_CPRIX_CN4IPX_WCDMA_IN1_1(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_WCDMA_IN1_1(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_wcdma_sn1_0
 *
 * CPRI CONN4 IP WCDMA Timer sync N1 0 Register
 */
union cavm_cprix_cn4ipx_wcdma_sn1_0
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_wcdma_sn1_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_13_31        : 19;
        uint32_t resync                : 1;  /**< [ 12: 12](R/W) Activate timer synchronization.
                                                                 Write:
                                                                   0 = No action.
                                                                   1 = Synchronize timer.
                                                                 Read:
                                                                   0 = Timer not synchronized.
                                                                   1 = Timer synchronized. */
        uint32_t n1_0                  : 12; /**< [ 11:  0](R/W) BCN timer N1 value when timer is synced.
                                                                 The value is represented as an unsigned 40-bit value, this register has 12 LSBs.
                                                                 When reading this is 12 LSBs of timer N1 value. */
#else /* Word 0 - Little Endian */
        uint32_t n1_0                  : 12; /**< [ 11:  0](R/W) BCN timer N1 value when timer is synced.
                                                                 The value is represented as an unsigned 40-bit value, this register has 12 LSBs.
                                                                 When reading this is 12 LSBs of timer N1 value. */
        uint32_t resync                : 1;  /**< [ 12: 12](R/W) Activate timer synchronization.
                                                                 Write:
                                                                   0 = No action.
                                                                   1 = Synchronize timer.
                                                                 Read:
                                                                   0 = Timer not synchronized.
                                                                   1 = Timer synchronized. */
        uint32_t reserved_13_31        : 19;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_wcdma_sn1_0_s cn; */
};
typedef union cavm_cprix_cn4ipx_wcdma_sn1_0 cavm_cprix_cn4ipx_wcdma_sn1_0_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_WCDMA_SN1_0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_WCDMA_SN1_0(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f0d0ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_WCDMA_SN1_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_WCDMA_SN1_0(a,b) cavm_cprix_cn4ipx_wcdma_sn1_0_t
#define bustype_CAVM_CPRIX_CN4IPX_WCDMA_SN1_0(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_WCDMA_SN1_0(a,b) "CPRIX_CN4IPX_WCDMA_SN1_0"
#define busnum_CAVM_CPRIX_CN4IPX_WCDMA_SN1_0(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_WCDMA_SN1_0(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_wcdma_sn1_1
 *
 * CPRI CONN4 IP WCDMA Timer sync N1 1 Register
 */
union cavm_cprix_cn4ipx_wcdma_sn1_1
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_wcdma_sn1_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t n1_1                  : 28; /**< [ 27:  0](R/W) BCN timer N1 value when timer is synced.
                                                                 The value is represented as an unsigned 40-bit value, this register has 28 MSBs.
                                                                 When reading this is 28 MSBs of timer N1 value. */
#else /* Word 0 - Little Endian */
        uint32_t n1_1                  : 28; /**< [ 27:  0](R/W) BCN timer N1 value when timer is synced.
                                                                 The value is represented as an unsigned 40-bit value, this register has 28 MSBs.
                                                                 When reading this is 28 MSBs of timer N1 value. */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_wcdma_sn1_1_s cn; */
};
typedef union cavm_cprix_cn4ipx_wcdma_sn1_1 cavm_cprix_cn4ipx_wcdma_sn1_1_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_WCDMA_SN1_1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_WCDMA_SN1_1(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f0d4ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_WCDMA_SN1_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_WCDMA_SN1_1(a,b) cavm_cprix_cn4ipx_wcdma_sn1_1_t
#define bustype_CAVM_CPRIX_CN4IPX_WCDMA_SN1_1(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_WCDMA_SN1_1(a,b) "CPRIX_CN4IPX_WCDMA_SN1_1"
#define busnum_CAVM_CPRIX_CN4IPX_WCDMA_SN1_1(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_WCDMA_SN1_1(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) cpri#_cn4ip#_wcdma_sn2
 *
 * CPRI CONN4 IP WCDMA Timer sync N2 Register
 */
union cavm_cprix_cn4ipx_wcdma_sn2
{
    uint32_t u;
    struct cavm_cprix_cn4ipx_wcdma_sn2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_22_31        : 10;
        uint32_t n2                    : 22; /**< [ 21:  0](R/W) BCN timer N2 value when timer is synced.
                                                                 The value is represented as an unsigned 22-bit value.
                                                                 When reading this is timer N2 value. */
#else /* Word 0 - Little Endian */
        uint32_t n2                    : 22; /**< [ 21:  0](R/W) BCN timer N2 value when timer is synced.
                                                                 The value is represented as an unsigned 22-bit value.
                                                                 When reading this is timer N2 value. */
        uint32_t reserved_22_31        : 10;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_cn4ipx_wcdma_sn2_s cn; */
};
typedef union cavm_cprix_cn4ipx_wcdma_sn2 cavm_cprix_cn4ipx_wcdma_sn2_t;

static inline uint64_t CAVM_CPRIX_CN4IPX_WCDMA_SN2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CN4IPX_WCDMA_SN2(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x86400080f0d8ll + 0x1000000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_CN4IPX_WCDMA_SN2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CN4IPX_WCDMA_SN2(a,b) cavm_cprix_cn4ipx_wcdma_sn2_t
#define bustype_CAVM_CPRIX_CN4IPX_WCDMA_SN2(a,b) CSR_TYPE_NCB32b
#define basename_CAVM_CPRIX_CN4IPX_WCDMA_SN2(a,b) "CPRIX_CN4IPX_WCDMA_SN2"
#define busnum_CAVM_CPRIX_CN4IPX_WCDMA_SN2(a,b) (a)
#define arguments_CAVM_CPRIX_CN4IPX_WCDMA_SN2(a,b) (a),(b),-1,-1

/**
 * Register (NCB) cpri#_control
 *
 * CPRI Control Register
 */
union cavm_cprix_control
{
    uint64_t u;
    struct cavm_cprix_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_0_63         : 64;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_63         : 64;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_control_s cn; */
};
typedef union cavm_cprix_control cavm_cprix_control_t;

static inline uint64_t CAVM_CPRIX_CONTROL(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_CONTROL(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x864000000000ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_CONTROL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_CONTROL(a) cavm_cprix_control_t
#define bustype_CAVM_CPRIX_CONTROL(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_CONTROL(a) "CPRIX_CONTROL"
#define busnum_CAVM_CPRIX_CONTROL(a) (a)
#define arguments_CAVM_CPRIX_CONTROL(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_eco
 *
 * INTERNAL: CPRI ECO Register
 *
 * An ECO CSR
 */
union cavm_cprix_eco
{
    uint64_t u;
    struct cavm_cprix_eco_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t eco_rw                : 64; /**< [ 63:  0](R/W) Reserved for ECO usage. */
#else /* Word 0 - Little Endian */
        uint64_t eco_rw                : 64; /**< [ 63:  0](R/W) Reserved for ECO usage. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_eco_s cn; */
};
typedef union cavm_cprix_eco cavm_cprix_eco_t;

static inline uint64_t CAVM_CPRIX_ECO(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_ECO(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x864000000008ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_ECO", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_ECO(a) cavm_cprix_eco_t
#define bustype_CAVM_CPRIX_ECO(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_ECO(a) "CPRIX_ECO"
#define busnum_CAVM_CPRIX_ECO(a) (a)
#define arguments_CAVM_CPRIX_ECO(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_eth#_bad_crc_cnt
 *
 * CPRI Ethernet Bad CRC Count Register
 */
union cavm_cprix_ethx_bad_crc_cnt
{
    uint64_t u;
    struct cavm_cprix_ethx_bad_crc_cnt_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t bad_crc_cnt           : 32; /**< [ 31:  0](RC/H) Count of CRC error events detected. */
#else /* Word 0 - Little Endian */
        uint64_t bad_crc_cnt           : 32; /**< [ 31:  0](RC/H) Count of CRC error events detected. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_ethx_bad_crc_cnt_s cn; */
};
typedef union cavm_cprix_ethx_bad_crc_cnt cavm_cprix_ethx_bad_crc_cnt_t;

static inline uint64_t CAVM_CPRIX_ETHX_BAD_CRC_CNT(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_ETHX_BAD_CRC_CNT(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=3)))
        return 0x864000000200ll + 0x1000000000ll * ((a) & 0x3) + 0x400ll * ((b) & 0x3);
    __cavm_csr_fatal("CPRIX_ETHX_BAD_CRC_CNT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_ETHX_BAD_CRC_CNT(a,b) cavm_cprix_ethx_bad_crc_cnt_t
#define bustype_CAVM_CPRIX_ETHX_BAD_CRC_CNT(a,b) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_ETHX_BAD_CRC_CNT(a,b) "CPRIX_ETHX_BAD_CRC_CNT"
#define busnum_CAVM_CPRIX_ETHX_BAD_CRC_CNT(a,b) (a)
#define arguments_CAVM_CPRIX_ETHX_BAD_CRC_CNT(a,b) (a),(b),-1,-1

/**
 * Register (NCB) cpri#_eth#_dl_goctets_cnt
 *
 * CPRI Ethernet Downlink Good Octets Count Register
 */
union cavm_cprix_ethx_dl_goctets_cnt
{
    uint64_t u;
    struct cavm_cprix_ethx_dl_goctets_cnt_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t dl_goctets_cnt        : 32; /**< [ 31:  0](RC/H) Number of Ethernet good octets sent to CONN004 IP for this link */
#else /* Word 0 - Little Endian */
        uint64_t dl_goctets_cnt        : 32; /**< [ 31:  0](RC/H) Number of Ethernet good octets sent to CONN004 IP for this link */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_ethx_dl_goctets_cnt_s cn; */
};
typedef union cavm_cprix_ethx_dl_goctets_cnt cavm_cprix_ethx_dl_goctets_cnt_t;

static inline uint64_t CAVM_CPRIX_ETHX_DL_GOCTETS_CNT(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_ETHX_DL_GOCTETS_CNT(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=3)))
        return 0x864000000240ll + 0x1000000000ll * ((a) & 0x3) + 0x400ll * ((b) & 0x3);
    __cavm_csr_fatal("CPRIX_ETHX_DL_GOCTETS_CNT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_ETHX_DL_GOCTETS_CNT(a,b) cavm_cprix_ethx_dl_goctets_cnt_t
#define bustype_CAVM_CPRIX_ETHX_DL_GOCTETS_CNT(a,b) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_ETHX_DL_GOCTETS_CNT(a,b) "CPRIX_ETHX_DL_GOCTETS_CNT"
#define busnum_CAVM_CPRIX_ETHX_DL_GOCTETS_CNT(a,b) (a)
#define arguments_CAVM_CPRIX_ETHX_DL_GOCTETS_CNT(a,b) (a),(b),-1,-1

/**
 * Register (NCB) cpri#_eth#_dl_gpkts_cnt
 *
 * CPRI Ethernet Downlink Good Packets Count Register
 */
union cavm_cprix_ethx_dl_gpkts_cnt
{
    uint64_t u;
    struct cavm_cprix_ethx_dl_gpkts_cnt_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t dl_gpkts_cnt          : 32; /**< [ 31:  0](RC/H) Number of Ethernet good packets sent. */
#else /* Word 0 - Little Endian */
        uint64_t dl_gpkts_cnt          : 32; /**< [ 31:  0](RC/H) Number of Ethernet good packets sent. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_ethx_dl_gpkts_cnt_s cn; */
};
typedef union cavm_cprix_ethx_dl_gpkts_cnt cavm_cprix_ethx_dl_gpkts_cnt_t;

static inline uint64_t CAVM_CPRIX_ETHX_DL_GPKTS_CNT(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_ETHX_DL_GPKTS_CNT(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=3)))
        return 0x864000000248ll + 0x1000000000ll * ((a) & 0x3) + 0x400ll * ((b) & 0x3);
    __cavm_csr_fatal("CPRIX_ETHX_DL_GPKTS_CNT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_ETHX_DL_GPKTS_CNT(a,b) cavm_cprix_ethx_dl_gpkts_cnt_t
#define bustype_CAVM_CPRIX_ETHX_DL_GPKTS_CNT(a,b) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_ETHX_DL_GPKTS_CNT(a,b) "CPRIX_ETHX_DL_GPKTS_CNT"
#define busnum_CAVM_CPRIX_ETHX_DL_GPKTS_CNT(a,b) (a)
#define arguments_CAVM_CPRIX_ETHX_DL_GPKTS_CNT(a,b) (a),(b),-1,-1

/**
 * Register (NCB) cpri#_eth#_ul_boct_cnt
 *
 * CPRI Ethernet Receive Bad Octets Count Register
 */
union cavm_cprix_ethx_ul_boct_cnt
{
    uint64_t u;
    struct cavm_cprix_ethx_ul_boct_cnt_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t ul_boct_cnt           : 32; /**< [ 31:  0](RC/H) Number of Ethernet bad octets received. This includes Frames with bad Preamble
                                                                 or SFD or FCS and undersize or oversize frames and overrun */
#else /* Word 0 - Little Endian */
        uint64_t ul_boct_cnt           : 32; /**< [ 31:  0](RC/H) Number of Ethernet bad octets received. This includes Frames with bad Preamble
                                                                 or SFD or FCS and undersize or oversize frames and overrun */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_ethx_ul_boct_cnt_s cn; */
};
typedef union cavm_cprix_ethx_ul_boct_cnt cavm_cprix_ethx_ul_boct_cnt_t;

static inline uint64_t CAVM_CPRIX_ETHX_UL_BOCT_CNT(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_ETHX_UL_BOCT_CNT(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=3)))
        return 0x864000000230ll + 0x1000000000ll * ((a) & 0x3) + 0x400ll * ((b) & 0x3);
    __cavm_csr_fatal("CPRIX_ETHX_UL_BOCT_CNT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_ETHX_UL_BOCT_CNT(a,b) cavm_cprix_ethx_ul_boct_cnt_t
#define bustype_CAVM_CPRIX_ETHX_UL_BOCT_CNT(a,b) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_ETHX_UL_BOCT_CNT(a,b) "CPRIX_ETHX_UL_BOCT_CNT"
#define busnum_CAVM_CPRIX_ETHX_UL_BOCT_CNT(a,b) (a)
#define arguments_CAVM_CPRIX_ETHX_UL_BOCT_CNT(a,b) (a),(b),-1,-1

/**
 * Register (NCB) cpri#_eth#_ul_err_cnt
 *
 * CPRI Ethernet Uplink Error Count Register
 */
union cavm_cprix_ethx_ul_err_cnt
{
    uint64_t u;
    struct cavm_cprix_ethx_ul_err_cnt_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t ul_err_cnt            : 32; /**< [ 31:  0](RC/H) Count of Ethernet uplink error events detected. This counts all frames that were
                                                                 dropped due to bad CRC or bad Preamble or SFD or overflow or undersize or
                                                                 oversize */
#else /* Word 0 - Little Endian */
        uint64_t ul_err_cnt            : 32; /**< [ 31:  0](RC/H) Count of Ethernet uplink error events detected. This counts all frames that were
                                                                 dropped due to bad CRC or bad Preamble or SFD or overflow or undersize or
                                                                 oversize */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_ethx_ul_err_cnt_s cn; */
};
typedef union cavm_cprix_ethx_ul_err_cnt cavm_cprix_ethx_ul_err_cnt_t;

static inline uint64_t CAVM_CPRIX_ETHX_UL_ERR_CNT(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_ETHX_UL_ERR_CNT(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=3)))
        return 0x864000000208ll + 0x1000000000ll * ((a) & 0x3) + 0x400ll * ((b) & 0x3);
    __cavm_csr_fatal("CPRIX_ETHX_UL_ERR_CNT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_ETHX_UL_ERR_CNT(a,b) cavm_cprix_ethx_ul_err_cnt_t
#define bustype_CAVM_CPRIX_ETHX_UL_ERR_CNT(a,b) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_ETHX_UL_ERR_CNT(a,b) "CPRIX_ETHX_UL_ERR_CNT"
#define busnum_CAVM_CPRIX_ETHX_UL_ERR_CNT(a,b) (a)
#define arguments_CAVM_CPRIX_ETHX_UL_ERR_CNT(a,b) (a),(b),-1,-1

/**
 * Register (NCB) cpri#_eth#_ul_fifo_orun_cnt
 *
 * CPRI Ethernet Receive FIFO Overrun Count Register
 */
union cavm_cprix_ethx_ul_fifo_orun_cnt
{
    uint64_t u;
    struct cavm_cprix_ethx_ul_fifo_orun_cnt_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t ff_orun_cnt           : 32; /**< [ 31:  0](RC/H) Number of times the Ethernet receive FIFO has overrun. */
#else /* Word 0 - Little Endian */
        uint64_t ff_orun_cnt           : 32; /**< [ 31:  0](RC/H) Number of times the Ethernet receive FIFO has overrun. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_ethx_ul_fifo_orun_cnt_s cn; */
};
typedef union cavm_cprix_ethx_ul_fifo_orun_cnt cavm_cprix_ethx_ul_fifo_orun_cnt_t;

static inline uint64_t CAVM_CPRIX_ETHX_UL_FIFO_ORUN_CNT(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_ETHX_UL_FIFO_ORUN_CNT(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=3)))
        return 0x864000000220ll + 0x1000000000ll * ((a) & 0x3) + 0x400ll * ((b) & 0x3);
    __cavm_csr_fatal("CPRIX_ETHX_UL_FIFO_ORUN_CNT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_ETHX_UL_FIFO_ORUN_CNT(a,b) cavm_cprix_ethx_ul_fifo_orun_cnt_t
#define bustype_CAVM_CPRIX_ETHX_UL_FIFO_ORUN_CNT(a,b) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_ETHX_UL_FIFO_ORUN_CNT(a,b) "CPRIX_ETHX_UL_FIFO_ORUN_CNT"
#define busnum_CAVM_CPRIX_ETHX_UL_FIFO_ORUN_CNT(a,b) (a)
#define arguments_CAVM_CPRIX_ETHX_UL_FIFO_ORUN_CNT(a,b) (a),(b),-1,-1

/**
 * Register (NCB) cpri#_eth#_ul_goct_cnt
 *
 * CPRI Ethernet Receive Good Octets Count Register
 */
union cavm_cprix_ethx_ul_goct_cnt
{
    uint64_t u;
    struct cavm_cprix_ethx_ul_goct_cnt_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t ul_goct_cnt           : 32; /**< [ 31:  0](RC/H) Number of Ethernet good octets received. This excludes Frames with bad Preamble
                                                                 or SFD or FCS and undersize or oversize frames and overrun */
#else /* Word 0 - Little Endian */
        uint64_t ul_goct_cnt           : 32; /**< [ 31:  0](RC/H) Number of Ethernet good octets received. This excludes Frames with bad Preamble
                                                                 or SFD or FCS and undersize or oversize frames and overrun */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_ethx_ul_goct_cnt_s cn; */
};
typedef union cavm_cprix_ethx_ul_goct_cnt cavm_cprix_ethx_ul_goct_cnt_t;

static inline uint64_t CAVM_CPRIX_ETHX_UL_GOCT_CNT(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_ETHX_UL_GOCT_CNT(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=3)))
        return 0x864000000238ll + 0x1000000000ll * ((a) & 0x3) + 0x400ll * ((b) & 0x3);
    __cavm_csr_fatal("CPRIX_ETHX_UL_GOCT_CNT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_ETHX_UL_GOCT_CNT(a,b) cavm_cprix_ethx_ul_goct_cnt_t
#define bustype_CAVM_CPRIX_ETHX_UL_GOCT_CNT(a,b) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_ETHX_UL_GOCT_CNT(a,b) "CPRIX_ETHX_UL_GOCT_CNT"
#define busnum_CAVM_CPRIX_ETHX_UL_GOCT_CNT(a,b) (a)
#define arguments_CAVM_CPRIX_ETHX_UL_GOCT_CNT(a,b) (a),(b),-1,-1

/**
 * Register (NCB) cpri#_eth#_ul_gpkts_cnt
 *
 * CPRI Ethernet Uplink Good Packets Count Register
 */
union cavm_cprix_ethx_ul_gpkts_cnt
{
    uint64_t u;
    struct cavm_cprix_ethx_ul_gpkts_cnt_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t ul_gpkts_cnt          : 32; /**< [ 31:  0](RC/H) Number of Ethernet good packets received from CONN004 IP for this link. This
                                                                 excludes Frames with bad Preamble or SFD and undersize or oversize frames and
                                                                 overrun. */
#else /* Word 0 - Little Endian */
        uint64_t ul_gpkts_cnt          : 32; /**< [ 31:  0](RC/H) Number of Ethernet good packets received from CONN004 IP for this link. This
                                                                 excludes Frames with bad Preamble or SFD and undersize or oversize frames and
                                                                 overrun. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_ethx_ul_gpkts_cnt_s cn; */
};
typedef union cavm_cprix_ethx_ul_gpkts_cnt cavm_cprix_ethx_ul_gpkts_cnt_t;

static inline uint64_t CAVM_CPRIX_ETHX_UL_GPKTS_CNT(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_ETHX_UL_GPKTS_CNT(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=3)))
        return 0x864000000228ll + 0x1000000000ll * ((a) & 0x3) + 0x400ll * ((b) & 0x3);
    __cavm_csr_fatal("CPRIX_ETHX_UL_GPKTS_CNT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_ETHX_UL_GPKTS_CNT(a,b) cavm_cprix_ethx_ul_gpkts_cnt_t
#define bustype_CAVM_CPRIX_ETHX_UL_GPKTS_CNT(a,b) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_ETHX_UL_GPKTS_CNT(a,b) "CPRIX_ETHX_UL_GPKTS_CNT"
#define busnum_CAVM_CPRIX_ETHX_UL_GPKTS_CNT(a,b) (a)
#define arguments_CAVM_CPRIX_ETHX_UL_GPKTS_CNT(a,b) (a),(b),-1,-1

/**
 * Register (NCB) cpri#_eth#_ul_osize_cnt
 *
 * CPRI Ethernet Uplink Oversized Packet Count Register
 */
union cavm_cprix_ethx_ul_osize_cnt
{
    uint64_t u;
    struct cavm_cprix_ethx_ul_osize_cnt_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t osize_cnt             : 32; /**< [ 31:  0](RC/H) Number of oversized Ethernet packets received. */
#else /* Word 0 - Little Endian */
        uint64_t osize_cnt             : 32; /**< [ 31:  0](RC/H) Number of oversized Ethernet packets received. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_ethx_ul_osize_cnt_s cn; */
};
typedef union cavm_cprix_ethx_ul_osize_cnt cavm_cprix_ethx_ul_osize_cnt_t;

static inline uint64_t CAVM_CPRIX_ETHX_UL_OSIZE_CNT(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_ETHX_UL_OSIZE_CNT(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=3)))
        return 0x864000000210ll + 0x1000000000ll * ((a) & 0x3) + 0x400ll * ((b) & 0x3);
    __cavm_csr_fatal("CPRIX_ETHX_UL_OSIZE_CNT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_ETHX_UL_OSIZE_CNT(a,b) cavm_cprix_ethx_ul_osize_cnt_t
#define bustype_CAVM_CPRIX_ETHX_UL_OSIZE_CNT(a,b) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_ETHX_UL_OSIZE_CNT(a,b) "CPRIX_ETHX_UL_OSIZE_CNT"
#define busnum_CAVM_CPRIX_ETHX_UL_OSIZE_CNT(a,b) (a)
#define arguments_CAVM_CPRIX_ETHX_UL_OSIZE_CNT(a,b) (a),(b),-1,-1

/**
 * Register (NCB) cpri#_eth#_ul_usize_cnt
 *
 * CPRI Ethernet Uplink Undersized Packet Count Register
 */
union cavm_cprix_ethx_ul_usize_cnt
{
    uint64_t u;
    struct cavm_cprix_ethx_ul_usize_cnt_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t usize_cnt             : 32; /**< [ 31:  0](RC/H) Number of undersized Ethernet packets received. */
#else /* Word 0 - Little Endian */
        uint64_t usize_cnt             : 32; /**< [ 31:  0](RC/H) Number of undersized Ethernet packets received. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_ethx_ul_usize_cnt_s cn; */
};
typedef union cavm_cprix_ethx_ul_usize_cnt cavm_cprix_ethx_ul_usize_cnt_t;

static inline uint64_t CAVM_CPRIX_ETHX_UL_USIZE_CNT(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_ETHX_UL_USIZE_CNT(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=3)))
        return 0x864000000218ll + 0x1000000000ll * ((a) & 0x3) + 0x400ll * ((b) & 0x3);
    __cavm_csr_fatal("CPRIX_ETHX_UL_USIZE_CNT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_ETHX_UL_USIZE_CNT(a,b) cavm_cprix_ethx_ul_usize_cnt_t
#define bustype_CAVM_CPRIX_ETHX_UL_USIZE_CNT(a,b) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_ETHX_UL_USIZE_CNT(a,b) "CPRIX_ETHX_UL_USIZE_CNT"
#define busnum_CAVM_CPRIX_ETHX_UL_USIZE_CNT(a,b) (a)
#define arguments_CAVM_CPRIX_ETHX_UL_USIZE_CNT(a,b) (a),(b),-1,-1

/**
 * Register (NCB) cpri#_ghb_control
 *
 * INTERNAL: CPRI GHB_CONTROL Register
 *
 * Contains WRR config bits for GAA interface
 */
union cavm_cprix_ghb_control
{
    uint64_t u;
    struct cavm_cprix_ghb_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_14_63        : 50;
        uint64_t ghb_rd_weight         : 6;  /**< [ 13:  8](R/W) The weighted round-robin arbitration weight used in the GHAB when
                                                                 arbitrating for read requests from this MHAB. A value of zero will
                                                                 only allow requests when there are no competing requests from other
                                                                 MHABs in the same GHAB, or when all competing MHABs have an effective
                                                                 weight of zero. A higher weight guarantees a greater share of the GHAB
                                                                 bandwidth. */
        uint64_t reserved_6_7          : 2;
        uint64_t ghb_wr_weight         : 6;  /**< [  5:  0](R/W) The weighted round-robin arbitration weight used in the GHAB when
                                                                 arbitrating for read requests from this MHAB. A value of zero will
                                                                 only allow requests when there are no competing requests from other
                                                                 MHABs in the same GHAB, or when all competing MHABs have an effective
                                                                 weight of zero. A higher weight guarantees a greater share of the GHAB
                                                                 bandwidth. */
#else /* Word 0 - Little Endian */
        uint64_t ghb_wr_weight         : 6;  /**< [  5:  0](R/W) The weighted round-robin arbitration weight used in the GHAB when
                                                                 arbitrating for read requests from this MHAB. A value of zero will
                                                                 only allow requests when there are no competing requests from other
                                                                 MHABs in the same GHAB, or when all competing MHABs have an effective
                                                                 weight of zero. A higher weight guarantees a greater share of the GHAB
                                                                 bandwidth. */
        uint64_t reserved_6_7          : 2;
        uint64_t ghb_rd_weight         : 6;  /**< [ 13:  8](R/W) The weighted round-robin arbitration weight used in the GHAB when
                                                                 arbitrating for read requests from this MHAB. A value of zero will
                                                                 only allow requests when there are no competing requests from other
                                                                 MHABs in the same GHAB, or when all competing MHABs have an effective
                                                                 weight of zero. A higher weight guarantees a greater share of the GHAB
                                                                 bandwidth. */
        uint64_t reserved_14_63        : 50;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_ghb_control_s cn; */
};
typedef union cavm_cprix_ghb_control cavm_cprix_ghb_control_t;

static inline uint64_t CAVM_CPRIX_GHB_CONTROL(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_GHB_CONTROL(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x8640000001f8ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_GHB_CONTROL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_GHB_CONTROL(a) cavm_cprix_ghb_control_t
#define bustype_CAVM_CPRIX_GHB_CONTROL(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_GHB_CONTROL(a) "CPRIX_GHB_CONTROL"
#define busnum_CAVM_CPRIX_GHB_CONTROL(a) (a)
#define arguments_CAVM_CPRIX_GHB_CONTROL(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_ip#_axi_int
 *
 * INTERNAL: CPRI AXI Interrupt and INT EVENT CLEAR Register
 *
 * These registers record interrupts due to AXI interface, captured from the
 * PSS_INT information of CONT004.
 */
union cavm_cprix_ipx_axi_int
{
    uint64_t u;
    struct cavm_cprix_ipx_axi_int_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t pss_int               : 32; /**< [ 31:  0](R/W1C/H) PSS_INT information */
#else /* Word 0 - Little Endian */
        uint64_t pss_int               : 32; /**< [ 31:  0](R/W1C/H) PSS_INT information */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_ipx_axi_int_s cn; */
};
typedef union cavm_cprix_ipx_axi_int cavm_cprix_ipx_axi_int_t;

static inline uint64_t CAVM_CPRIX_IPX_AXI_INT(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_IPX_AXI_INT(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000000108ll + 0x1000000000ll * ((a) & 0x3) + 0x400ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_IPX_AXI_INT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_IPX_AXI_INT(a,b) cavm_cprix_ipx_axi_int_t
#define bustype_CAVM_CPRIX_IPX_AXI_INT(a,b) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_IPX_AXI_INT(a,b) "CPRIX_IPX_AXI_INT"
#define busnum_CAVM_CPRIX_IPX_AXI_INT(a,b) (a)
#define arguments_CAVM_CPRIX_IPX_AXI_INT(a,b) (a),(b),-1,-1

/**
 * Register (NCB) cpri#_ip#_axi_int_ena_w1c
 *
 * INTERNAL: CPRI AXI Interrupt Mask Set Register
 *
 * This register clears interrupt enable bits.
 */
union cavm_cprix_ipx_axi_int_ena_w1c
{
    uint64_t u;
    struct cavm_cprix_ipx_axi_int_ena_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t pss_int               : 32; /**< [ 31:  0](R/W1C/H) Reads or clears enable for CPRI(0..2)_IP(0..1)_AXI_INT[PSS_INT]. */
#else /* Word 0 - Little Endian */
        uint64_t pss_int               : 32; /**< [ 31:  0](R/W1C/H) Reads or clears enable for CPRI(0..2)_IP(0..1)_AXI_INT[PSS_INT]. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_ipx_axi_int_ena_w1c_s cn; */
};
typedef union cavm_cprix_ipx_axi_int_ena_w1c cavm_cprix_ipx_axi_int_ena_w1c_t;

static inline uint64_t CAVM_CPRIX_IPX_AXI_INT_ENA_W1C(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_IPX_AXI_INT_ENA_W1C(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000000130ll + 0x1000000000ll * ((a) & 0x3) + 0x400ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_IPX_AXI_INT_ENA_W1C", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_IPX_AXI_INT_ENA_W1C(a,b) cavm_cprix_ipx_axi_int_ena_w1c_t
#define bustype_CAVM_CPRIX_IPX_AXI_INT_ENA_W1C(a,b) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_IPX_AXI_INT_ENA_W1C(a,b) "CPRIX_IPX_AXI_INT_ENA_W1C"
#define busnum_CAVM_CPRIX_IPX_AXI_INT_ENA_W1C(a,b) (a)
#define arguments_CAVM_CPRIX_IPX_AXI_INT_ENA_W1C(a,b) (a),(b),-1,-1

/**
 * Register (NCB) cpri#_ip#_axi_int_ena_w1s
 *
 * INTERNAL: CPRI AXI Interrupt Mask Clear Register
 *
 * This register sets interrupt enable bits.
 */
union cavm_cprix_ipx_axi_int_ena_w1s
{
    uint64_t u;
    struct cavm_cprix_ipx_axi_int_ena_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t pss_int               : 32; /**< [ 31:  0](R/W1S/H) Reads or sets enable for CPRI(0..2)_IP(0..1)_AXI_INT[PSS_INT]. */
#else /* Word 0 - Little Endian */
        uint64_t pss_int               : 32; /**< [ 31:  0](R/W1S/H) Reads or sets enable for CPRI(0..2)_IP(0..1)_AXI_INT[PSS_INT]. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_ipx_axi_int_ena_w1s_s cn; */
};
typedef union cavm_cprix_ipx_axi_int_ena_w1s cavm_cprix_ipx_axi_int_ena_w1s_t;

static inline uint64_t CAVM_CPRIX_IPX_AXI_INT_ENA_W1S(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_IPX_AXI_INT_ENA_W1S(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000000128ll + 0x1000000000ll * ((a) & 0x3) + 0x400ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_IPX_AXI_INT_ENA_W1S", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_IPX_AXI_INT_ENA_W1S(a,b) cavm_cprix_ipx_axi_int_ena_w1s_t
#define bustype_CAVM_CPRIX_IPX_AXI_INT_ENA_W1S(a,b) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_IPX_AXI_INT_ENA_W1S(a,b) "CPRIX_IPX_AXI_INT_ENA_W1S"
#define busnum_CAVM_CPRIX_IPX_AXI_INT_ENA_W1S(a,b) (a)
#define arguments_CAVM_CPRIX_IPX_AXI_INT_ENA_W1S(a,b) (a),(b),-1,-1

/**
 * Register (NCB) cpri#_ip#_axi_int_mask
 *
 * INTERNAL: CPRI AXI Interrupt Mask Register
 */
union cavm_cprix_ipx_axi_int_mask
{
    uint64_t u;
    struct cavm_cprix_ipx_axi_int_mask_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t pss_int               : 32; /**< [ 31:  0](R/W1C/H) PSS_INT information */
#else /* Word 0 - Little Endian */
        uint64_t pss_int               : 32; /**< [ 31:  0](R/W1C/H) PSS_INT information */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_ipx_axi_int_mask_s cn; */
};
typedef union cavm_cprix_ipx_axi_int_mask cavm_cprix_ipx_axi_int_mask_t;

static inline uint64_t CAVM_CPRIX_IPX_AXI_INT_MASK(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_IPX_AXI_INT_MASK(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000000120ll + 0x1000000000ll * ((a) & 0x3) + 0x400ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_IPX_AXI_INT_MASK", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_IPX_AXI_INT_MASK(a,b) cavm_cprix_ipx_axi_int_mask_t
#define bustype_CAVM_CPRIX_IPX_AXI_INT_MASK(a,b) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_IPX_AXI_INT_MASK(a,b) "CPRIX_IPX_AXI_INT_MASK"
#define busnum_CAVM_CPRIX_IPX_AXI_INT_MASK(a,b) (a)
#define arguments_CAVM_CPRIX_IPX_AXI_INT_MASK(a,b) (a),(b),-1,-1

/**
 * Register (NCB) cpri#_ip#_axi_int_status
 *
 * INTERNAL: CPRI AXI Interrupt Status after Mask Register
 */
union cavm_cprix_ipx_axi_int_status
{
    uint64_t u;
    struct cavm_cprix_ipx_axi_int_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t pss_int               : 32; /**< [ 31:  0](RO/H) PSS_INT Status information, after gating with Interrupt Mask */
#else /* Word 0 - Little Endian */
        uint64_t pss_int               : 32; /**< [ 31:  0](RO/H) PSS_INT Status information, after gating with Interrupt Mask */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_ipx_axi_int_status_s cn; */
};
typedef union cavm_cprix_ipx_axi_int_status cavm_cprix_ipx_axi_int_status_t;

static inline uint64_t CAVM_CPRIX_IPX_AXI_INT_STATUS(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_IPX_AXI_INT_STATUS(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000000100ll + 0x1000000000ll * ((a) & 0x3) + 0x400ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_IPX_AXI_INT_STATUS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_IPX_AXI_INT_STATUS(a,b) cavm_cprix_ipx_axi_int_status_t
#define bustype_CAVM_CPRIX_IPX_AXI_INT_STATUS(a,b) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_IPX_AXI_INT_STATUS(a,b) "CPRIX_IPX_AXI_INT_STATUS"
#define busnum_CAVM_CPRIX_IPX_AXI_INT_STATUS(a,b) (a)
#define arguments_CAVM_CPRIX_IPX_AXI_INT_STATUS(a,b) (a),(b),-1,-1

/**
 * Register (NCB) cpri#_ip#_axi_int_w1s
 *
 * INTERNAL: CPRI AXI Interrupt Set Register
 *
 * This register sets interrupt bits.
 */
union cavm_cprix_ipx_axi_int_w1s
{
    uint64_t u;
    struct cavm_cprix_ipx_axi_int_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t pss_int               : 32; /**< [ 31:  0](R/W1S/H) Reads or sets CPRI(0..2)_IP(0..1)_AXI_INT[PSS_INT]. */
#else /* Word 0 - Little Endian */
        uint64_t pss_int               : 32; /**< [ 31:  0](R/W1S/H) Reads or sets CPRI(0..2)_IP(0..1)_AXI_INT[PSS_INT]. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_ipx_axi_int_w1s_s cn; */
};
typedef union cavm_cprix_ipx_axi_int_w1s cavm_cprix_ipx_axi_int_w1s_t;

static inline uint64_t CAVM_CPRIX_IPX_AXI_INT_W1S(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_IPX_AXI_INT_W1S(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1)))
        return 0x864000000110ll + 0x1000000000ll * ((a) & 0x3) + 0x400ll * ((b) & 0x1);
    __cavm_csr_fatal("CPRIX_IPX_AXI_INT_W1S", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_IPX_AXI_INT_W1S(a,b) cavm_cprix_ipx_axi_int_w1s_t
#define bustype_CAVM_CPRIX_IPX_AXI_INT_W1S(a,b) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_IPX_AXI_INT_W1S(a,b) "CPRIX_IPX_AXI_INT_W1S"
#define busnum_CAVM_CPRIX_IPX_AXI_INT_W1S(a,b) (a)
#define arguments_CAVM_CPRIX_IPX_AXI_INT_W1S(a,b) (a),(b),-1,-1

/**
 * Register (NCB) cpri#_mhb_int
 *
 * INTERNAL: CPRI MHB Interrupt Register
 *
 * These registers record interrupts due to different error events that occur in the
 * MHAB outside of the CONN004 IPs
 */
union cavm_cprix_mhb_int
{
    uint64_t u;
    struct cavm_cprix_mhb_int_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t dl_rp3_fifo_ovfl      : 1;  /**< [ 15: 15](R/W1C/H) RP3 DL Request Fifo overflow inside TXDMA module */
        uint64_t dl_rp3_dma_ferr       : 1;  /**< [ 14: 14](R/W1C/H) Fatal Error detected during RP3 DMA */
        uint64_t dl_rp3_dma_nferr      : 1;  /**< [ 13: 13](R/W1C/H) Non-Fatal Error detected during RP3 DMA */
        uint64_t gmii_dl_pkt_dma_ferr  : 1;  /**< [ 12: 12](R/W1C/H) Fatal Error detected during Packet DMA */
        uint64_t gmii_dl_pkt_dma_nferr : 1;  /**< [ 11: 11](R/W1C/H) Non-Fatal Error detected during Packet DMA */
        uint64_t ul_rp3_fifo_ovfl      : 1;  /**< [ 10: 10](R/W1C/H) RP3 UL FIFO overflow error inside RXDMA module */
        uint64_t ul_pkt_fifo_ovfl      : 1;  /**< [  9:  9](R/W1C/H) GMII UL FIFO overflow err inside RXDMA module */
        uint64_t ul_rp3_dma_ferr       : 1;  /**< [  8:  8](R/W1C/H) Fatal Error detected during RP3 DMA */
        uint64_t ul_rp3_dma_nferr      : 1;  /**< [  7:  7](R/W1C/H) Non-Fatal Error detected during RP3 DMA */
        uint64_t gmii_ul_pkt_dma_ferr  : 1;  /**< [  6:  6](R/W1C/H) Fatal Error detected during Packet DMA */
        uint64_t gmii_ul_pkt_dma_nferr : 1;  /**< [  5:  5](R/W1C/H) Non-Fatal Error detected during Packet DMA */
        uint64_t gmii_ul_pkts_rcvd     : 1;  /**< [  4:  4](R/W1C/H) Packets received from the 4 lanes exceeded threshold */
        uint64_t axi_bad_wr_response_1 : 1;  /**< [  3:  3](R/W1C/H) Bad write response received from CONN004 IP#1 */
        uint64_t axi_bad_rd_response_1 : 1;  /**< [  2:  2](R/W1C/H) Bad read response received from IP#1 */
        uint64_t axi_bad_wr_response_0 : 1;  /**< [  1:  1](R/W1C/H) Bad write response received from CONN004 IP#0 */
        uint64_t axi_bad_rd_response_0 : 1;  /**< [  0:  0](R/W1C/H) Bad read response received from IP#0 */
#else /* Word 0 - Little Endian */
        uint64_t axi_bad_rd_response_0 : 1;  /**< [  0:  0](R/W1C/H) Bad read response received from IP#0 */
        uint64_t axi_bad_wr_response_0 : 1;  /**< [  1:  1](R/W1C/H) Bad write response received from CONN004 IP#0 */
        uint64_t axi_bad_rd_response_1 : 1;  /**< [  2:  2](R/W1C/H) Bad read response received from IP#1 */
        uint64_t axi_bad_wr_response_1 : 1;  /**< [  3:  3](R/W1C/H) Bad write response received from CONN004 IP#1 */
        uint64_t gmii_ul_pkts_rcvd     : 1;  /**< [  4:  4](R/W1C/H) Packets received from the 4 lanes exceeded threshold */
        uint64_t gmii_ul_pkt_dma_nferr : 1;  /**< [  5:  5](R/W1C/H) Non-Fatal Error detected during Packet DMA */
        uint64_t gmii_ul_pkt_dma_ferr  : 1;  /**< [  6:  6](R/W1C/H) Fatal Error detected during Packet DMA */
        uint64_t ul_rp3_dma_nferr      : 1;  /**< [  7:  7](R/W1C/H) Non-Fatal Error detected during RP3 DMA */
        uint64_t ul_rp3_dma_ferr       : 1;  /**< [  8:  8](R/W1C/H) Fatal Error detected during RP3 DMA */
        uint64_t ul_pkt_fifo_ovfl      : 1;  /**< [  9:  9](R/W1C/H) GMII UL FIFO overflow err inside RXDMA module */
        uint64_t ul_rp3_fifo_ovfl      : 1;  /**< [ 10: 10](R/W1C/H) RP3 UL FIFO overflow error inside RXDMA module */
        uint64_t gmii_dl_pkt_dma_nferr : 1;  /**< [ 11: 11](R/W1C/H) Non-Fatal Error detected during Packet DMA */
        uint64_t gmii_dl_pkt_dma_ferr  : 1;  /**< [ 12: 12](R/W1C/H) Fatal Error detected during Packet DMA */
        uint64_t dl_rp3_dma_nferr      : 1;  /**< [ 13: 13](R/W1C/H) Non-Fatal Error detected during RP3 DMA */
        uint64_t dl_rp3_dma_ferr       : 1;  /**< [ 14: 14](R/W1C/H) Fatal Error detected during RP3 DMA */
        uint64_t dl_rp3_fifo_ovfl      : 1;  /**< [ 15: 15](R/W1C/H) RP3 DL Request Fifo overflow inside TXDMA module */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_mhb_int_s cn; */
};
typedef union cavm_cprix_mhb_int cavm_cprix_mhb_int_t;

static inline uint64_t CAVM_CPRIX_MHB_INT(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_MHB_INT(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x8640000001a0ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_MHB_INT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_MHB_INT(a) cavm_cprix_mhb_int_t
#define bustype_CAVM_CPRIX_MHB_INT(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_MHB_INT(a) "CPRIX_MHB_INT"
#define busnum_CAVM_CPRIX_MHB_INT(a) (a)
#define arguments_CAVM_CPRIX_MHB_INT(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_mhb_int_ena_w1c
 *
 * INTERNAL: CPRI MHB Interrupt Enable Clear Register
 *
 * This register clears interrupt enable bits.
 */
union cavm_cprix_mhb_int_ena_w1c
{
    uint64_t u;
    struct cavm_cprix_mhb_int_ena_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t dl_rp3_fifo_ovfl      : 1;  /**< [ 15: 15](R/W1C/H) Reads or clears enable for CPRI(0..2)_MHB_INT[DL_RP3_FIFO_OVFL]. */
        uint64_t dl_rp3_dma_ferr       : 1;  /**< [ 14: 14](R/W1C/H) Reads or clears enable for CPRI(0..2)_MHB_INT[DL_RP3_DMA_FERR]. */
        uint64_t dl_rp3_dma_nferr      : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for CPRI(0..2)_MHB_INT[DL_RP3_DMA_NFERR]. */
        uint64_t gmii_dl_pkt_dma_ferr  : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for CPRI(0..2)_MHB_INT[GMII_DL_PKT_DMA_FERR]. */
        uint64_t gmii_dl_pkt_dma_nferr : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for CPRI(0..2)_MHB_INT[GMII_DL_PKT_DMA_NFERR]. */
        uint64_t ul_rp3_fifo_ovfl      : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for CPRI(0..2)_MHB_INT[UL_RP3_FIFO_OVFL]. */
        uint64_t ul_pkt_fifo_ovfl      : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for CPRI(0..2)_MHB_INT[UL_PKT_FIFO_OVFL]. */
        uint64_t ul_rp3_dma_ferr       : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for CPRI(0..2)_MHB_INT[UL_RP3_DMA_FERR]. */
        uint64_t ul_rp3_dma_nferr      : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for CPRI(0..2)_MHB_INT[UL_RP3_DMA_NFERR]. */
        uint64_t gmii_ul_pkt_dma_ferr  : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for CPRI(0..2)_MHB_INT[GMII_UL_PKT_DMA_FERR]. */
        uint64_t gmii_ul_pkt_dma_nferr : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CPRI(0..2)_MHB_INT[GMII_UL_PKT_DMA_NFERR]. */
        uint64_t gmii_ul_pkts_rcvd     : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CPRI(0..2)_MHB_INT[GMII_UL_PKTS_RCVD]. */
        uint64_t axi_bad_wr_response_1 : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CPRI(0..2)_MHB_INT[AXI_BAD_WR_RESPONSE_1]. */
        uint64_t axi_bad_rd_response_1 : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CPRI(0..2)_MHB_INT[AXI_BAD_RD_RESPONSE_1]. */
        uint64_t axi_bad_wr_response_0 : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CPRI(0..2)_MHB_INT[AXI_BAD_WR_RESPONSE_0]. */
        uint64_t axi_bad_rd_response_0 : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CPRI(0..2)_MHB_INT[AXI_BAD_RD_RESPONSE_0]. */
#else /* Word 0 - Little Endian */
        uint64_t axi_bad_rd_response_0 : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CPRI(0..2)_MHB_INT[AXI_BAD_RD_RESPONSE_0]. */
        uint64_t axi_bad_wr_response_0 : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CPRI(0..2)_MHB_INT[AXI_BAD_WR_RESPONSE_0]. */
        uint64_t axi_bad_rd_response_1 : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CPRI(0..2)_MHB_INT[AXI_BAD_RD_RESPONSE_1]. */
        uint64_t axi_bad_wr_response_1 : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CPRI(0..2)_MHB_INT[AXI_BAD_WR_RESPONSE_1]. */
        uint64_t gmii_ul_pkts_rcvd     : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CPRI(0..2)_MHB_INT[GMII_UL_PKTS_RCVD]. */
        uint64_t gmii_ul_pkt_dma_nferr : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CPRI(0..2)_MHB_INT[GMII_UL_PKT_DMA_NFERR]. */
        uint64_t gmii_ul_pkt_dma_ferr  : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for CPRI(0..2)_MHB_INT[GMII_UL_PKT_DMA_FERR]. */
        uint64_t ul_rp3_dma_nferr      : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for CPRI(0..2)_MHB_INT[UL_RP3_DMA_NFERR]. */
        uint64_t ul_rp3_dma_ferr       : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for CPRI(0..2)_MHB_INT[UL_RP3_DMA_FERR]. */
        uint64_t ul_pkt_fifo_ovfl      : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for CPRI(0..2)_MHB_INT[UL_PKT_FIFO_OVFL]. */
        uint64_t ul_rp3_fifo_ovfl      : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for CPRI(0..2)_MHB_INT[UL_RP3_FIFO_OVFL]. */
        uint64_t gmii_dl_pkt_dma_nferr : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for CPRI(0..2)_MHB_INT[GMII_DL_PKT_DMA_NFERR]. */
        uint64_t gmii_dl_pkt_dma_ferr  : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for CPRI(0..2)_MHB_INT[GMII_DL_PKT_DMA_FERR]. */
        uint64_t dl_rp3_dma_nferr      : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for CPRI(0..2)_MHB_INT[DL_RP3_DMA_NFERR]. */
        uint64_t dl_rp3_dma_ferr       : 1;  /**< [ 14: 14](R/W1C/H) Reads or clears enable for CPRI(0..2)_MHB_INT[DL_RP3_DMA_FERR]. */
        uint64_t dl_rp3_fifo_ovfl      : 1;  /**< [ 15: 15](R/W1C/H) Reads or clears enable for CPRI(0..2)_MHB_INT[DL_RP3_FIFO_OVFL]. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_mhb_int_ena_w1c_s cn; */
};
typedef union cavm_cprix_mhb_int_ena_w1c cavm_cprix_mhb_int_ena_w1c_t;

static inline uint64_t CAVM_CPRIX_MHB_INT_ENA_W1C(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_MHB_INT_ENA_W1C(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x8640000001b0ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_MHB_INT_ENA_W1C", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_MHB_INT_ENA_W1C(a) cavm_cprix_mhb_int_ena_w1c_t
#define bustype_CAVM_CPRIX_MHB_INT_ENA_W1C(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_MHB_INT_ENA_W1C(a) "CPRIX_MHB_INT_ENA_W1C"
#define busnum_CAVM_CPRIX_MHB_INT_ENA_W1C(a) (a)
#define arguments_CAVM_CPRIX_MHB_INT_ENA_W1C(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_mhb_int_ena_w1s
 *
 * INTERNAL: CPRI MHB Interrupt Enable Set Register
 *
 * This register sets interrupt enable bits.
 */
union cavm_cprix_mhb_int_ena_w1s
{
    uint64_t u;
    struct cavm_cprix_mhb_int_ena_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t dl_rp3_fifo_ovfl      : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets enable for CPRI(0..2)_MHB_INT[DL_RP3_FIFO_OVFL]. */
        uint64_t dl_rp3_dma_ferr       : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets enable for CPRI(0..2)_MHB_INT[DL_RP3_DMA_FERR]. */
        uint64_t dl_rp3_dma_nferr      : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for CPRI(0..2)_MHB_INT[DL_RP3_DMA_NFERR]. */
        uint64_t gmii_dl_pkt_dma_ferr  : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for CPRI(0..2)_MHB_INT[GMII_DL_PKT_DMA_FERR]. */
        uint64_t gmii_dl_pkt_dma_nferr : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for CPRI(0..2)_MHB_INT[GMII_DL_PKT_DMA_NFERR]. */
        uint64_t ul_rp3_fifo_ovfl      : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for CPRI(0..2)_MHB_INT[UL_RP3_FIFO_OVFL]. */
        uint64_t ul_pkt_fifo_ovfl      : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for CPRI(0..2)_MHB_INT[UL_PKT_FIFO_OVFL]. */
        uint64_t ul_rp3_dma_ferr       : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for CPRI(0..2)_MHB_INT[UL_RP3_DMA_FERR]. */
        uint64_t ul_rp3_dma_nferr      : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for CPRI(0..2)_MHB_INT[UL_RP3_DMA_NFERR]. */
        uint64_t gmii_ul_pkt_dma_ferr  : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for CPRI(0..2)_MHB_INT[GMII_UL_PKT_DMA_FERR]. */
        uint64_t gmii_ul_pkt_dma_nferr : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CPRI(0..2)_MHB_INT[GMII_UL_PKT_DMA_NFERR]. */
        uint64_t gmii_ul_pkts_rcvd     : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CPRI(0..2)_MHB_INT[GMII_UL_PKTS_RCVD]. */
        uint64_t axi_bad_wr_response_1 : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CPRI(0..2)_MHB_INT[AXI_BAD_WR_RESPONSE_1]. */
        uint64_t axi_bad_rd_response_1 : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CPRI(0..2)_MHB_INT[AXI_BAD_RD_RESPONSE_1]. */
        uint64_t axi_bad_wr_response_0 : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CPRI(0..2)_MHB_INT[AXI_BAD_WR_RESPONSE_0]. */
        uint64_t axi_bad_rd_response_0 : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CPRI(0..2)_MHB_INT[AXI_BAD_RD_RESPONSE_0]. */
#else /* Word 0 - Little Endian */
        uint64_t axi_bad_rd_response_0 : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CPRI(0..2)_MHB_INT[AXI_BAD_RD_RESPONSE_0]. */
        uint64_t axi_bad_wr_response_0 : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CPRI(0..2)_MHB_INT[AXI_BAD_WR_RESPONSE_0]. */
        uint64_t axi_bad_rd_response_1 : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CPRI(0..2)_MHB_INT[AXI_BAD_RD_RESPONSE_1]. */
        uint64_t axi_bad_wr_response_1 : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CPRI(0..2)_MHB_INT[AXI_BAD_WR_RESPONSE_1]. */
        uint64_t gmii_ul_pkts_rcvd     : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CPRI(0..2)_MHB_INT[GMII_UL_PKTS_RCVD]. */
        uint64_t gmii_ul_pkt_dma_nferr : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CPRI(0..2)_MHB_INT[GMII_UL_PKT_DMA_NFERR]. */
        uint64_t gmii_ul_pkt_dma_ferr  : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for CPRI(0..2)_MHB_INT[GMII_UL_PKT_DMA_FERR]. */
        uint64_t ul_rp3_dma_nferr      : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for CPRI(0..2)_MHB_INT[UL_RP3_DMA_NFERR]. */
        uint64_t ul_rp3_dma_ferr       : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for CPRI(0..2)_MHB_INT[UL_RP3_DMA_FERR]. */
        uint64_t ul_pkt_fifo_ovfl      : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for CPRI(0..2)_MHB_INT[UL_PKT_FIFO_OVFL]. */
        uint64_t ul_rp3_fifo_ovfl      : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for CPRI(0..2)_MHB_INT[UL_RP3_FIFO_OVFL]. */
        uint64_t gmii_dl_pkt_dma_nferr : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for CPRI(0..2)_MHB_INT[GMII_DL_PKT_DMA_NFERR]. */
        uint64_t gmii_dl_pkt_dma_ferr  : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for CPRI(0..2)_MHB_INT[GMII_DL_PKT_DMA_FERR]. */
        uint64_t dl_rp3_dma_nferr      : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for CPRI(0..2)_MHB_INT[DL_RP3_DMA_NFERR]. */
        uint64_t dl_rp3_dma_ferr       : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets enable for CPRI(0..2)_MHB_INT[DL_RP3_DMA_FERR]. */
        uint64_t dl_rp3_fifo_ovfl      : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets enable for CPRI(0..2)_MHB_INT[DL_RP3_FIFO_OVFL]. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_mhb_int_ena_w1s_s cn; */
};
typedef union cavm_cprix_mhb_int_ena_w1s cavm_cprix_mhb_int_ena_w1s_t;

static inline uint64_t CAVM_CPRIX_MHB_INT_ENA_W1S(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_MHB_INT_ENA_W1S(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x8640000001a8ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_MHB_INT_ENA_W1S", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_MHB_INT_ENA_W1S(a) cavm_cprix_mhb_int_ena_w1s_t
#define bustype_CAVM_CPRIX_MHB_INT_ENA_W1S(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_MHB_INT_ENA_W1S(a) "CPRIX_MHB_INT_ENA_W1S"
#define busnum_CAVM_CPRIX_MHB_INT_ENA_W1S(a) (a)
#define arguments_CAVM_CPRIX_MHB_INT_ENA_W1S(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_mhb_int_psm_msg_w0
 *
 * INTERNAL: CPRI MHB Interrupt Message w0  Register
 *
 * JCA word 0 message to send on enabled MHB interrupt
 */
union cavm_cprix_mhb_int_psm_msg_w0
{
    uint64_t u;
    struct cavm_cprix_mhb_int_psm_msg_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t w0                    : 64; /**< [ 63:  0](R/W) Word 0 of JCA message. */
#else /* Word 0 - Little Endian */
        uint64_t w0                    : 64; /**< [ 63:  0](R/W) Word 0 of JCA message. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_mhb_int_psm_msg_w0_s cn; */
};
typedef union cavm_cprix_mhb_int_psm_msg_w0 cavm_cprix_mhb_int_psm_msg_w0_t;

static inline uint64_t CAVM_CPRIX_MHB_INT_PSM_MSG_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_MHB_INT_PSM_MSG_W0(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x8640000001d0ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_MHB_INT_PSM_MSG_W0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_MHB_INT_PSM_MSG_W0(a) cavm_cprix_mhb_int_psm_msg_w0_t
#define bustype_CAVM_CPRIX_MHB_INT_PSM_MSG_W0(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_MHB_INT_PSM_MSG_W0(a) "CPRIX_MHB_INT_PSM_MSG_W0"
#define busnum_CAVM_CPRIX_MHB_INT_PSM_MSG_W0(a) (a)
#define arguments_CAVM_CPRIX_MHB_INT_PSM_MSG_W0(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_mhb_int_psm_msg_w1
 *
 * INTERNAL: CPRI MHB Interrupt Message w1 Register
 *
 * JCA word 1 message to send on enabled MHB interrupt
 */
union cavm_cprix_mhb_int_psm_msg_w1
{
    uint64_t u;
    struct cavm_cprix_mhb_int_psm_msg_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t w1                    : 64; /**< [ 63:  0](R/W) Word 1 of JCA message. */
#else /* Word 0 - Little Endian */
        uint64_t w1                    : 64; /**< [ 63:  0](R/W) Word 1 of JCA message. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_mhb_int_psm_msg_w1_s cn; */
};
typedef union cavm_cprix_mhb_int_psm_msg_w1 cavm_cprix_mhb_int_psm_msg_w1_t;

static inline uint64_t CAVM_CPRIX_MHB_INT_PSM_MSG_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_MHB_INT_PSM_MSG_W1(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x8640000001d8ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_MHB_INT_PSM_MSG_W1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_MHB_INT_PSM_MSG_W1(a) cavm_cprix_mhb_int_psm_msg_w1_t
#define bustype_CAVM_CPRIX_MHB_INT_PSM_MSG_W1(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_MHB_INT_PSM_MSG_W1(a) "CPRIX_MHB_INT_PSM_MSG_W1"
#define busnum_CAVM_CPRIX_MHB_INT_PSM_MSG_W1(a) (a)
#define arguments_CAVM_CPRIX_MHB_INT_PSM_MSG_W1(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_mhb_int_w1s
 *
 * INTERNAL: CPRI MHB Interrupt Set Register
 *
 * This register sets interrupt bits.
 */
union cavm_cprix_mhb_int_w1s
{
    uint64_t u;
    struct cavm_cprix_mhb_int_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t dl_rp3_fifo_ovfl      : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets CPRI(0..2)_MHB_INT[DL_RP3_FIFO_OVFL]. */
        uint64_t dl_rp3_dma_ferr       : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets CPRI(0..2)_MHB_INT[DL_RP3_DMA_FERR]. */
        uint64_t dl_rp3_dma_nferr      : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets CPRI(0..2)_MHB_INT[DL_RP3_DMA_NFERR]. */
        uint64_t gmii_dl_pkt_dma_ferr  : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets CPRI(0..2)_MHB_INT[GMII_DL_PKT_DMA_FERR]. */
        uint64_t gmii_dl_pkt_dma_nferr : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets CPRI(0..2)_MHB_INT[GMII_DL_PKT_DMA_NFERR]. */
        uint64_t ul_rp3_fifo_ovfl      : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets CPRI(0..2)_MHB_INT[UL_RP3_FIFO_OVFL]. */
        uint64_t ul_pkt_fifo_ovfl      : 1;  /**< [  9:  9](R/W1S/H) Reads or sets CPRI(0..2)_MHB_INT[UL_PKT_FIFO_OVFL]. */
        uint64_t ul_rp3_dma_ferr       : 1;  /**< [  8:  8](R/W1S/H) Reads or sets CPRI(0..2)_MHB_INT[UL_RP3_DMA_FERR]. */
        uint64_t ul_rp3_dma_nferr      : 1;  /**< [  7:  7](R/W1S/H) Reads or sets CPRI(0..2)_MHB_INT[UL_RP3_DMA_NFERR]. */
        uint64_t gmii_ul_pkt_dma_ferr  : 1;  /**< [  6:  6](R/W1S/H) Reads or sets CPRI(0..2)_MHB_INT[GMII_UL_PKT_DMA_FERR]. */
        uint64_t gmii_ul_pkt_dma_nferr : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CPRI(0..2)_MHB_INT[GMII_UL_PKT_DMA_NFERR]. */
        uint64_t gmii_ul_pkts_rcvd     : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CPRI(0..2)_MHB_INT[GMII_UL_PKTS_RCVD]. */
        uint64_t axi_bad_wr_response_1 : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CPRI(0..2)_MHB_INT[AXI_BAD_WR_RESPONSE_1]. */
        uint64_t axi_bad_rd_response_1 : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CPRI(0..2)_MHB_INT[AXI_BAD_RD_RESPONSE_1]. */
        uint64_t axi_bad_wr_response_0 : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CPRI(0..2)_MHB_INT[AXI_BAD_WR_RESPONSE_0]. */
        uint64_t axi_bad_rd_response_0 : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CPRI(0..2)_MHB_INT[AXI_BAD_RD_RESPONSE_0]. */
#else /* Word 0 - Little Endian */
        uint64_t axi_bad_rd_response_0 : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CPRI(0..2)_MHB_INT[AXI_BAD_RD_RESPONSE_0]. */
        uint64_t axi_bad_wr_response_0 : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CPRI(0..2)_MHB_INT[AXI_BAD_WR_RESPONSE_0]. */
        uint64_t axi_bad_rd_response_1 : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CPRI(0..2)_MHB_INT[AXI_BAD_RD_RESPONSE_1]. */
        uint64_t axi_bad_wr_response_1 : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CPRI(0..2)_MHB_INT[AXI_BAD_WR_RESPONSE_1]. */
        uint64_t gmii_ul_pkts_rcvd     : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CPRI(0..2)_MHB_INT[GMII_UL_PKTS_RCVD]. */
        uint64_t gmii_ul_pkt_dma_nferr : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CPRI(0..2)_MHB_INT[GMII_UL_PKT_DMA_NFERR]. */
        uint64_t gmii_ul_pkt_dma_ferr  : 1;  /**< [  6:  6](R/W1S/H) Reads or sets CPRI(0..2)_MHB_INT[GMII_UL_PKT_DMA_FERR]. */
        uint64_t ul_rp3_dma_nferr      : 1;  /**< [  7:  7](R/W1S/H) Reads or sets CPRI(0..2)_MHB_INT[UL_RP3_DMA_NFERR]. */
        uint64_t ul_rp3_dma_ferr       : 1;  /**< [  8:  8](R/W1S/H) Reads or sets CPRI(0..2)_MHB_INT[UL_RP3_DMA_FERR]. */
        uint64_t ul_pkt_fifo_ovfl      : 1;  /**< [  9:  9](R/W1S/H) Reads or sets CPRI(0..2)_MHB_INT[UL_PKT_FIFO_OVFL]. */
        uint64_t ul_rp3_fifo_ovfl      : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets CPRI(0..2)_MHB_INT[UL_RP3_FIFO_OVFL]. */
        uint64_t gmii_dl_pkt_dma_nferr : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets CPRI(0..2)_MHB_INT[GMII_DL_PKT_DMA_NFERR]. */
        uint64_t gmii_dl_pkt_dma_ferr  : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets CPRI(0..2)_MHB_INT[GMII_DL_PKT_DMA_FERR]. */
        uint64_t dl_rp3_dma_nferr      : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets CPRI(0..2)_MHB_INT[DL_RP3_DMA_NFERR]. */
        uint64_t dl_rp3_dma_ferr       : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets CPRI(0..2)_MHB_INT[DL_RP3_DMA_FERR]. */
        uint64_t dl_rp3_fifo_ovfl      : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets CPRI(0..2)_MHB_INT[DL_RP3_FIFO_OVFL]. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_mhb_int_w1s_s cn; */
};
typedef union cavm_cprix_mhb_int_w1s cavm_cprix_mhb_int_w1s_t;

static inline uint64_t CAVM_CPRIX_MHB_INT_W1S(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_MHB_INT_W1S(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x8640000001b8ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_MHB_INT_W1S", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_MHB_INT_W1S(a) cavm_cprix_mhb_int_w1s_t
#define bustype_CAVM_CPRIX_MHB_INT_W1S(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_MHB_INT_W1S(a) "CPRIX_MHB_INT_W1S"
#define busnum_CAVM_CPRIX_MHB_INT_W1S(a) (a)
#define arguments_CAVM_CPRIX_MHB_INT_W1S(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_rp3_dl_axc_ba_cfg
 *
 * CPRI RP3 DL AXC Buffer Address Configuration Register
 */
union cavm_cprix_rp3_dl_axc_ba_cfg
{
    uint64_t u;
    struct cavm_cprix_rp3_dl_axc_ba_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_53_63        : 11;
        uint64_t buf_addr              : 53; /**< [ 52:  0](R/W) DL AXC buffer base address. Note this is a byte address and the 4 LSB are always considered as 0. */
#else /* Word 0 - Little Endian */
        uint64_t buf_addr              : 53; /**< [ 52:  0](R/W) DL AXC buffer base address. Note this is a byte address and the 4 LSB are always considered as 0. */
        uint64_t reserved_53_63        : 11;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_rp3_dl_axc_ba_cfg_s cn; */
};
typedef union cavm_cprix_rp3_dl_axc_ba_cfg cavm_cprix_rp3_dl_axc_ba_cfg_t;

static inline uint64_t CAVM_CPRIX_RP3_DL_AXC_BA_CFG(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_RP3_DL_AXC_BA_CFG(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x864000002048ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_RP3_DL_AXC_BA_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_RP3_DL_AXC_BA_CFG(a) cavm_cprix_rp3_dl_axc_ba_cfg_t
#define bustype_CAVM_CPRIX_RP3_DL_AXC_BA_CFG(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_RP3_DL_AXC_BA_CFG(a) "CPRIX_RP3_DL_AXC_BA_CFG"
#define busnum_CAVM_CPRIX_RP3_DL_AXC_BA_CFG(a) (a)
#define arguments_CAVM_CPRIX_RP3_DL_AXC_BA_CFG(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_rp3_dl_ctrl_cfg0
 *
 * CPRI RP3 DL Control Configuration Register
 */
union cavm_cprix_rp3_dl_ctrl_cfg0
{
    uint64_t u;
    struct cavm_cprix_rp3_dl_ctrl_cfg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t buf_idx               : 8;  /**< [ 31: 24](R/W) AXC buffer index. Must be in the range [128:191]. Otherwise, will result in unpredictable behavior. */
        uint64_t reserved_9_23         : 15;
        uint64_t dest_cpri_ip          : 1;  /**< [  8:  8](R/W) Indicates to send the RP3 messages for a given AXC to the CPRI IP 0 or 1. */
        uint64_t reserved_1_7          : 7;
        uint64_t buf_enable            : 1;  /**< [  0:  0](R/W) Enable buffering the DL RP3 messages to send to CPRI_IP. */
#else /* Word 0 - Little Endian */
        uint64_t buf_enable            : 1;  /**< [  0:  0](R/W) Enable buffering the DL RP3 messages to send to CPRI_IP. */
        uint64_t reserved_1_7          : 7;
        uint64_t dest_cpri_ip          : 1;  /**< [  8:  8](R/W) Indicates to send the RP3 messages for a given AXC to the CPRI IP 0 or 1. */
        uint64_t reserved_9_23         : 15;
        uint64_t buf_idx               : 8;  /**< [ 31: 24](R/W) AXC buffer index. Must be in the range [128:191]. Otherwise, will result in unpredictable behavior. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_rp3_dl_ctrl_cfg0_s cn; */
};
typedef union cavm_cprix_rp3_dl_ctrl_cfg0 cavm_cprix_rp3_dl_ctrl_cfg0_t;

static inline uint64_t CAVM_CPRIX_RP3_DL_CTRL_CFG0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_RP3_DL_CTRL_CFG0(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x864000010068ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_RP3_DL_CTRL_CFG0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_RP3_DL_CTRL_CFG0(a) cavm_cprix_rp3_dl_ctrl_cfg0_t
#define bustype_CAVM_CPRIX_RP3_DL_CTRL_CFG0(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_RP3_DL_CTRL_CFG0(a) "CPRIX_RP3_DL_CTRL_CFG0"
#define busnum_CAVM_CPRIX_RP3_DL_CTRL_CFG0(a) (a)
#define arguments_CAVM_CPRIX_RP3_DL_CTRL_CFG0(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_rp3_dl_ctrl_data0
 *
 * CPRI RP3 DL Control Data0 Register
 */
union cavm_cprix_rp3_dl_ctrl_data0
{
    uint64_t u;
    struct cavm_cprix_rp3_dl_ctrl_data0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) RP3 DL CSR Control Message Data[63:0]. */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) RP3 DL CSR Control Message Data[63:0]. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_rp3_dl_ctrl_data0_s cn; */
};
typedef union cavm_cprix_rp3_dl_ctrl_data0 cavm_cprix_rp3_dl_ctrl_data0_t;

static inline uint64_t CAVM_CPRIX_RP3_DL_CTRL_DATA0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_RP3_DL_CTRL_DATA0(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x864000010070ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_RP3_DL_CTRL_DATA0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_RP3_DL_CTRL_DATA0(a) cavm_cprix_rp3_dl_ctrl_data0_t
#define bustype_CAVM_CPRIX_RP3_DL_CTRL_DATA0(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_RP3_DL_CTRL_DATA0(a) "CPRIX_RP3_DL_CTRL_DATA0"
#define busnum_CAVM_CPRIX_RP3_DL_CTRL_DATA0(a) (a)
#define arguments_CAVM_CPRIX_RP3_DL_CTRL_DATA0(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_rp3_dl_ctrl_data1
 *
 * CPRI RP3 DL Control Data1 Register
 */
union cavm_cprix_rp3_dl_ctrl_data1
{
    uint64_t u;
    struct cavm_cprix_rp3_dl_ctrl_data1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) RP3 DL CSR Control Message Data[127:64]. */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) RP3 DL CSR Control Message Data[127:64]. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_rp3_dl_ctrl_data1_s cn; */
};
typedef union cavm_cprix_rp3_dl_ctrl_data1 cavm_cprix_rp3_dl_ctrl_data1_t;

static inline uint64_t CAVM_CPRIX_RP3_DL_CTRL_DATA1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_RP3_DL_CTRL_DATA1(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x864000010078ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_RP3_DL_CTRL_DATA1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_RP3_DL_CTRL_DATA1(a) cavm_cprix_rp3_dl_ctrl_data1_t
#define bustype_CAVM_CPRIX_RP3_DL_CTRL_DATA1(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_RP3_DL_CTRL_DATA1(a) "CPRIX_RP3_DL_CTRL_DATA1"
#define busnum_CAVM_CPRIX_RP3_DL_CTRL_DATA1(a) (a)
#define arguments_CAVM_CPRIX_RP3_DL_CTRL_DATA1(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_rp3_dl_ctrl_data2
 *
 * CPRI RP3 DL Control Data2 Register
 */
union cavm_cprix_rp3_dl_ctrl_data2
{
    uint64_t u;
    struct cavm_cprix_rp3_dl_ctrl_data2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_24_63        : 40;
        uint64_t data                  : 24; /**< [ 23:  0](R/W) RP3 DL CSR Control Message Data[151:128]. */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 24; /**< [ 23:  0](R/W) RP3 DL CSR Control Message Data[151:128]. */
        uint64_t reserved_24_63        : 40;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_rp3_dl_ctrl_data2_s cn; */
};
typedef union cavm_cprix_rp3_dl_ctrl_data2 cavm_cprix_rp3_dl_ctrl_data2_t;

static inline uint64_t CAVM_CPRIX_RP3_DL_CTRL_DATA2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_RP3_DL_CTRL_DATA2(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x864000010080ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_RP3_DL_CTRL_DATA2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_RP3_DL_CTRL_DATA2(a) cavm_cprix_rp3_dl_ctrl_data2_t
#define bustype_CAVM_CPRIX_RP3_DL_CTRL_DATA2(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_RP3_DL_CTRL_DATA2(a) "CPRIX_RP3_DL_CTRL_DATA2"
#define busnum_CAVM_CPRIX_RP3_DL_CTRL_DATA2(a) (a)
#define arguments_CAVM_CPRIX_RP3_DL_CTRL_DATA2(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_rp3_dl_ip#_axc_cfg0#
 *
 * CPRI RP3 DL AXC Configuration Register
 * RP3 Downlink AxC Configuration Register0 for CPRI_IP Ports 0 and 1.
 */
union cavm_cprix_rp3_dl_ipx_axc_cfg0x
{
    uint64_t u;
    struct cavm_cprix_rp3_dl_ipx_axc_cfg0x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_57_63        : 7;
        uint64_t ts_store              : 5;  /**< [ 56: 52](RO/H) Stored timestamp value to be used.in next message if needed. */
        uint64_t reserved_49_51        : 3;
        uint64_t repl_type             : 5;  /**< [ 48: 44](R/W) Replacement RP3 message type field when a message is routed (SW_ENABLE=1) to another CPRI lane. */
        uint64_t reserved_41_43        : 3;
        uint64_t repl_addr             : 13; /**< [ 40: 28](R/W) Replacement RP3 message address field when a message is routed (SW_ENABLE=1) to another CPRI lane. */
        uint64_t msg_cnt               : 16; /**< [ 27: 12](RO/H) Current message count ready to be sent (when Switch is enabled). Count written on Switch
                                                                 Message Type 1 from the Read Count field and decremented when message data are
                                                                 read out to be sent to the CPRI IP port. */
        uint64_t reserved_8_11         : 4;
        uint64_t data_swap             : 3;  /**< [  7:  5](R/W) Byte swap enable. */
        uint64_t dest_mem              : 1;  /**< [  4:  4](R/W) Destination memory:
                                                                 0 = SMEM.
                                                                 1 = LLC/DRAM. */
        uint64_t cmd_type              : 2;  /**< [  3:  2](R/W) Write DMA command type. */
        uint64_t sw_enable             : 1;  /**< [  1:  1](R/W) Enable switching the DL RP3 messages from another CPRI lane. */
        uint64_t buf_enable            : 1;  /**< [  0:  0](R/W) Enable reading the DL RP3 messages to memory. */
#else /* Word 0 - Little Endian */
        uint64_t buf_enable            : 1;  /**< [  0:  0](R/W) Enable reading the DL RP3 messages to memory. */
        uint64_t sw_enable             : 1;  /**< [  1:  1](R/W) Enable switching the DL RP3 messages from another CPRI lane. */
        uint64_t cmd_type              : 2;  /**< [  3:  2](R/W) Write DMA command type. */
        uint64_t dest_mem              : 1;  /**< [  4:  4](R/W) Destination memory:
                                                                 0 = SMEM.
                                                                 1 = LLC/DRAM. */
        uint64_t data_swap             : 3;  /**< [  7:  5](R/W) Byte swap enable. */
        uint64_t reserved_8_11         : 4;
        uint64_t msg_cnt               : 16; /**< [ 27: 12](RO/H) Current message count ready to be sent (when Switch is enabled). Count written on Switch
                                                                 Message Type 1 from the Read Count field and decremented when message data are
                                                                 read out to be sent to the CPRI IP port. */
        uint64_t repl_addr             : 13; /**< [ 40: 28](R/W) Replacement RP3 message address field when a message is routed (SW_ENABLE=1) to another CPRI lane. */
        uint64_t reserved_41_43        : 3;
        uint64_t repl_type             : 5;  /**< [ 48: 44](R/W) Replacement RP3 message type field when a message is routed (SW_ENABLE=1) to another CPRI lane. */
        uint64_t reserved_49_51        : 3;
        uint64_t ts_store              : 5;  /**< [ 56: 52](RO/H) Stored timestamp value to be used.in next message if needed. */
        uint64_t reserved_57_63        : 7;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_rp3_dl_ipx_axc_cfg0x_s cn; */
};
typedef union cavm_cprix_rp3_dl_ipx_axc_cfg0x cavm_cprix_rp3_dl_ipx_axc_cfg0x_t;

static inline uint64_t CAVM_CPRIX_RP3_DL_IPX_AXC_CFG0X(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_RP3_DL_IPX_AXC_CFG0X(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=127)))
        return 0x864000010030ll + 0x1000000000ll * ((a) & 0x3) + 0x8000ll * ((b) & 0x1) + 0x100ll * ((c) & 0x7f);
    __cavm_csr_fatal("CPRIX_RP3_DL_IPX_AXC_CFG0X", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_RP3_DL_IPX_AXC_CFG0X(a,b,c) cavm_cprix_rp3_dl_ipx_axc_cfg0x_t
#define bustype_CAVM_CPRIX_RP3_DL_IPX_AXC_CFG0X(a,b,c) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_RP3_DL_IPX_AXC_CFG0X(a,b,c) "CPRIX_RP3_DL_IPX_AXC_CFG0X"
#define busnum_CAVM_CPRIX_RP3_DL_IPX_AXC_CFG0X(a,b,c) (a)
#define arguments_CAVM_CPRIX_RP3_DL_IPX_AXC_CFG0X(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB) cpri#_rp3_dl_ip#_axc_cfg1#
 *
 * CPRI RP3 DL AXC Configuration Register
 * RP3 Downlink AxC Configuration Register1 For CPRI_IP Ports 0 and 1.
 */
union cavm_cprix_rp3_dl_ipx_axc_cfg1x
{
    uint64_t u;
    struct cavm_cprix_rp3_dl_ipx_axc_cfg1x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t buf_rptr_offset       : 16; /**< [ 47: 32](R/W) AXC buffer write pointer offset in the circular buffer indicated by the BUF_IDX. */
        uint64_t buf_idx               : 8;  /**< [ 31: 24](R/W) AXC buffer index. */
        uint64_t bcn_st                : 24; /**< [ 23:  0](R/W) BCN start time to fetch the first AXC sample from memory. */
#else /* Word 0 - Little Endian */
        uint64_t bcn_st                : 24; /**< [ 23:  0](R/W) BCN start time to fetch the first AXC sample from memory. */
        uint64_t buf_idx               : 8;  /**< [ 31: 24](R/W) AXC buffer index. */
        uint64_t buf_rptr_offset       : 16; /**< [ 47: 32](R/W) AXC buffer write pointer offset in the circular buffer indicated by the BUF_IDX. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_rp3_dl_ipx_axc_cfg1x_s cn; */
};
typedef union cavm_cprix_rp3_dl_ipx_axc_cfg1x cavm_cprix_rp3_dl_ipx_axc_cfg1x_t;

static inline uint64_t CAVM_CPRIX_RP3_DL_IPX_AXC_CFG1X(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_RP3_DL_IPX_AXC_CFG1X(unsigned long a, unsigned long b, unsigned long c)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=1) && (c<=127)))
        return 0x864000010038ll + 0x1000000000ll * ((a) & 0x3) + 0x8000ll * ((b) & 0x1) + 0x100ll * ((c) & 0x7f);
    __cavm_csr_fatal("CPRIX_RP3_DL_IPX_AXC_CFG1X", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_RP3_DL_IPX_AXC_CFG1X(a,b,c) cavm_cprix_rp3_dl_ipx_axc_cfg1x_t
#define bustype_CAVM_CPRIX_RP3_DL_IPX_AXC_CFG1X(a,b,c) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_RP3_DL_IPX_AXC_CFG1X(a,b,c) "CPRIX_RP3_DL_IPX_AXC_CFG1X"
#define busnum_CAVM_CPRIX_RP3_DL_IPX_AXC_CFG1X(a,b,c) (a)
#define arguments_CAVM_CPRIX_RP3_DL_IPX_AXC_CFG1X(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB) cpri#_rp3_ul_axc_ba_cfg
 *
 * CPRI RP3 UL AXC Buffer Address Configuration Register
 */
union cavm_cprix_rp3_ul_axc_ba_cfg
{
    uint64_t u;
    struct cavm_cprix_rp3_ul_axc_ba_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_53_63        : 11;
        uint64_t buf_addr              : 53; /**< [ 52:  0](R/W) UL AXC buffer base address. Note this is a byte address and the 4 LSB are always considered as 0. */
#else /* Word 0 - Little Endian */
        uint64_t buf_addr              : 53; /**< [ 52:  0](R/W) UL AXC buffer base address. Note this is a byte address and the 4 LSB are always considered as 0. */
        uint64_t reserved_53_63        : 11;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_rp3_ul_axc_ba_cfg_s cn; */
};
typedef union cavm_cprix_rp3_ul_axc_ba_cfg cavm_cprix_rp3_ul_axc_ba_cfg_t;

static inline uint64_t CAVM_CPRIX_RP3_UL_AXC_BA_CFG(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_RP3_UL_AXC_BA_CFG(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x864000002000ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_RP3_UL_AXC_BA_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_RP3_UL_AXC_BA_CFG(a) cavm_cprix_rp3_ul_axc_ba_cfg_t
#define bustype_CAVM_CPRIX_RP3_UL_AXC_BA_CFG(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_RP3_UL_AXC_BA_CFG(a) "CPRIX_RP3_UL_AXC_BA_CFG"
#define busnum_CAVM_CPRIX_RP3_UL_AXC_BA_CFG(a) (a)
#define arguments_CAVM_CPRIX_RP3_UL_AXC_BA_CFG(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_rp3_ul_axc_cfg0#
 *
 * CPRI RP3 UL AXC Configuration Register
 */
union cavm_cprix_rp3_ul_axc_cfg0x
{
    uint64_t u;
    struct cavm_cprix_rp3_ul_axc_cfg0x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_52_63        : 12;
        uint64_t buf_idx               : 8;  /**< [ 51: 44](R/W) AXC buffer index. */
        uint64_t msg_cnt               : 16; /**< [ 43: 28](R/W/H) Current message count sent. A notification is sent when the message count
                                                                 reaches the NOTIF_THRES and the count is reset at that time. */
        uint64_t notif_thres           : 16; /**< [ 27: 12](R/W) Message count threshold at which a notification is issued. The notification sent
                                                                 can be either an interrupt or a job descriptor.
                                                                 A value of 0 indicates that notifications are disabled. */
        uint64_t reserved_9_11         : 3;
        uint64_t notif_type            : 1;  /**< [  8:  8](R/W) The notification type sent after the message count threshold is reached.
                                                                 0x0 = interrupt.
                                                                 0x1 = job descriptor */
        uint64_t data_swap             : 3;  /**< [  7:  5](R/W) Byte swap enable. */
        uint64_t dest_mem              : 1;  /**< [  4:  4](R/W) Destination memory:
                                                                 0 = SMEM.
                                                                 1 = LLC/DRAM. */
        uint64_t cmd_type              : 2;  /**< [  3:  2](R/W) Write DMA command type. */
        uint64_t sw_enable             : 1;  /**< [  1:  1](R/W) Enable switching the UL RP3 messages to another CPRI lane. */
        uint64_t buf_enable            : 1;  /**< [  0:  0](R/W) Enable buffering the UL RP3 messages to memory. */
#else /* Word 0 - Little Endian */
        uint64_t buf_enable            : 1;  /**< [  0:  0](R/W) Enable buffering the UL RP3 messages to memory. */
        uint64_t sw_enable             : 1;  /**< [  1:  1](R/W) Enable switching the UL RP3 messages to another CPRI lane. */
        uint64_t cmd_type              : 2;  /**< [  3:  2](R/W) Write DMA command type. */
        uint64_t dest_mem              : 1;  /**< [  4:  4](R/W) Destination memory:
                                                                 0 = SMEM.
                                                                 1 = LLC/DRAM. */
        uint64_t data_swap             : 3;  /**< [  7:  5](R/W) Byte swap enable. */
        uint64_t notif_type            : 1;  /**< [  8:  8](R/W) The notification type sent after the message count threshold is reached.
                                                                 0x0 = interrupt.
                                                                 0x1 = job descriptor */
        uint64_t reserved_9_11         : 3;
        uint64_t notif_thres           : 16; /**< [ 27: 12](R/W) Message count threshold at which a notification is issued. The notification sent
                                                                 can be either an interrupt or a job descriptor.
                                                                 A value of 0 indicates that notifications are disabled. */
        uint64_t msg_cnt               : 16; /**< [ 43: 28](R/W/H) Current message count sent. A notification is sent when the message count
                                                                 reaches the NOTIF_THRES and the count is reset at that time. */
        uint64_t buf_idx               : 8;  /**< [ 51: 44](R/W) AXC buffer index. */
        uint64_t reserved_52_63        : 12;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_rp3_ul_axc_cfg0x_s cn; */
};
typedef union cavm_cprix_rp3_ul_axc_cfg0x cavm_cprix_rp3_ul_axc_cfg0x_t;

static inline uint64_t CAVM_CPRIX_RP3_UL_AXC_CFG0X(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_RP3_UL_AXC_CFG0X(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=255)))
        return 0x864000010000ll + 0x1000000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0xff);
    __cavm_csr_fatal("CPRIX_RP3_UL_AXC_CFG0X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_RP3_UL_AXC_CFG0X(a,b) cavm_cprix_rp3_ul_axc_cfg0x_t
#define bustype_CAVM_CPRIX_RP3_UL_AXC_CFG0X(a,b) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_RP3_UL_AXC_CFG0X(a,b) "CPRIX_RP3_UL_AXC_CFG0X"
#define busnum_CAVM_CPRIX_RP3_UL_AXC_CFG0X(a,b) (a)
#define arguments_CAVM_CPRIX_RP3_UL_AXC_CFG0X(a,b) (a),(b),-1,-1

/**
 * Register (NCB) cpri#_rp3_ul_axc_cfg1#
 *
 * CPRI RP3 UL AXC Configuration Register
 */
union cavm_cprix_rp3_ul_axc_cfg1x
{
    uint64_t u;
    struct cavm_cprix_rp3_ul_axc_cfg1x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t buf_wptr_offset       : 16; /**< [ 15:  0](R/W/H) AXC buffer write pointer offset in the circular buffer indicated by the BUF_IDX. */
#else /* Word 0 - Little Endian */
        uint64_t buf_wptr_offset       : 16; /**< [ 15:  0](R/W/H) AXC buffer write pointer offset in the circular buffer indicated by the BUF_IDX. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_rp3_ul_axc_cfg1x_s cn; */
};
typedef union cavm_cprix_rp3_ul_axc_cfg1x cavm_cprix_rp3_ul_axc_cfg1x_t;

static inline uint64_t CAVM_CPRIX_RP3_UL_AXC_CFG1X(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_RP3_UL_AXC_CFG1X(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=255)))
        return 0x864000010008ll + 0x1000000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0xff);
    __cavm_csr_fatal("CPRIX_RP3_UL_AXC_CFG1X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_RP3_UL_AXC_CFG1X(a,b) cavm_cprix_rp3_ul_axc_cfg1x_t
#define bustype_CAVM_CPRIX_RP3_UL_AXC_CFG1X(a,b) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_RP3_UL_AXC_CFG1X(a,b) "CPRIX_RP3_UL_AXC_CFG1X"
#define busnum_CAVM_CPRIX_RP3_UL_AXC_CFG1X(a,b) (a)
#define arguments_CAVM_CPRIX_RP3_UL_AXC_CFG1X(a,b) (a),(b),-1,-1

/**
 * Register (NCB) cpri#_rp3_ul_axc_jd_ba_cfg
 *
 * CPRI RP3 UL AXC Job Descriptor Buffer Base Address Configuration Register
 */
union cavm_cprix_rp3_ul_axc_jd_ba_cfg
{
    uint64_t u;
    struct cavm_cprix_rp3_ul_axc_jd_ba_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_53_63        : 11;
        uint64_t buf_addr              : 53; /**< [ 52:  0](R/W) Job descriptor buffer base address. Note this is a byte address and the 4 LSB
                                                                 are always considered as 0. */
#else /* Word 0 - Little Endian */
        uint64_t buf_addr              : 53; /**< [ 52:  0](R/W) Job descriptor buffer base address. Note this is a byte address and the 4 LSB
                                                                 are always considered as 0. */
        uint64_t reserved_53_63        : 11;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_rp3_ul_axc_jd_ba_cfg_s cn; */
};
typedef union cavm_cprix_rp3_ul_axc_jd_ba_cfg cavm_cprix_rp3_ul_axc_jd_ba_cfg_t;

static inline uint64_t CAVM_CPRIX_RP3_UL_AXC_JD_BA_CFG(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_RP3_UL_AXC_JD_BA_CFG(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x864000002028ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_RP3_UL_AXC_JD_BA_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_RP3_UL_AXC_JD_BA_CFG(a) cavm_cprix_rp3_ul_axc_jd_ba_cfg_t
#define bustype_CAVM_CPRIX_RP3_UL_AXC_JD_BA_CFG(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_RP3_UL_AXC_JD_BA_CFG(a) "CPRIX_RP3_UL_AXC_JD_BA_CFG"
#define busnum_CAVM_CPRIX_RP3_UL_AXC_JD_BA_CFG(a) (a)
#define arguments_CAVM_CPRIX_RP3_UL_AXC_JD_BA_CFG(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_rp3_ul_axc_jd_bs_cfg
 *
 * CPRI RP3 UL AXC Job Descriptor Buffer Base Size Configuration Register
 */
union cavm_cprix_rp3_ul_axc_jd_bs_cfg
{
    uint64_t u;
    struct cavm_cprix_rp3_ul_axc_jd_bs_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_24_63        : 40;
        uint64_t num_jd                : 8;  /**< [ 23: 16](R/W) Number of Job descritor buffers. */
        uint64_t jd_size               : 16; /**< [ 15:  0](R/W) Size of each job descriptor buffer dedicated to a given AXC. */
#else /* Word 0 - Little Endian */
        uint64_t jd_size               : 16; /**< [ 15:  0](R/W) Size of each job descriptor buffer dedicated to a given AXC. */
        uint64_t num_jd                : 8;  /**< [ 23: 16](R/W) Number of Job descritor buffers. */
        uint64_t reserved_24_63        : 40;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_rp3_ul_axc_jd_bs_cfg_s cn; */
};
typedef union cavm_cprix_rp3_ul_axc_jd_bs_cfg cavm_cprix_rp3_ul_axc_jd_bs_cfg_t;

static inline uint64_t CAVM_CPRIX_RP3_UL_AXC_JD_BS_CFG(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_RP3_UL_AXC_JD_BS_CFG(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x864000002030ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_RP3_UL_AXC_JD_BS_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_RP3_UL_AXC_JD_BS_CFG(a) cavm_cprix_rp3_ul_axc_jd_bs_cfg_t
#define bustype_CAVM_CPRIX_RP3_UL_AXC_JD_BS_CFG(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_RP3_UL_AXC_JD_BS_CFG(a) "CPRIX_RP3_UL_AXC_JD_BS_CFG"
#define busnum_CAVM_CPRIX_RP3_UL_AXC_JD_BS_CFG(a) (a)
#define arguments_CAVM_CPRIX_RP3_UL_AXC_JD_BS_CFG(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_rp3_ul_axc_jd_cfg#
 *
 * CPRI RP3 AXC UL Job Descriptor Configuration Register
 */
union cavm_cprix_rp3_ul_axc_jd_cfgx
{
    uint64_t u;
    struct cavm_cprix_rp3_ul_axc_jd_cfgx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_36_63        : 28;
        uint64_t jd_wptr               : 16; /**< [ 35: 20](R/W) Write pointer within an AXC job descriptor buffer. */
        uint64_t next_jd_ptr           : 8;  /**< [ 19: 12](R/W) Next job descriptor pointer, which wraps around at NUM_JD. */
        uint64_t jd_buf_idx            : 8;  /**< [ 11:  4](R/W) Job descriptor buffer index for a given AXC. There are 256 buffers of size JD_SIZE
                                                                 128-bit entries. */
        uint64_t reserved_1_3          : 3;
        uint64_t jd_enable             : 1;  /**< [  0:  0](R/W) Job descriptor enable. */
#else /* Word 0 - Little Endian */
        uint64_t jd_enable             : 1;  /**< [  0:  0](R/W) Job descriptor enable. */
        uint64_t reserved_1_3          : 3;
        uint64_t jd_buf_idx            : 8;  /**< [ 11:  4](R/W) Job descriptor buffer index for a given AXC. There are 256 buffers of size JD_SIZE
                                                                 128-bit entries. */
        uint64_t next_jd_ptr           : 8;  /**< [ 19: 12](R/W) Next job descriptor pointer, which wraps around at NUM_JD. */
        uint64_t jd_wptr               : 16; /**< [ 35: 20](R/W) Write pointer within an AXC job descriptor buffer. */
        uint64_t reserved_36_63        : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_rp3_ul_axc_jd_cfgx_s cn; */
};
typedef union cavm_cprix_rp3_ul_axc_jd_cfgx cavm_cprix_rp3_ul_axc_jd_cfgx_t;

static inline uint64_t CAVM_CPRIX_RP3_UL_AXC_JD_CFGX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_RP3_UL_AXC_JD_CFGX(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=255)))
        return 0x864000010018ll + 0x1000000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0xff);
    __cavm_csr_fatal("CPRIX_RP3_UL_AXC_JD_CFGX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_RP3_UL_AXC_JD_CFGX(a,b) cavm_cprix_rp3_ul_axc_jd_cfgx_t
#define bustype_CAVM_CPRIX_RP3_UL_AXC_JD_CFGX(a,b) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_RP3_UL_AXC_JD_CFGX(a,b) "CPRIX_RP3_UL_AXC_JD_CFGX"
#define busnum_CAVM_CPRIX_RP3_UL_AXC_JD_CFGX(a,b) (a)
#define arguments_CAVM_CPRIX_RP3_UL_AXC_JD_CFGX(a,b) (a),(b),-1,-1

/**
 * Register (NCB) cpri#_rp3_ul_axc_map0#
 *
 * CPRI RP3 UL AXC MAP for port 0 Register
 */
union cavm_cprix_rp3_ul_axc_map0x
{
    uint64_t u;
    struct cavm_cprix_rp3_ul_axc_map0x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_24_63        : 40;
        uint64_t axc_id                : 8;  /**< [ 23: 16](R/W) AXC ID associated wit the RP3 UL address (ADDR). */
        uint64_t reserved_13_15        : 3;
        uint64_t addr                  : 13; /**< [ 12:  0](R/W) RP3 UL address associated with the AXC ID (AXC_ID). */
#else /* Word 0 - Little Endian */
        uint64_t addr                  : 13; /**< [ 12:  0](R/W) RP3 UL address associated with the AXC ID (AXC_ID). */
        uint64_t reserved_13_15        : 3;
        uint64_t axc_id                : 8;  /**< [ 23: 16](R/W) AXC ID associated wit the RP3 UL address (ADDR). */
        uint64_t reserved_24_63        : 40;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_rp3_ul_axc_map0x_s cn; */
};
typedef union cavm_cprix_rp3_ul_axc_map0x cavm_cprix_rp3_ul_axc_map0x_t;

static inline uint64_t CAVM_CPRIX_RP3_UL_AXC_MAP0X(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_RP3_UL_AXC_MAP0X(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=127)))
        return 0x864000010040ll + 0x1000000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x7f);
    __cavm_csr_fatal("CPRIX_RP3_UL_AXC_MAP0X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_RP3_UL_AXC_MAP0X(a,b) cavm_cprix_rp3_ul_axc_map0x_t
#define bustype_CAVM_CPRIX_RP3_UL_AXC_MAP0X(a,b) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_RP3_UL_AXC_MAP0X(a,b) "CPRIX_RP3_UL_AXC_MAP0X"
#define busnum_CAVM_CPRIX_RP3_UL_AXC_MAP0X(a,b) (a)
#define arguments_CAVM_CPRIX_RP3_UL_AXC_MAP0X(a,b) (a),(b),-1,-1

/**
 * Register (NCB) cpri#_rp3_ul_axc_map1#
 *
 * CPRI RP3 UL AXC MAP for port 1 Register
 */
union cavm_cprix_rp3_ul_axc_map1x
{
    uint64_t u;
    struct cavm_cprix_rp3_ul_axc_map1x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_24_63        : 40;
        uint64_t axc_id                : 8;  /**< [ 23: 16](R/W) AXC ID associated wit the RP3 UL address (ADDR). */
        uint64_t reserved_13_15        : 3;
        uint64_t addr                  : 13; /**< [ 12:  0](R/W) RP3 UL address associated with the AXC ID (AXC_ID). */
#else /* Word 0 - Little Endian */
        uint64_t addr                  : 13; /**< [ 12:  0](R/W) RP3 UL address associated with the AXC ID (AXC_ID). */
        uint64_t reserved_13_15        : 3;
        uint64_t axc_id                : 8;  /**< [ 23: 16](R/W) AXC ID associated wit the RP3 UL address (ADDR). */
        uint64_t reserved_24_63        : 40;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_rp3_ul_axc_map1x_s cn; */
};
typedef union cavm_cprix_rp3_ul_axc_map1x cavm_cprix_rp3_ul_axc_map1x_t;

static inline uint64_t CAVM_CPRIX_RP3_UL_AXC_MAP1X(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_RP3_UL_AXC_MAP1X(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=127)))
        return 0x864000010048ll + 0x1000000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x7f);
    __cavm_csr_fatal("CPRIX_RP3_UL_AXC_MAP1X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_RP3_UL_AXC_MAP1X(a,b) cavm_cprix_rp3_ul_axc_map1x_t
#define bustype_CAVM_CPRIX_RP3_UL_AXC_MAP1X(a,b) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_RP3_UL_AXC_MAP1X(a,b) "CPRIX_RP3_UL_AXC_MAP1X"
#define busnum_CAVM_CPRIX_RP3_UL_AXC_MAP1X(a,b) (a)
#define arguments_CAVM_CPRIX_RP3_UL_AXC_MAP1X(a,b) (a),(b),-1,-1

/**
 * Register (NCB) cpri#_rp3_ul_axc_sw_cfg#
 *
 * CPRI RP3 UL AXC Configuration Register
 */
union cavm_cprix_rp3_ul_axc_sw_cfgx
{
    uint64_t u;
    struct cavm_cprix_rp3_ul_axc_sw_cfgx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_12_63        : 52;
        uint64_t sw_msg_axc            : 8;  /**< [ 11:  4](R/W) Switched message AXC ID (0-255). */
        uint64_t sw_msg_dest           : 4;  /**< [  3:  0](R/W) Switched AXC message destination core (0-4). */
#else /* Word 0 - Little Endian */
        uint64_t sw_msg_dest           : 4;  /**< [  3:  0](R/W) Switched AXC message destination core (0-4). */
        uint64_t sw_msg_axc            : 8;  /**< [ 11:  4](R/W) Switched message AXC ID (0-255). */
        uint64_t reserved_12_63        : 52;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_rp3_ul_axc_sw_cfgx_s cn; */
};
typedef union cavm_cprix_rp3_ul_axc_sw_cfgx cavm_cprix_rp3_ul_axc_sw_cfgx_t;

static inline uint64_t CAVM_CPRIX_RP3_UL_AXC_SW_CFGX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_RP3_UL_AXC_SW_CFGX(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=255)))
        return 0x864000010010ll + 0x1000000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0xff);
    __cavm_csr_fatal("CPRIX_RP3_UL_AXC_SW_CFGX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_RP3_UL_AXC_SW_CFGX(a,b) cavm_cprix_rp3_ul_axc_sw_cfgx_t
#define bustype_CAVM_CPRIX_RP3_UL_AXC_SW_CFGX(a,b) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_RP3_UL_AXC_SW_CFGX(a,b) "CPRIX_RP3_UL_AXC_SW_CFGX"
#define busnum_CAVM_CPRIX_RP3_UL_AXC_SW_CFGX(a,b) (a)
#define arguments_CAVM_CPRIX_RP3_UL_AXC_SW_CFGX(a,b) (a),(b),-1,-1

/**
 * Register (NCB) cpri#_rp3_ul_ctrl_ba_cfg
 *
 * CPRI RP3 UL Control Buffer Address Configuration Register
 */
union cavm_cprix_rp3_ul_ctrl_ba_cfg
{
    uint64_t u;
    struct cavm_cprix_rp3_ul_ctrl_ba_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_53_63        : 11;
        uint64_t buf_addr              : 53; /**< [ 52:  0](R/W) UL AXC buffer base address. Note this is a byte address and the 4 LSB are always considered as 0. */
#else /* Word 0 - Little Endian */
        uint64_t buf_addr              : 53; /**< [ 52:  0](R/W) UL AXC buffer base address. Note this is a byte address and the 4 LSB are always considered as 0. */
        uint64_t reserved_53_63        : 11;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_rp3_ul_ctrl_ba_cfg_s cn; */
};
typedef union cavm_cprix_rp3_ul_ctrl_ba_cfg cavm_cprix_rp3_ul_ctrl_ba_cfg_t;

static inline uint64_t CAVM_CPRIX_RP3_UL_CTRL_BA_CFG(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_RP3_UL_CTRL_BA_CFG(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x864000002010ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_RP3_UL_CTRL_BA_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_RP3_UL_CTRL_BA_CFG(a) cavm_cprix_rp3_ul_ctrl_ba_cfg_t
#define bustype_CAVM_CPRIX_RP3_UL_CTRL_BA_CFG(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_RP3_UL_CTRL_BA_CFG(a) "CPRIX_RP3_UL_CTRL_BA_CFG"
#define busnum_CAVM_CPRIX_RP3_UL_CTRL_BA_CFG(a) (a)
#define arguments_CAVM_CPRIX_RP3_UL_CTRL_BA_CFG(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_rp3_ul_ctrl_bs_cfg
 *
 * CPRI RP3 UL Control Buffer Size Configuration Register
 */
union cavm_cprix_rp3_ul_ctrl_bs_cfg
{
    uint64_t u;
    struct cavm_cprix_rp3_ul_ctrl_bs_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t buf_size              : 16; /**< [ 15:  0](R/W) UL AXC buffer base size. */
#else /* Word 0 - Little Endian */
        uint64_t buf_size              : 16; /**< [ 15:  0](R/W) UL AXC buffer base size. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_rp3_ul_ctrl_bs_cfg_s cn; */
};
typedef union cavm_cprix_rp3_ul_ctrl_bs_cfg cavm_cprix_rp3_ul_ctrl_bs_cfg_t;

static inline uint64_t CAVM_CPRIX_RP3_UL_CTRL_BS_CFG(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_RP3_UL_CTRL_BS_CFG(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x864000002018ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_RP3_UL_CTRL_BS_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_RP3_UL_CTRL_BS_CFG(a) cavm_cprix_rp3_ul_ctrl_bs_cfg_t
#define bustype_CAVM_CPRIX_RP3_UL_CTRL_BS_CFG(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_RP3_UL_CTRL_BS_CFG(a) "CPRIX_RP3_UL_CTRL_BS_CFG"
#define busnum_CAVM_CPRIX_RP3_UL_CTRL_BS_CFG(a) (a)
#define arguments_CAVM_CPRIX_RP3_UL_CTRL_BS_CFG(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_rp3_ul_ctrl_cfg
 *
 * CPRI RP3 UL CTRL Configuration Register
 */
union cavm_cprix_rp3_ul_ctrl_cfg
{
    uint64_t u;
    struct cavm_cprix_rp3_ul_ctrl_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t buf_wptr_offset       : 16; /**< [ 63: 48](R/W/H) AXC buffer write pointer offset in the circular buffer indicated by the BUF_IDX. */
        uint64_t reserved_44_47        : 4;
        uint64_t msg_cnt               : 16; /**< [ 43: 28](R/W/H) Current message count sent. A notification is sent when the message count
                                                                 reaches the NOTIF_THRES and the count is reset at that time. */
        uint64_t notif_thres           : 16; /**< [ 27: 12](R/W) Message count threshold at which a notification is issued. The notification sent
                                                                 can be either an interrupt or a job descriptor.
                                                                 A value of 0 indicates that notifications are disabled. */
        uint64_t reserved_9_11         : 3;
        uint64_t notif_type            : 1;  /**< [  8:  8](R/W) The notification type sent after the message count threshold is reached.
                                                                 0x0 = interrupt.
                                                                 0x1 = job descriptor. */
        uint64_t data_swap             : 3;  /**< [  7:  5](R/W) Byte swap enable. */
        uint64_t dest_mem              : 1;  /**< [  4:  4](R/W) Destination memory:
                                                                 0 = SMEM.
                                                                 1 = LLC/DRAM. */
        uint64_t cmd_type              : 2;  /**< [  3:  2](R/W) Write DMA command type. */
        uint64_t sw_enable             : 1;  /**< [  1:  1](R/W) Enable switching the UL RP3 messages to another CPRI lane. */
        uint64_t buf_enable            : 1;  /**< [  0:  0](R/W) Enable buffering the UL RP3 messages to memory. */
#else /* Word 0 - Little Endian */
        uint64_t buf_enable            : 1;  /**< [  0:  0](R/W) Enable buffering the UL RP3 messages to memory. */
        uint64_t sw_enable             : 1;  /**< [  1:  1](R/W) Enable switching the UL RP3 messages to another CPRI lane. */
        uint64_t cmd_type              : 2;  /**< [  3:  2](R/W) Write DMA command type. */
        uint64_t dest_mem              : 1;  /**< [  4:  4](R/W) Destination memory:
                                                                 0 = SMEM.
                                                                 1 = LLC/DRAM. */
        uint64_t data_swap             : 3;  /**< [  7:  5](R/W) Byte swap enable. */
        uint64_t notif_type            : 1;  /**< [  8:  8](R/W) The notification type sent after the message count threshold is reached.
                                                                 0x0 = interrupt.
                                                                 0x1 = job descriptor. */
        uint64_t reserved_9_11         : 3;
        uint64_t notif_thres           : 16; /**< [ 27: 12](R/W) Message count threshold at which a notification is issued. The notification sent
                                                                 can be either an interrupt or a job descriptor.
                                                                 A value of 0 indicates that notifications are disabled. */
        uint64_t msg_cnt               : 16; /**< [ 43: 28](R/W/H) Current message count sent. A notification is sent when the message count
                                                                 reaches the NOTIF_THRES and the count is reset at that time. */
        uint64_t reserved_44_47        : 4;
        uint64_t buf_wptr_offset       : 16; /**< [ 63: 48](R/W/H) AXC buffer write pointer offset in the circular buffer indicated by the BUF_IDX. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_rp3_ul_ctrl_cfg_s cn; */
};
typedef union cavm_cprix_rp3_ul_ctrl_cfg cavm_cprix_rp3_ul_ctrl_cfg_t;

static inline uint64_t CAVM_CPRIX_RP3_UL_CTRL_CFG(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_RP3_UL_CTRL_CFG(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x864000002020ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_RP3_UL_CTRL_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_RP3_UL_CTRL_CFG(a) cavm_cprix_rp3_ul_ctrl_cfg_t
#define bustype_CAVM_CPRIX_RP3_UL_CTRL_CFG(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_RP3_UL_CTRL_CFG(a) "CPRIX_RP3_UL_CTRL_CFG"
#define busnum_CAVM_CPRIX_RP3_UL_CTRL_CFG(a) (a)
#define arguments_CAVM_CPRIX_RP3_UL_CTRL_CFG(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_rp3_ul_ctrl_jd_ba_cfg
 *
 * CPRI RP3 UL Control Job Descriptor Buffer Base Address Configuration Register
 */
union cavm_cprix_rp3_ul_ctrl_jd_ba_cfg
{
    uint64_t u;
    struct cavm_cprix_rp3_ul_ctrl_jd_ba_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_53_63        : 11;
        uint64_t buf_addr              : 53; /**< [ 52:  0](R/W) Job descriptor buffer base address. Note this is a byte address and the 4 LSB
                                                                 are always considered as 0. */
#else /* Word 0 - Little Endian */
        uint64_t buf_addr              : 53; /**< [ 52:  0](R/W) Job descriptor buffer base address. Note this is a byte address and the 4 LSB
                                                                 are always considered as 0. */
        uint64_t reserved_53_63        : 11;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_rp3_ul_ctrl_jd_ba_cfg_s cn; */
};
typedef union cavm_cprix_rp3_ul_ctrl_jd_ba_cfg cavm_cprix_rp3_ul_ctrl_jd_ba_cfg_t;

static inline uint64_t CAVM_CPRIX_RP3_UL_CTRL_JD_BA_CFG(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_RP3_UL_CTRL_JD_BA_CFG(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x864000002038ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_RP3_UL_CTRL_JD_BA_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_RP3_UL_CTRL_JD_BA_CFG(a) cavm_cprix_rp3_ul_ctrl_jd_ba_cfg_t
#define bustype_CAVM_CPRIX_RP3_UL_CTRL_JD_BA_CFG(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_RP3_UL_CTRL_JD_BA_CFG(a) "CPRIX_RP3_UL_CTRL_JD_BA_CFG"
#define busnum_CAVM_CPRIX_RP3_UL_CTRL_JD_BA_CFG(a) (a)
#define arguments_CAVM_CPRIX_RP3_UL_CTRL_JD_BA_CFG(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_rp3_ul_ctrl_jd_bs_cfg
 *
 * CPRI RP3 UL Control Job Descriptor Buffer Base Size Configuration Register
 */
union cavm_cprix_rp3_ul_ctrl_jd_bs_cfg
{
    uint64_t u;
    struct cavm_cprix_rp3_ul_ctrl_jd_bs_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_24_63        : 40;
        uint64_t num_jd                : 8;  /**< [ 23: 16](R/W) Number of Job descritor buffers. */
        uint64_t jd_size               : 16; /**< [ 15:  0](R/W) Size of each job descriptor buffer for control massages. */
#else /* Word 0 - Little Endian */
        uint64_t jd_size               : 16; /**< [ 15:  0](R/W) Size of each job descriptor buffer for control massages. */
        uint64_t num_jd                : 8;  /**< [ 23: 16](R/W) Number of Job descritor buffers. */
        uint64_t reserved_24_63        : 40;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_rp3_ul_ctrl_jd_bs_cfg_s cn; */
};
typedef union cavm_cprix_rp3_ul_ctrl_jd_bs_cfg cavm_cprix_rp3_ul_ctrl_jd_bs_cfg_t;

static inline uint64_t CAVM_CPRIX_RP3_UL_CTRL_JD_BS_CFG(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_RP3_UL_CTRL_JD_BS_CFG(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x864000002040ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_RP3_UL_CTRL_JD_BS_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_RP3_UL_CTRL_JD_BS_CFG(a) cavm_cprix_rp3_ul_ctrl_jd_bs_cfg_t
#define bustype_CAVM_CPRIX_RP3_UL_CTRL_JD_BS_CFG(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_RP3_UL_CTRL_JD_BS_CFG(a) "CPRIX_RP3_UL_CTRL_JD_BS_CFG"
#define busnum_CAVM_CPRIX_RP3_UL_CTRL_JD_BS_CFG(a) (a)
#define arguments_CAVM_CPRIX_RP3_UL_CTRL_JD_BS_CFG(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_rp3_ul_ctrl_jd_cfg
 *
 * CPRI RP3 UL CTRL Job Descriptor Configuration Register
 */
union cavm_cprix_rp3_ul_ctrl_jd_cfg
{
    uint64_t u;
    struct cavm_cprix_rp3_ul_ctrl_jd_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_36_63        : 28;
        uint64_t jd_wptr               : 16; /**< [ 35: 20](R/W) Write pointer within the Control message job descriptor buffer. */
        uint64_t next_jd_ptr           : 8;  /**< [ 19: 12](R/W) Next job descriptor pointer, which wraps around at NUM_JD. */
        uint64_t reserved_1_11         : 11;
        uint64_t jd_enable             : 1;  /**< [  0:  0](R/W) Job descriptor enable. */
#else /* Word 0 - Little Endian */
        uint64_t jd_enable             : 1;  /**< [  0:  0](R/W) Job descriptor enable. */
        uint64_t reserved_1_11         : 11;
        uint64_t next_jd_ptr           : 8;  /**< [ 19: 12](R/W) Next job descriptor pointer, which wraps around at NUM_JD. */
        uint64_t jd_wptr               : 16; /**< [ 35: 20](R/W) Write pointer within the Control message job descriptor buffer. */
        uint64_t reserved_36_63        : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_rp3_ul_ctrl_jd_cfg_s cn; */
};
typedef union cavm_cprix_rp3_ul_ctrl_jd_cfg cavm_cprix_rp3_ul_ctrl_jd_cfg_t;

static inline uint64_t CAVM_CPRIX_RP3_UL_CTRL_JD_CFG(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_RP3_UL_CTRL_JD_CFG(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x864000010028ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_RP3_UL_CTRL_JD_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_RP3_UL_CTRL_JD_CFG(a) cavm_cprix_rp3_ul_ctrl_jd_cfg_t
#define bustype_CAVM_CPRIX_RP3_UL_CTRL_JD_CFG(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_RP3_UL_CTRL_JD_CFG(a) "CPRIX_RP3_UL_CTRL_JD_CFG"
#define busnum_CAVM_CPRIX_RP3_UL_CTRL_JD_CFG(a) (a)
#define arguments_CAVM_CPRIX_RP3_UL_CTRL_JD_CFG(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_rp3_ul_ctrl_map0#
 *
 * CPRI RP3 UL Control MAP 0 Register
 */
union cavm_cprix_rp3_ul_ctrl_map0x
{
    uint64_t u;
    struct cavm_cprix_rp3_ul_ctrl_map0x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_22_63        : 42;
        uint64_t ctrl_id               : 6;  /**< [ 21: 16](R/W) CTRL ID associated wit the RP3 UL address (ADDR). */
        uint64_t reserved_13_15        : 3;
        uint64_t addr                  : 13; /**< [ 12:  0](R/W) RP3 UL address associated with the control channel corresponding to the register
                                                                 index. Associated with CPRI IP 0. */
#else /* Word 0 - Little Endian */
        uint64_t addr                  : 13; /**< [ 12:  0](R/W) RP3 UL address associated with the control channel corresponding to the register
                                                                 index. Associated with CPRI IP 0. */
        uint64_t reserved_13_15        : 3;
        uint64_t ctrl_id               : 6;  /**< [ 21: 16](R/W) CTRL ID associated wit the RP3 UL address (ADDR). */
        uint64_t reserved_22_63        : 42;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_rp3_ul_ctrl_map0x_s cn; */
};
typedef union cavm_cprix_rp3_ul_ctrl_map0x cavm_cprix_rp3_ul_ctrl_map0x_t;

static inline uint64_t CAVM_CPRIX_RP3_UL_CTRL_MAP0X(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_RP3_UL_CTRL_MAP0X(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=63)))
        return 0x864000010050ll + 0x1000000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3f);
    __cavm_csr_fatal("CPRIX_RP3_UL_CTRL_MAP0X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_RP3_UL_CTRL_MAP0X(a,b) cavm_cprix_rp3_ul_ctrl_map0x_t
#define bustype_CAVM_CPRIX_RP3_UL_CTRL_MAP0X(a,b) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_RP3_UL_CTRL_MAP0X(a,b) "CPRIX_RP3_UL_CTRL_MAP0X"
#define busnum_CAVM_CPRIX_RP3_UL_CTRL_MAP0X(a,b) (a)
#define arguments_CAVM_CPRIX_RP3_UL_CTRL_MAP0X(a,b) (a),(b),-1,-1

/**
 * Register (NCB) cpri#_rp3_ul_ctrl_map1#
 *
 * CPRI RP3 UL Control MAP 1 Register
 */
union cavm_cprix_rp3_ul_ctrl_map1x
{
    uint64_t u;
    struct cavm_cprix_rp3_ul_ctrl_map1x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_22_63        : 42;
        uint64_t ctrl_id               : 6;  /**< [ 21: 16](R/W) CTRL ID associated wit the RP3 UL address (ADDR). */
        uint64_t reserved_13_15        : 3;
        uint64_t addr                  : 13; /**< [ 12:  0](R/W) RP3 UL address associated with the control channel corresponding to the register
                                                                 index. Associated with CPRI IP 1. */
#else /* Word 0 - Little Endian */
        uint64_t addr                  : 13; /**< [ 12:  0](R/W) RP3 UL address associated with the control channel corresponding to the register
                                                                 index. Associated with CPRI IP 1. */
        uint64_t reserved_13_15        : 3;
        uint64_t ctrl_id               : 6;  /**< [ 21: 16](R/W) CTRL ID associated wit the RP3 UL address (ADDR). */
        uint64_t reserved_22_63        : 42;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_rp3_ul_ctrl_map1x_s cn; */
};
typedef union cavm_cprix_rp3_ul_ctrl_map1x cavm_cprix_rp3_ul_ctrl_map1x_t;

static inline uint64_t CAVM_CPRIX_RP3_UL_CTRL_MAP1X(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_RP3_UL_CTRL_MAP1X(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=63)))
        return 0x864000010058ll + 0x1000000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3f);
    __cavm_csr_fatal("CPRIX_RP3_UL_CTRL_MAP1X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_RP3_UL_CTRL_MAP1X(a,b) cavm_cprix_rp3_ul_ctrl_map1x_t
#define bustype_CAVM_CPRIX_RP3_UL_CTRL_MAP1X(a,b) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_RP3_UL_CTRL_MAP1X(a,b) "CPRIX_RP3_UL_CTRL_MAP1X"
#define busnum_CAVM_CPRIX_RP3_UL_CTRL_MAP1X(a,b) (a)
#define arguments_CAVM_CPRIX_RP3_UL_CTRL_MAP1X(a,b) (a),(b),-1,-1

/**
 * Register (NCB) cpri#_rp3_ul_ctrl_sw_cfg#
 *
 * CPRI RP3 UL Control Switch Configuration Register
 */
union cavm_cprix_rp3_ul_ctrl_sw_cfgx
{
    uint64_t u;
    struct cavm_cprix_rp3_ul_ctrl_sw_cfgx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_25_63        : 39;
        uint64_t repl_addr             : 13; /**< [ 24: 12](R/W) Switched control message replacement address. */
        uint64_t sw_msg_axc            : 8;  /**< [ 11:  4](R/W) Switched message CTRL ID (0-255). */
        uint64_t sw_msg_dest           : 4;  /**< [  3:  0](R/W) Switched control message destination core (0-4). */
#else /* Word 0 - Little Endian */
        uint64_t sw_msg_dest           : 4;  /**< [  3:  0](R/W) Switched control message destination core (0-4). */
        uint64_t sw_msg_axc            : 8;  /**< [ 11:  4](R/W) Switched message CTRL ID (0-255). */
        uint64_t repl_addr             : 13; /**< [ 24: 12](R/W) Switched control message replacement address. */
        uint64_t reserved_25_63        : 39;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_rp3_ul_ctrl_sw_cfgx_s cn; */
};
typedef union cavm_cprix_rp3_ul_ctrl_sw_cfgx cavm_cprix_rp3_ul_ctrl_sw_cfgx_t;

static inline uint64_t CAVM_CPRIX_RP3_UL_CTRL_SW_CFGX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_RP3_UL_CTRL_SW_CFGX(unsigned long a, unsigned long b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=2) && (b<=63)))
        return 0x864000010020ll + 0x1000000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3f);
    __cavm_csr_fatal("CPRIX_RP3_UL_CTRL_SW_CFGX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_RP3_UL_CTRL_SW_CFGX(a,b) cavm_cprix_rp3_ul_ctrl_sw_cfgx_t
#define bustype_CAVM_CPRIX_RP3_UL_CTRL_SW_CFGX(a,b) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_RP3_UL_CTRL_SW_CFGX(a,b) "CPRIX_RP3_UL_CTRL_SW_CFGX"
#define busnum_CAVM_CPRIX_RP3_UL_CTRL_SW_CFGX(a,b) (a)
#define arguments_CAVM_CPRIX_RP3_UL_CTRL_SW_CFGX(a,b) (a),(b),-1,-1

/**
 * Register (NCB) cpri#_rp3_ul_ja_params
 *
 * CPRI RP3 UL Job Addition Parameters Register
 */
union cavm_cprix_rp3_ul_ja_params
{
    uint64_t u;
    struct cavm_cprix_rp3_ul_ja_params_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_56_63        : 8;
        uint64_t opcode                : 6;  /**< [ 55: 50](R/W) OPCODE parameter used when adding a job to the PSM. */
        uint64_t rsrc_set              : 2;  /**< [ 49: 48](R/W) RSRC_SET parameter used when adding a job to the PSM. */
        uint64_t qid                   : 8;  /**< [ 47: 40](R/W) QID parameter used when adding a job to the PSM. */
        uint64_t waitcond              : 8;  /**< [ 39: 32](R/W) Waitcond parameter used when adding a job to the PSM. */
        uint64_t jobtag                : 16; /**< [ 31: 16](R/W) Job Tag parameter used when adding a job to the PSM. */
        uint64_t reserved_9_15         : 7;
        uint64_t tmem                  : 1;  /**< [  8:  8](R/W) Indicates the memory type where the job descriptor is located for the jobs to be added.
                                                                 0 = SMEM.
                                                                 1 = LLC/DRAM. */
        uint64_t jobtype               : 8;  /**< [  7:  0](R/W) Job type parameter used when adding a job to the PSM. */
#else /* Word 0 - Little Endian */
        uint64_t jobtype               : 8;  /**< [  7:  0](R/W) Job type parameter used when adding a job to the PSM. */
        uint64_t tmem                  : 1;  /**< [  8:  8](R/W) Indicates the memory type where the job descriptor is located for the jobs to be added.
                                                                 0 = SMEM.
                                                                 1 = LLC/DRAM. */
        uint64_t reserved_9_15         : 7;
        uint64_t jobtag                : 16; /**< [ 31: 16](R/W) Job Tag parameter used when adding a job to the PSM. */
        uint64_t waitcond              : 8;  /**< [ 39: 32](R/W) Waitcond parameter used when adding a job to the PSM. */
        uint64_t qid                   : 8;  /**< [ 47: 40](R/W) QID parameter used when adding a job to the PSM. */
        uint64_t rsrc_set              : 2;  /**< [ 49: 48](R/W) RSRC_SET parameter used when adding a job to the PSM. */
        uint64_t opcode                : 6;  /**< [ 55: 50](R/W) OPCODE parameter used when adding a job to the PSM. */
        uint64_t reserved_56_63        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_rp3_ul_ja_params_s cn; */
};
typedef union cavm_cprix_rp3_ul_ja_params cavm_cprix_rp3_ul_ja_params_t;

static inline uint64_t CAVM_CPRIX_RP3_UL_JA_PARAMS(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_RP3_UL_JA_PARAMS(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x864000010060ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_RP3_UL_JA_PARAMS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_RP3_UL_JA_PARAMS(a) cavm_cprix_rp3_ul_ja_params_t
#define bustype_CAVM_CPRIX_RP3_UL_JA_PARAMS(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_RP3_UL_JA_PARAMS(a) "CPRIX_RP3_UL_JA_PARAMS"
#define busnum_CAVM_CPRIX_RP3_UL_JA_PARAMS(a) (a)
#define arguments_CAVM_CPRIX_RP3_UL_JA_PARAMS(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_rp3_ul_type_lut
 *
 * CPRI RP3 UL Type Lookup Table Register
 */
union cavm_cprix_rp3_ul_type_lut
{
    uint64_t u;
    struct cavm_cprix_rp3_ul_type_lut_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t lut                   : 32; /**< [ 31:  0](R/W) Message type lookup table. Each bit of this lookup table indicates whether the
                                                                 associated type control (0) or AXC (1). */
#else /* Word 0 - Little Endian */
        uint64_t lut                   : 32; /**< [ 31:  0](R/W) Message type lookup table. Each bit of this lookup table indicates whether the
                                                                 associated type control (0) or AXC (1). */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_rp3_ul_type_lut_s cn; */
};
typedef union cavm_cprix_rp3_ul_type_lut cavm_cprix_rp3_ul_type_lut_t;

static inline uint64_t CAVM_CPRIX_RP3_UL_TYPE_LUT(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_RP3_UL_TYPE_LUT(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x864000002058ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_RP3_UL_TYPE_LUT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_RP3_UL_TYPE_LUT(a) cavm_cprix_rp3_ul_type_lut_t
#define bustype_CAVM_CPRIX_RP3_UL_TYPE_LUT(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_RP3_UL_TYPE_LUT(a) "CPRIX_RP3_UL_TYPE_LUT"
#define busnum_CAVM_CPRIX_RP3_UL_TYPE_LUT(a) (a)
#define arguments_CAVM_CPRIX_RP3_UL_TYPE_LUT(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_rp3_uldl_axc_bs_cfg
 *
 * CPRI RP3 UL and DL AXC Buffer Sizes Configuration Register
 */
union cavm_cprix_rp3_uldl_axc_bs_cfg
{
    uint64_t u;
    struct cavm_cprix_rp3_uldl_axc_bs_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t buf_size              : 16; /**< [ 15:  0](R/W) UL and DL AXC buffers base size. */
#else /* Word 0 - Little Endian */
        uint64_t buf_size              : 16; /**< [ 15:  0](R/W) UL and DL AXC buffers base size. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_rp3_uldl_axc_bs_cfg_s cn; */
};
typedef union cavm_cprix_rp3_uldl_axc_bs_cfg cavm_cprix_rp3_uldl_axc_bs_cfg_t;

static inline uint64_t CAVM_CPRIX_RP3_ULDL_AXC_BS_CFG(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_RP3_ULDL_AXC_BS_CFG(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x864000002008ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_RP3_ULDL_AXC_BS_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_RP3_ULDL_AXC_BS_CFG(a) cavm_cprix_rp3_uldl_axc_bs_cfg_t
#define bustype_CAVM_CPRIX_RP3_ULDL_AXC_BS_CFG(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_RP3_ULDL_AXC_BS_CFG(a) "CPRIX_RP3_ULDL_AXC_BS_CFG"
#define busnum_CAVM_CPRIX_RP3_ULDL_AXC_BS_CFG(a) (a)
#define arguments_CAVM_CPRIX_RP3_ULDL_AXC_BS_CFG(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_rxd_gmii_ul_cbuf_cfg1
 *
 * CPRI GMII UL Circular Buffer Configuration Register 1
 */
union cavm_cprix_rxd_gmii_ul_cbuf_cfg1
{
    uint64_t u;
    struct cavm_cprix_rxd_gmii_ul_cbuf_cfg1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t buf_enable            : 1;  /**< [ 63: 63](R/W) Enables DMA of Ethernet packets to the circular buffer. When written
                                                                 to zero, it also resets the RXDMA logic for GMII and associated registers. */
        uint64_t reserved_32_62        : 31;
        uint64_t ul_cbuf_size          : 16; /**< [ 31: 16](R/W) Size of the GMII UL Circular Buffer in 128 bit entries */
        uint64_t reserved_8_15         : 8;
        uint64_t ul_int_pkt_threshold  : 8;  /**< [  7:  0](R/W) Threshold on when to send interrupt based on number of packets written. */
#else /* Word 0 - Little Endian */
        uint64_t ul_int_pkt_threshold  : 8;  /**< [  7:  0](R/W) Threshold on when to send interrupt based on number of packets written. */
        uint64_t reserved_8_15         : 8;
        uint64_t ul_cbuf_size          : 16; /**< [ 31: 16](R/W) Size of the GMII UL Circular Buffer in 128 bit entries */
        uint64_t reserved_32_62        : 31;
        uint64_t buf_enable            : 1;  /**< [ 63: 63](R/W) Enables DMA of Ethernet packets to the circular buffer. When written
                                                                 to zero, it also resets the RXDMA logic for GMII and associated registers. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_rxd_gmii_ul_cbuf_cfg1_s cn; */
};
typedef union cavm_cprix_rxd_gmii_ul_cbuf_cfg1 cavm_cprix_rxd_gmii_ul_cbuf_cfg1_t;

static inline uint64_t CAVM_CPRIX_RXD_GMII_UL_CBUF_CFG1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_RXD_GMII_UL_CBUF_CFG1(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x864000001000ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_RXD_GMII_UL_CBUF_CFG1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_RXD_GMII_UL_CBUF_CFG1(a) cavm_cprix_rxd_gmii_ul_cbuf_cfg1_t
#define bustype_CAVM_CPRIX_RXD_GMII_UL_CBUF_CFG1(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_RXD_GMII_UL_CBUF_CFG1(a) "CPRIX_RXD_GMII_UL_CBUF_CFG1"
#define busnum_CAVM_CPRIX_RXD_GMII_UL_CBUF_CFG1(a) (a)
#define arguments_CAVM_CPRIX_RXD_GMII_UL_CBUF_CFG1(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_rxd_gmii_ul_cbuf_cfg2
 *
 * CPRI GMII UL Circular Buffer Configuration Register 2
 */
union cavm_cprix_rxd_gmii_ul_cbuf_cfg2
{
    uint64_t u;
    struct cavm_cprix_rxd_gmii_ul_cbuf_cfg2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t target_mem            : 1;  /**< [ 63: 63](R/W) Specifies the target memory for the address.
                                                                 0 = SMEM.
                                                                 1 = LLC/DRAM. */
        uint64_t reserved_62           : 1;
        uint64_t cmd_type              : 2;  /**< [ 61: 60](R/W) Command type for LLC/DRAM writes. The write operations are
                                                                 enumerated by MHBW_PNB_WR_CMD_E. */
        uint64_t hp                    : 1;  /**< [ 59: 59](R/W) Write Priority sent along with the write request */
        uint64_t dswap                 : 3;  /**< [ 58: 56](R/W) The byte swap mode for DMA to LLC/DRAM. Enumerated in MHBW_PNB_DSWAP_E.
                                                                 DMA to BPHY SMEM ignores this field. */
        uint64_t reserved_53_55        : 3;
        uint64_t cbuf_ptr              : 53; /**< [ 52:  0](R/W) GMII UL Circular Buffer base address (byte address). This should be 128 bit aligned address. */
#else /* Word 0 - Little Endian */
        uint64_t cbuf_ptr              : 53; /**< [ 52:  0](R/W) GMII UL Circular Buffer base address (byte address). This should be 128 bit aligned address. */
        uint64_t reserved_53_55        : 3;
        uint64_t dswap                 : 3;  /**< [ 58: 56](R/W) The byte swap mode for DMA to LLC/DRAM. Enumerated in MHBW_PNB_DSWAP_E.
                                                                 DMA to BPHY SMEM ignores this field. */
        uint64_t hp                    : 1;  /**< [ 59: 59](R/W) Write Priority sent along with the write request */
        uint64_t cmd_type              : 2;  /**< [ 61: 60](R/W) Command type for LLC/DRAM writes. The write operations are
                                                                 enumerated by MHBW_PNB_WR_CMD_E. */
        uint64_t reserved_62           : 1;
        uint64_t target_mem            : 1;  /**< [ 63: 63](R/W) Specifies the target memory for the address.
                                                                 0 = SMEM.
                                                                 1 = LLC/DRAM. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_rxd_gmii_ul_cbuf_cfg2_s cn; */
};
typedef union cavm_cprix_rxd_gmii_ul_cbuf_cfg2 cavm_cprix_rxd_gmii_ul_cbuf_cfg2_t;

static inline uint64_t CAVM_CPRIX_RXD_GMII_UL_CBUF_CFG2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_RXD_GMII_UL_CBUF_CFG2(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x864000001008ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_RXD_GMII_UL_CBUF_CFG2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_RXD_GMII_UL_CBUF_CFG2(a) cavm_cprix_rxd_gmii_ul_cbuf_cfg2_t
#define bustype_CAVM_CPRIX_RXD_GMII_UL_CBUF_CFG2(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_RXD_GMII_UL_CBUF_CFG2(a) "CPRIX_RXD_GMII_UL_CBUF_CFG2"
#define busnum_CAVM_CPRIX_RXD_GMII_UL_CBUF_CFG2(a) (a)
#define arguments_CAVM_CPRIX_RXD_GMII_UL_CBUF_CFG2(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_rxd_gmii_ul_nxt_wr_ptr
 *
 * CPRI GMII UL CIRCULAR BUFFER NEXT WRITE POINTER Register
 */
union cavm_cprix_rxd_gmii_ul_nxt_wr_ptr
{
    uint64_t u;
    struct cavm_cprix_rxd_gmii_ul_nxt_wr_ptr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t nxt_wr_ptr            : 16; /**< [ 15:  0](RO/H) Circular Buffer next write pointer. 1 unit per 16 bytes */
#else /* Word 0 - Little Endian */
        uint64_t nxt_wr_ptr            : 16; /**< [ 15:  0](RO/H) Circular Buffer next write pointer. 1 unit per 16 bytes */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_rxd_gmii_ul_nxt_wr_ptr_s cn; */
};
typedef union cavm_cprix_rxd_gmii_ul_nxt_wr_ptr cavm_cprix_rxd_gmii_ul_nxt_wr_ptr_t;

static inline uint64_t CAVM_CPRIX_RXD_GMII_UL_NXT_WR_PTR(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_RXD_GMII_UL_NXT_WR_PTR(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x864000001020ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_RXD_GMII_UL_NXT_WR_PTR", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_RXD_GMII_UL_NXT_WR_PTR(a) cavm_cprix_rxd_gmii_ul_nxt_wr_ptr_t
#define bustype_CAVM_CPRIX_RXD_GMII_UL_NXT_WR_PTR(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_RXD_GMII_UL_NXT_WR_PTR(a) "CPRIX_RXD_GMII_UL_NXT_WR_PTR"
#define busnum_CAVM_CPRIX_RXD_GMII_UL_NXT_WR_PTR(a) (a)
#define arguments_CAVM_CPRIX_RXD_GMII_UL_NXT_WR_PTR(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_rxd_gmii_ul_pkt_count
 *
 * CPRI GMII UL CIRCULAR BUFFER PACKET COUNT Register
 */
union cavm_cprix_rxd_gmii_ul_pkt_count
{
    uint64_t u;
    struct cavm_cprix_rxd_gmii_ul_pkt_count_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t pkt_count             : 8;  /**< [  7:  0](RO/H) Count of packets to track sending of Interrupt. The entry is cleared when the interrupt is sent. */
#else /* Word 0 - Little Endian */
        uint64_t pkt_count             : 8;  /**< [  7:  0](RO/H) Count of packets to track sending of Interrupt. The entry is cleared when the interrupt is sent. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_rxd_gmii_ul_pkt_count_s cn; */
};
typedef union cavm_cprix_rxd_gmii_ul_pkt_count cavm_cprix_rxd_gmii_ul_pkt_count_t;

static inline uint64_t CAVM_CPRIX_RXD_GMII_UL_PKT_COUNT(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_RXD_GMII_UL_PKT_COUNT(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x864000001028ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_RXD_GMII_UL_PKT_COUNT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_RXD_GMII_UL_PKT_COUNT(a) cavm_cprix_rxd_gmii_ul_pkt_count_t
#define bustype_CAVM_CPRIX_RXD_GMII_UL_PKT_COUNT(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_RXD_GMII_UL_PKT_COUNT(a) "CPRIX_RXD_GMII_UL_PKT_COUNT"
#define busnum_CAVM_CPRIX_RXD_GMII_UL_PKT_COUNT(a) (a)
#define arguments_CAVM_CPRIX_RXD_GMII_UL_PKT_COUNT(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_rxd_gmii_ul_rd_doorbell
 *
 * CPRI GMII UL CBUF SOFTWARE READ DOORBELL Register
 */
union cavm_cprix_rxd_gmii_ul_rd_doorbell
{
    uint64_t u;
    struct cavm_cprix_rxd_gmii_ul_rd_doorbell_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t sw_rd_doorbell        : 8;  /**< [  7:  0](R/W/H) Written by software to indicate the number of packets read from the circular
                                                                 buffer. The register is automatically cleared after the software read pointer
                                                                 has been updated. */
#else /* Word 0 - Little Endian */
        uint64_t sw_rd_doorbell        : 8;  /**< [  7:  0](R/W/H) Written by software to indicate the number of packets read from the circular
                                                                 buffer. The register is automatically cleared after the software read pointer
                                                                 has been updated. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_rxd_gmii_ul_rd_doorbell_s cn; */
};
typedef union cavm_cprix_rxd_gmii_ul_rd_doorbell cavm_cprix_rxd_gmii_ul_rd_doorbell_t;

static inline uint64_t CAVM_CPRIX_RXD_GMII_UL_RD_DOORBELL(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_RXD_GMII_UL_RD_DOORBELL(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x864000001010ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_RXD_GMII_UL_RD_DOORBELL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_RXD_GMII_UL_RD_DOORBELL(a) cavm_cprix_rxd_gmii_ul_rd_doorbell_t
#define bustype_CAVM_CPRIX_RXD_GMII_UL_RD_DOORBELL(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_RXD_GMII_UL_RD_DOORBELL(a) "CPRIX_RXD_GMII_UL_RD_DOORBELL"
#define busnum_CAVM_CPRIX_RXD_GMII_UL_RD_DOORBELL(a) (a)
#define arguments_CAVM_CPRIX_RXD_GMII_UL_RD_DOORBELL(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_rxd_gmii_ul_sw_rd_ptr
 *
 * CPRI GMII UL CBUF SOFTWARE READ POINTER Register
 */
union cavm_cprix_rxd_gmii_ul_sw_rd_ptr
{
    uint64_t u;
    struct cavm_cprix_rxd_gmii_ul_sw_rd_ptr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t sw_rd_ptr             : 16; /**< [ 15:  0](RO/H) Software read pointer. 1 unit per 16 bytes */
#else /* Word 0 - Little Endian */
        uint64_t sw_rd_ptr             : 16; /**< [ 15:  0](RO/H) Software read pointer. 1 unit per 16 bytes */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_rxd_gmii_ul_sw_rd_ptr_s cn; */
};
typedef union cavm_cprix_rxd_gmii_ul_sw_rd_ptr cavm_cprix_rxd_gmii_ul_sw_rd_ptr_t;

static inline uint64_t CAVM_CPRIX_RXD_GMII_UL_SW_RD_PTR(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_RXD_GMII_UL_SW_RD_PTR(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x864000001018ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_RXD_GMII_UL_SW_RD_PTR", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_RXD_GMII_UL_SW_RD_PTR(a) cavm_cprix_rxd_gmii_ul_sw_rd_ptr_t
#define bustype_CAVM_CPRIX_RXD_GMII_UL_SW_RD_PTR(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_RXD_GMII_UL_SW_RD_PTR(a) "CPRIX_RXD_GMII_UL_SW_RD_PTR"
#define busnum_CAVM_CPRIX_RXD_GMII_UL_SW_RD_PTR(a) (a)
#define arguments_CAVM_CPRIX_RXD_GMII_UL_SW_RD_PTR(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_status
 *
 * CPRI Status Register
 */
union cavm_cprix_status
{
    uint64_t u;
    struct cavm_cprix_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_0_63         : 64;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_63         : 64;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_status_s cn; */
};
typedef union cavm_cprix_status cavm_cprix_status_t;

static inline uint64_t CAVM_CPRIX_STATUS(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_STATUS(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x864000000018ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_STATUS(a) cavm_cprix_status_t
#define bustype_CAVM_CPRIX_STATUS(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_STATUS(a) "CPRIX_STATUS"
#define busnum_CAVM_CPRIX_STATUS(a) (a)
#define arguments_CAVM_CPRIX_STATUS(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_txd_gmii_dl_cbuf_cfg1
 *
 * CPRI GMII DL Circular Buffer Configuration Register 1
 */
union cavm_cprix_txd_gmii_dl_cbuf_cfg1
{
    uint64_t u;
    struct cavm_cprix_txd_gmii_dl_cbuf_cfg1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t buf_enable            : 1;  /**< [ 63: 63](R/W) Enables DMA of Ethernet packets to the circular buffer. When written
                                                                 to zero, it also resets the TXDMA logic for GMII and associated registers. */
        uint64_t reserved_32_62        : 31;
        uint64_t dl_cbuf_size          : 16; /**< [ 31: 16](R/W) Size of the GMII DL Circular Buffer in 128 bit entries */
        uint64_t reserved_0_15         : 16;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_15         : 16;
        uint64_t dl_cbuf_size          : 16; /**< [ 31: 16](R/W) Size of the GMII DL Circular Buffer in 128 bit entries */
        uint64_t reserved_32_62        : 31;
        uint64_t buf_enable            : 1;  /**< [ 63: 63](R/W) Enables DMA of Ethernet packets to the circular buffer. When written
                                                                 to zero, it also resets the TXDMA logic for GMII and associated registers. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_txd_gmii_dl_cbuf_cfg1_s cn; */
};
typedef union cavm_cprix_txd_gmii_dl_cbuf_cfg1 cavm_cprix_txd_gmii_dl_cbuf_cfg1_t;

static inline uint64_t CAVM_CPRIX_TXD_GMII_DL_CBUF_CFG1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_TXD_GMII_DL_CBUF_CFG1(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x864000001100ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_TXD_GMII_DL_CBUF_CFG1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_TXD_GMII_DL_CBUF_CFG1(a) cavm_cprix_txd_gmii_dl_cbuf_cfg1_t
#define bustype_CAVM_CPRIX_TXD_GMII_DL_CBUF_CFG1(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_TXD_GMII_DL_CBUF_CFG1(a) "CPRIX_TXD_GMII_DL_CBUF_CFG1"
#define busnum_CAVM_CPRIX_TXD_GMII_DL_CBUF_CFG1(a) (a)
#define arguments_CAVM_CPRIX_TXD_GMII_DL_CBUF_CFG1(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_txd_gmii_dl_cbuf_cfg2
 *
 * CPRI GMII DL Circular Buffer Configuration Register 2
 */
union cavm_cprix_txd_gmii_dl_cbuf_cfg2
{
    uint64_t u;
    struct cavm_cprix_txd_gmii_dl_cbuf_cfg2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t target_mem            : 1;  /**< [ 63: 63](R/W) Specifies the target memory for the address.
                                                                 0 = SMEM.
                                                                 1 = LLC/DRAM. */
        uint64_t reserved_62           : 1;
        uint64_t cmd_type              : 2;  /**< [ 61: 60](R/W) Command type for LLC/DRAM writes. The write operations are
                                                                 enumerated by MHBW_PNB_WR_CMD_E. */
        uint64_t hp                    : 1;  /**< [ 59: 59](R/W) Read Priority sent along with the read request */
        uint64_t dswap                 : 3;  /**< [ 58: 56](R/W) The byte swap mode for DMA to LLC/DRAM. Enumerated in MHBW_PNB_DSWAP_E.
                                                                 DMA to BPHY SMEM ignores this field. */
        uint64_t reserved_53_55        : 3;
        uint64_t cbuf_ptr              : 53; /**< [ 52:  0](R/W) GMII DL Circular Buffer base address (byte address). This should be 128 bit aligned address. */
#else /* Word 0 - Little Endian */
        uint64_t cbuf_ptr              : 53; /**< [ 52:  0](R/W) GMII DL Circular Buffer base address (byte address). This should be 128 bit aligned address. */
        uint64_t reserved_53_55        : 3;
        uint64_t dswap                 : 3;  /**< [ 58: 56](R/W) The byte swap mode for DMA to LLC/DRAM. Enumerated in MHBW_PNB_DSWAP_E.
                                                                 DMA to BPHY SMEM ignores this field. */
        uint64_t hp                    : 1;  /**< [ 59: 59](R/W) Read Priority sent along with the read request */
        uint64_t cmd_type              : 2;  /**< [ 61: 60](R/W) Command type for LLC/DRAM writes. The write operations are
                                                                 enumerated by MHBW_PNB_WR_CMD_E. */
        uint64_t reserved_62           : 1;
        uint64_t target_mem            : 1;  /**< [ 63: 63](R/W) Specifies the target memory for the address.
                                                                 0 = SMEM.
                                                                 1 = LLC/DRAM. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_txd_gmii_dl_cbuf_cfg2_s cn; */
};
typedef union cavm_cprix_txd_gmii_dl_cbuf_cfg2 cavm_cprix_txd_gmii_dl_cbuf_cfg2_t;

static inline uint64_t CAVM_CPRIX_TXD_GMII_DL_CBUF_CFG2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_TXD_GMII_DL_CBUF_CFG2(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x864000001108ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_TXD_GMII_DL_CBUF_CFG2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_TXD_GMII_DL_CBUF_CFG2(a) cavm_cprix_txd_gmii_dl_cbuf_cfg2_t
#define bustype_CAVM_CPRIX_TXD_GMII_DL_CBUF_CFG2(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_TXD_GMII_DL_CBUF_CFG2(a) "CPRIX_TXD_GMII_DL_CBUF_CFG2"
#define busnum_CAVM_CPRIX_TXD_GMII_DL_CBUF_CFG2(a) (a)
#define arguments_CAVM_CPRIX_TXD_GMII_DL_CBUF_CFG2(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_txd_gmii_dl_nxt_rd_ptr
 *
 * CPRI GMII DL CIRCULAR BUFFER NEXT READ POINTER Register
 */
union cavm_cprix_txd_gmii_dl_nxt_rd_ptr
{
    uint64_t u;
    struct cavm_cprix_txd_gmii_dl_nxt_rd_ptr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t nxt_rd_ptr            : 16; /**< [ 15:  0](RO/H) Circular Buffer next read pointer. 1 unit per 16 bytes */
#else /* Word 0 - Little Endian */
        uint64_t nxt_rd_ptr            : 16; /**< [ 15:  0](RO/H) Circular Buffer next read pointer. 1 unit per 16 bytes */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_txd_gmii_dl_nxt_rd_ptr_s cn; */
};
typedef union cavm_cprix_txd_gmii_dl_nxt_rd_ptr cavm_cprix_txd_gmii_dl_nxt_rd_ptr_t;

static inline uint64_t CAVM_CPRIX_TXD_GMII_DL_NXT_RD_PTR(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_TXD_GMII_DL_NXT_RD_PTR(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x864000001120ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_TXD_GMII_DL_NXT_RD_PTR", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_TXD_GMII_DL_NXT_RD_PTR(a) cavm_cprix_txd_gmii_dl_nxt_rd_ptr_t
#define bustype_CAVM_CPRIX_TXD_GMII_DL_NXT_RD_PTR(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_TXD_GMII_DL_NXT_RD_PTR(a) "CPRIX_TXD_GMII_DL_NXT_RD_PTR"
#define busnum_CAVM_CPRIX_TXD_GMII_DL_NXT_RD_PTR(a) (a)
#define arguments_CAVM_CPRIX_TXD_GMII_DL_NXT_RD_PTR(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_txd_gmii_dl_sw_wr_ptr
 *
 * CPRI GMII DL CBUF SOFTWARE WRITE POINTER Register
 */
union cavm_cprix_txd_gmii_dl_sw_wr_ptr
{
    uint64_t u;
    struct cavm_cprix_txd_gmii_dl_sw_wr_ptr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t sw_wr_ptr             : 16; /**< [ 15:  0](RO/H) Software write pointer. 1 unit per 16 bytes */
#else /* Word 0 - Little Endian */
        uint64_t sw_wr_ptr             : 16; /**< [ 15:  0](RO/H) Software write pointer. 1 unit per 16 bytes */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_txd_gmii_dl_sw_wr_ptr_s cn; */
};
typedef union cavm_cprix_txd_gmii_dl_sw_wr_ptr cavm_cprix_txd_gmii_dl_sw_wr_ptr_t;

static inline uint64_t CAVM_CPRIX_TXD_GMII_DL_SW_WR_PTR(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_TXD_GMII_DL_SW_WR_PTR(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x864000001118ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_TXD_GMII_DL_SW_WR_PTR", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_TXD_GMII_DL_SW_WR_PTR(a) cavm_cprix_txd_gmii_dl_sw_wr_ptr_t
#define bustype_CAVM_CPRIX_TXD_GMII_DL_SW_WR_PTR(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_TXD_GMII_DL_SW_WR_PTR(a) "CPRIX_TXD_GMII_DL_SW_WR_PTR"
#define busnum_CAVM_CPRIX_TXD_GMII_DL_SW_WR_PTR(a) (a)
#define arguments_CAVM_CPRIX_TXD_GMII_DL_SW_WR_PTR(a) (a),-1,-1,-1

/**
 * Register (NCB) cpri#_txd_gmii_dl_wr_doorbell
 *
 * CPRI GMII DL CBUF SOFTWARE WRITE DOORBELL Register
 */
union cavm_cprix_txd_gmii_dl_wr_doorbell
{
    uint64_t u;
    struct cavm_cprix_txd_gmii_dl_wr_doorbell_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t sw_wr_doorbell        : 8;  /**< [  7:  0](R/W/H) Written by software to indicate the number of packets written to the circular
                                                                 buffer. The register is automatically cleared after the software write pointer
                                                                 has been updated. */
#else /* Word 0 - Little Endian */
        uint64_t sw_wr_doorbell        : 8;  /**< [  7:  0](R/W/H) Written by software to indicate the number of packets written to the circular
                                                                 buffer. The register is automatically cleared after the software write pointer
                                                                 has been updated. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_cprix_txd_gmii_dl_wr_doorbell_s cn; */
};
typedef union cavm_cprix_txd_gmii_dl_wr_doorbell cavm_cprix_txd_gmii_dl_wr_doorbell_t;

static inline uint64_t CAVM_CPRIX_TXD_GMII_DL_WR_DOORBELL(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_CPRIX_TXD_GMII_DL_WR_DOORBELL(unsigned long a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=2))
        return 0x864000001110ll + 0x1000000000ll * ((a) & 0x3);
    __cavm_csr_fatal("CPRIX_TXD_GMII_DL_WR_DOORBELL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_CPRIX_TXD_GMII_DL_WR_DOORBELL(a) cavm_cprix_txd_gmii_dl_wr_doorbell_t
#define bustype_CAVM_CPRIX_TXD_GMII_DL_WR_DOORBELL(a) CSR_TYPE_NCB
#define basename_CAVM_CPRIX_TXD_GMII_DL_WR_DOORBELL(a) "CPRIX_TXD_GMII_DL_WR_DOORBELL"
#define busnum_CAVM_CPRIX_TXD_GMII_DL_WR_DOORBELL(a) (a)
#define arguments_CAVM_CPRIX_TXD_GMII_DL_WR_DOORBELL(a) (a),-1,-1,-1

#endif /* __CAVM_CSRS_CPRI_H__ */

#ifndef __CAVM_CSRS_APBROM_HORIZONTAL_H__
#define __CAVM_CSRS_APBROM_HORIZONTAL_H__
/* This file is auto-generated. Do not edit */

/***********************license start***********************************
* Copyright (C) 2019 Marvell International Ltd.
* SPDX-License-Identifier: BSD-3-Clause
* https://spdx.org/licenses
***********************license end**************************************/


/**
 * @file
 *
 * Configuration and status register (CSR) address and type definitions for
 * OcteonTX APBROM_HORIZONTAL.
 *
 * This file is auto generated. Do not edit.
 *
 */

/**
 * Register (RSL32b) apbrom_horizontal_authstatus
 *
 * APBROM Horizontal Authstatus Register
 * Reports the current status of the authentication control signals.
 */
union cavm_apbrom_horizontal_authstatus
{
    uint32_t u;
    struct cavm_apbrom_horizontal_authstatus_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 20; /**< [ 31: 12](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t hnid                  : 2;  /**< [ 11: 10](RO) Hypervisor non-invasive debug. */
        uint32_t hid                   : 2;  /**< [  9:  8](RO) Hypervisor invasive debug. */
        uint32_t snid                  : 2;  /**< [  7:  6](RO) Secure non-invasive debug. */
        uint32_t sid                   : 2;  /**< [  5:  4](RO) Secure invasive debug. */
        uint32_t nsnid                 : 2;  /**< [  3:  2](RO) Non-secure non-invasive debug. */
        uint32_t nsid                  : 2;  /**< [  1:  0](RO) Non-secure invasive debug. */
#else /* Word 0 - Little Endian */
        uint32_t nsid                  : 2;  /**< [  1:  0](RO) Non-secure invasive debug. */
        uint32_t nsnid                 : 2;  /**< [  3:  2](RO) Non-secure non-invasive debug. */
        uint32_t sid                   : 2;  /**< [  5:  4](RO) Secure invasive debug. */
        uint32_t snid                  : 2;  /**< [  7:  6](RO) Secure non-invasive debug. */
        uint32_t hid                   : 2;  /**< [  9:  8](RO) Hypervisor invasive debug. */
        uint32_t hnid                  : 2;  /**< [ 11: 10](RO) Hypervisor non-invasive debug. */
        uint32_t res0_0                : 20; /**< [ 31: 12](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_authstatus_s cn; */
};
typedef union cavm_apbrom_horizontal_authstatus cavm_apbrom_horizontal_authstatus_t;

#define CAVM_APBROM_HORIZONTAL_AUTHSTATUS CAVM_APBROM_HORIZONTAL_AUTHSTATUS_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_AUTHSTATUS_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_AUTHSTATUS_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000fb8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_AUTHSTATUS", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_AUTHSTATUS cavm_apbrom_horizontal_authstatus_t
#define bustype_CAVM_APBROM_HORIZONTAL_AUTHSTATUS CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_AUTHSTATUS "APBROM_HORIZONTAL_AUTHSTATUS"
#define busnum_CAVM_APBROM_HORIZONTAL_AUTHSTATUS 0
#define arguments_CAVM_APBROM_HORIZONTAL_AUTHSTATUS -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_cidr0
 *
 * APBROM Horizontal Cidr0 Register
 * The CIDR0 register is part of the set of component identification registers.
 */
union cavm_apbrom_horizontal_cidr0
{
    uint32_t u;
    struct cavm_apbrom_horizontal_cidr0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t prmbl_0               : 8;  /**< [  7:  0](RO) Preamble. Returns 0x0D. */
#else /* Word 0 - Little Endian */
        uint32_t prmbl_0               : 8;  /**< [  7:  0](RO) Preamble. Returns 0x0D. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_cidr0_s cn; */
};
typedef union cavm_apbrom_horizontal_cidr0 cavm_apbrom_horizontal_cidr0_t;

#define CAVM_APBROM_HORIZONTAL_CIDR0 CAVM_APBROM_HORIZONTAL_CIDR0_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_CIDR0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_CIDR0_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000ff0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_CIDR0", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_CIDR0 cavm_apbrom_horizontal_cidr0_t
#define bustype_CAVM_APBROM_HORIZONTAL_CIDR0 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_CIDR0 "APBROM_HORIZONTAL_CIDR0"
#define busnum_CAVM_APBROM_HORIZONTAL_CIDR0 0
#define arguments_CAVM_APBROM_HORIZONTAL_CIDR0 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_cidr1
 *
 * APBROM Horizontal Cidr1 Register
 * The CIDR1 register is part of the set of component identification registers.
 */
union cavm_apbrom_horizontal_cidr1
{
    uint32_t u;
    struct cavm_apbrom_horizontal_cidr1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t class_f               : 4;  /**< [  7:  4](RO) Component class. Returns 0x9, indicating this is a CoreSight component. */
        uint32_t prmbl_1               : 4;  /**< [  3:  0](RO) Preamble. Returns 0x0. */
#else /* Word 0 - Little Endian */
        uint32_t prmbl_1               : 4;  /**< [  3:  0](RO) Preamble. Returns 0x0. */
        uint32_t class_f               : 4;  /**< [  7:  4](RO) Component class. Returns 0x9, indicating this is a CoreSight component. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_cidr1_s cn; */
};
typedef union cavm_apbrom_horizontal_cidr1 cavm_apbrom_horizontal_cidr1_t;

#define CAVM_APBROM_HORIZONTAL_CIDR1 CAVM_APBROM_HORIZONTAL_CIDR1_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_CIDR1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_CIDR1_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000ff4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_CIDR1", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_CIDR1 cavm_apbrom_horizontal_cidr1_t
#define bustype_CAVM_APBROM_HORIZONTAL_CIDR1 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_CIDR1 "APBROM_HORIZONTAL_CIDR1"
#define busnum_CAVM_APBROM_HORIZONTAL_CIDR1 0
#define arguments_CAVM_APBROM_HORIZONTAL_CIDR1 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_cidr2
 *
 * APBROM Horizontal Cidr2 Register
 * The CIDR2 register is part of the set of component identification registers.
 */
union cavm_apbrom_horizontal_cidr2
{
    uint32_t u;
    struct cavm_apbrom_horizontal_cidr2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t prmbl_2               : 8;  /**< [  7:  0](RO) Preamble. Returns 0x05. */
#else /* Word 0 - Little Endian */
        uint32_t prmbl_2               : 8;  /**< [  7:  0](RO) Preamble. Returns 0x05. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_cidr2_s cn; */
};
typedef union cavm_apbrom_horizontal_cidr2 cavm_apbrom_horizontal_cidr2_t;

#define CAVM_APBROM_HORIZONTAL_CIDR2 CAVM_APBROM_HORIZONTAL_CIDR2_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_CIDR2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_CIDR2_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000ff8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_CIDR2", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_CIDR2 cavm_apbrom_horizontal_cidr2_t
#define bustype_CAVM_APBROM_HORIZONTAL_CIDR2 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_CIDR2 "APBROM_HORIZONTAL_CIDR2"
#define busnum_CAVM_APBROM_HORIZONTAL_CIDR2 0
#define arguments_CAVM_APBROM_HORIZONTAL_CIDR2 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_cidr3
 *
 * APBROM Horizontal Cidr3 Register
 * The CIDR3 register is part of the set of component identification registers.
 */
union cavm_apbrom_horizontal_cidr3
{
    uint32_t u;
    struct cavm_apbrom_horizontal_cidr3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t prmbl_3               : 8;  /**< [  7:  0](RO) Preamble. Returns 0xB1. */
#else /* Word 0 - Little Endian */
        uint32_t prmbl_3               : 8;  /**< [  7:  0](RO) Preamble. Returns 0xB1. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_cidr3_s cn; */
};
typedef union cavm_apbrom_horizontal_cidr3 cavm_apbrom_horizontal_cidr3_t;

#define CAVM_APBROM_HORIZONTAL_CIDR3 CAVM_APBROM_HORIZONTAL_CIDR3_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_CIDR3_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_CIDR3_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000ffcll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_CIDR3", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_CIDR3 cavm_apbrom_horizontal_cidr3_t
#define bustype_CAVM_APBROM_HORIZONTAL_CIDR3 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_CIDR3 "APBROM_HORIZONTAL_CIDR3"
#define busnum_CAVM_APBROM_HORIZONTAL_CIDR3 0
#define arguments_CAVM_APBROM_HORIZONTAL_CIDR3 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_devarch
 *
 * APBROM Horizontal Devarch Register
 * Identifies the architect and architecture of a CoreSight component. The architect
 * might differ from the designer of a component, for example Arm defines the
 * architecture but another company designs and implements the component.
 */
union cavm_apbrom_horizontal_devarch
{
    uint32_t u;
    struct cavm_apbrom_horizontal_devarch_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t architect             : 11; /**< [ 31: 21](RO) Returns 0x23b, denoting Arm as architect of the component. */
        uint32_t present               : 1;  /**< [ 20: 20](RO) Returns 1, indicating that the DEVARCH register is present. */
        uint32_t revision              : 4;  /**< [ 19: 16](RO) Architecture revision. Returns the revision of the architecture that the ARCHID field specifies. */
        uint32_t archid                : 16; /**< [ 15:  0](RO) Architecture ID. Returns 0x0af7, identifying ROM Table Architecture v0. */
#else /* Word 0 - Little Endian */
        uint32_t archid                : 16; /**< [ 15:  0](RO) Architecture ID. Returns 0x0af7, identifying ROM Table Architecture v0. */
        uint32_t revision              : 4;  /**< [ 19: 16](RO) Architecture revision. Returns the revision of the architecture that the ARCHID field specifies. */
        uint32_t present               : 1;  /**< [ 20: 20](RO) Returns 1, indicating that the DEVARCH register is present. */
        uint32_t architect             : 11; /**< [ 31: 21](RO) Returns 0x23b, denoting Arm as architect of the component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_devarch_s cn; */
};
typedef union cavm_apbrom_horizontal_devarch cavm_apbrom_horizontal_devarch_t;

#define CAVM_APBROM_HORIZONTAL_DEVARCH CAVM_APBROM_HORIZONTAL_DEVARCH_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_DEVARCH_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_DEVARCH_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000fbcll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_DEVARCH", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_DEVARCH cavm_apbrom_horizontal_devarch_t
#define bustype_CAVM_APBROM_HORIZONTAL_DEVARCH CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_DEVARCH "APBROM_HORIZONTAL_DEVARCH"
#define busnum_CAVM_APBROM_HORIZONTAL_DEVARCH 0
#define arguments_CAVM_APBROM_HORIZONTAL_DEVARCH -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_devid
 *
 * APBROM Horizontal Devid Register
 * This register is IMPLEMENTATION DEFINED for each Part Number and Designer. The
 * register indicates the capabilities of the component.
 */
union cavm_apbrom_horizontal_devid
{
    uint32_t u;
    struct cavm_apbrom_horizontal_devid_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_1                : 26; /**< [ 31:  6](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t prr                   : 1;  /**< [  5:  5](RO) Indicates that power request functionality is included. Set by the GPR_PRESENT parameter. */
        uint32_t sysmem                : 1;  /**< [  4:  4](RO) Indicates whether system memory is present on the bus. Set by the SYSMEM parameter. */
        uint32_t res0_0                : 1;  /**< [  3:  3](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t format                : 3;  /**< [  2:  0](RO) Indicates that this is a 32-bit ROM table. */
#else /* Word 0 - Little Endian */
        uint32_t format                : 3;  /**< [  2:  0](RO) Indicates that this is a 32-bit ROM table. */
        uint32_t res0_0                : 1;  /**< [  3:  3](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t sysmem                : 1;  /**< [  4:  4](RO) Indicates whether system memory is present on the bus. Set by the SYSMEM parameter. */
        uint32_t prr                   : 1;  /**< [  5:  5](RO) Indicates that power request functionality is included. Set by the GPR_PRESENT parameter. */
        uint32_t res0_1                : 26; /**< [ 31:  6](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_devid_s cn; */
};
typedef union cavm_apbrom_horizontal_devid cavm_apbrom_horizontal_devid_t;

#define CAVM_APBROM_HORIZONTAL_DEVID CAVM_APBROM_HORIZONTAL_DEVID_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_DEVID_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_DEVID_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000fc8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_DEVID", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_DEVID cavm_apbrom_horizontal_devid_t
#define bustype_CAVM_APBROM_HORIZONTAL_DEVID CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_DEVID "APBROM_HORIZONTAL_DEVID"
#define busnum_CAVM_APBROM_HORIZONTAL_DEVID 0
#define arguments_CAVM_APBROM_HORIZONTAL_DEVID -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_pidr0
 *
 * APBROM Horizontal Pidr0 Register
 * The PIDR0 register is part of the set of peripheral identification registers.
 */
union cavm_apbrom_horizontal_pidr0
{
    uint32_t u;
    struct cavm_apbrom_horizontal_pidr0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t part_0                : 8;  /**< [  7:  0](RO) Part number, bits[7:0]. Set by the configuration inputs part_number[7:0] */
#else /* Word 0 - Little Endian */
        uint32_t part_0                : 8;  /**< [  7:  0](RO) Part number, bits[7:0]. Set by the configuration inputs part_number[7:0] */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_pidr0_s cn; */
};
typedef union cavm_apbrom_horizontal_pidr0 cavm_apbrom_horizontal_pidr0_t;

#define CAVM_APBROM_HORIZONTAL_PIDR0 CAVM_APBROM_HORIZONTAL_PIDR0_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_PIDR0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_PIDR0_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000fe0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_PIDR0", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_PIDR0 cavm_apbrom_horizontal_pidr0_t
#define bustype_CAVM_APBROM_HORIZONTAL_PIDR0 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_PIDR0 "APBROM_HORIZONTAL_PIDR0"
#define busnum_CAVM_APBROM_HORIZONTAL_PIDR0 0
#define arguments_CAVM_APBROM_HORIZONTAL_PIDR0 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_pidr1
 *
 * APBROM Horizontal Pidr1 Register
 * The PIDR1 register is part of the set of peripheral identification registers.
 */
union cavm_apbrom_horizontal_pidr1
{
    uint32_t u;
    struct cavm_apbrom_horizontal_pidr1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t des_0                 : 4;  /**< [  7:  4](RO) JEP106 identification code, bits[3:0]. Set by the configuration inputs
                                                                 jep106_id[3:0]. Together, with PIDR4.DES_2 and PIDR2.DES_1, they indicate the
                                                                 designer of the component and not the implementer, except where the two are the
                                                                 same. */
        uint32_t part_1                : 4;  /**< [  3:  0](RO) Part number, bits[11:8]. Set by the configuration inputs part_number[11:8]. */
#else /* Word 0 - Little Endian */
        uint32_t part_1                : 4;  /**< [  3:  0](RO) Part number, bits[11:8]. Set by the configuration inputs part_number[11:8]. */
        uint32_t des_0                 : 4;  /**< [  7:  4](RO) JEP106 identification code, bits[3:0]. Set by the configuration inputs
                                                                 jep106_id[3:0]. Together, with PIDR4.DES_2 and PIDR2.DES_1, they indicate the
                                                                 designer of the component and not the implementer, except where the two are the
                                                                 same. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_pidr1_s cn; */
};
typedef union cavm_apbrom_horizontal_pidr1 cavm_apbrom_horizontal_pidr1_t;

#define CAVM_APBROM_HORIZONTAL_PIDR1 CAVM_APBROM_HORIZONTAL_PIDR1_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_PIDR1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_PIDR1_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000fe4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_PIDR1", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_PIDR1 cavm_apbrom_horizontal_pidr1_t
#define bustype_CAVM_APBROM_HORIZONTAL_PIDR1 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_PIDR1 "APBROM_HORIZONTAL_PIDR1"
#define busnum_CAVM_APBROM_HORIZONTAL_PIDR1 0
#define arguments_CAVM_APBROM_HORIZONTAL_PIDR1 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_pidr2
 *
 * APBROM Horizontal Pidr2 Register
 * The PIDR2 register is part of the set of peripheral identification registers.
 */
union cavm_apbrom_horizontal_pidr2
{
    uint32_t u;
    struct cavm_apbrom_horizontal_pidr2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t revision              : 4;  /**< [  7:  4](RO) Revision. Set by the configuration inputs revision[3:0]. */
        uint32_t jedec                 : 1;  /**< [  3:  3](RO) 1 - Always set. Indicates that a JEDEC assigned value is used. */
        uint32_t des_1                 : 3;  /**< [  2:  0](RO) JEP106 identification code, bits[6:4]. Set by the configuration inputs
                                                                 jep106_id[6:4]. Together, with PIDR4.DES_2 and PIDR1.DES_0, they indicate the
                                                                 designer of the component and not the implementer, except where the two are the
                                                                 same. */
#else /* Word 0 - Little Endian */
        uint32_t des_1                 : 3;  /**< [  2:  0](RO) JEP106 identification code, bits[6:4]. Set by the configuration inputs
                                                                 jep106_id[6:4]. Together, with PIDR4.DES_2 and PIDR1.DES_0, they indicate the
                                                                 designer of the component and not the implementer, except where the two are the
                                                                 same. */
        uint32_t jedec                 : 1;  /**< [  3:  3](RO) 1 - Always set. Indicates that a JEDEC assigned value is used. */
        uint32_t revision              : 4;  /**< [  7:  4](RO) Revision. Set by the configuration inputs revision[3:0]. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_pidr2_s cn; */
};
typedef union cavm_apbrom_horizontal_pidr2 cavm_apbrom_horizontal_pidr2_t;

#define CAVM_APBROM_HORIZONTAL_PIDR2 CAVM_APBROM_HORIZONTAL_PIDR2_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_PIDR2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_PIDR2_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000fe8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_PIDR2", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_PIDR2 cavm_apbrom_horizontal_pidr2_t
#define bustype_CAVM_APBROM_HORIZONTAL_PIDR2 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_PIDR2 "APBROM_HORIZONTAL_PIDR2"
#define busnum_CAVM_APBROM_HORIZONTAL_PIDR2 0
#define arguments_CAVM_APBROM_HORIZONTAL_PIDR2 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_pidr3
 *
 * APBROM Horizontal Pidr3 Register
 * The PIDR3 register is part of the set of peripheral identification registers.
 */
union cavm_apbrom_horizontal_pidr3
{
    uint32_t u;
    struct cavm_apbrom_horizontal_pidr3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t revand                : 4;  /**< [  7:  4](RO) This field indicates minor errata fixes specific to this design, for example
                                                                 metal fixes after implementation. In most cases this field is 0x0. */
        uint32_t cmod                  : 4;  /**< [  3:  0](RO) Customer Modified. Where the component is reusable IP, this value indicates if
                                                                 the customer has modified the behavior of the component. In most cases this
                                                                 field is 0x0. */
#else /* Word 0 - Little Endian */
        uint32_t cmod                  : 4;  /**< [  3:  0](RO) Customer Modified. Where the component is reusable IP, this value indicates if
                                                                 the customer has modified the behavior of the component. In most cases this
                                                                 field is 0x0. */
        uint32_t revand                : 4;  /**< [  7:  4](RO) This field indicates minor errata fixes specific to this design, for example
                                                                 metal fixes after implementation. In most cases this field is 0x0. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_pidr3_s cn; */
};
typedef union cavm_apbrom_horizontal_pidr3 cavm_apbrom_horizontal_pidr3_t;

#define CAVM_APBROM_HORIZONTAL_PIDR3 CAVM_APBROM_HORIZONTAL_PIDR3_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_PIDR3_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_PIDR3_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000fecll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_PIDR3", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_PIDR3 cavm_apbrom_horizontal_pidr3_t
#define bustype_CAVM_APBROM_HORIZONTAL_PIDR3 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_PIDR3 "APBROM_HORIZONTAL_PIDR3"
#define busnum_CAVM_APBROM_HORIZONTAL_PIDR3 0
#define arguments_CAVM_APBROM_HORIZONTAL_PIDR3 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_pidr4
 *
 * APBROM Horizontal Pidr4 Register
 * The PIDR4 register is part of the set of peripheral identification registers.
 */
union cavm_apbrom_horizontal_pidr4
{
    uint32_t u;
    struct cavm_apbrom_horizontal_pidr4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t size                  : 4;  /**< [  7:  4](RO) Indicates the memory size that is used by this component. Returns 0 indicating
                                                                 that the component uses an UNKNOWN number of 4KB blocks. Using the SIZE field to
                                                                 indicate the size of the component is deprecated. */
        uint32_t des_2                 : 4;  /**< [  3:  0](RO) JEP106 continuation code. Together, with PIDR2.DES_1 and PIDR1.DES_0, they
                                                                 indicate the designer of the component and not the implementer, except where the
                                                                 two are the same. */
#else /* Word 0 - Little Endian */
        uint32_t des_2                 : 4;  /**< [  3:  0](RO) JEP106 continuation code. Together, with PIDR2.DES_1 and PIDR1.DES_0, they
                                                                 indicate the designer of the component and not the implementer, except where the
                                                                 two are the same. */
        uint32_t size                  : 4;  /**< [  7:  4](RO) Indicates the memory size that is used by this component. Returns 0 indicating
                                                                 that the component uses an UNKNOWN number of 4KB blocks. Using the SIZE field to
                                                                 indicate the size of the component is deprecated. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_pidr4_s cn; */
};
typedef union cavm_apbrom_horizontal_pidr4 cavm_apbrom_horizontal_pidr4_t;

#define CAVM_APBROM_HORIZONTAL_PIDR4 CAVM_APBROM_HORIZONTAL_PIDR4_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_PIDR4_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_PIDR4_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000fd0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_PIDR4", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_PIDR4 cavm_apbrom_horizontal_pidr4_t
#define bustype_CAVM_APBROM_HORIZONTAL_PIDR4 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_PIDR4 "APBROM_HORIZONTAL_PIDR4"
#define busnum_CAVM_APBROM_HORIZONTAL_PIDR4 0
#define arguments_CAVM_APBROM_HORIZONTAL_PIDR4 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_pidr5
 *
 * APBROM Horizontal Pidr5 Register
 * The PIDR5 register is part of the set of peripheral identification registers.
 */
union cavm_apbrom_horizontal_pidr5
{
    uint32_t u;
    struct cavm_apbrom_horizontal_pidr5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t pidr5                 : 8;  /**< [  7:  0](RO) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t pidr5                 : 8;  /**< [  7:  0](RO) Reserved. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_pidr5_s cn; */
};
typedef union cavm_apbrom_horizontal_pidr5 cavm_apbrom_horizontal_pidr5_t;

#define CAVM_APBROM_HORIZONTAL_PIDR5 CAVM_APBROM_HORIZONTAL_PIDR5_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_PIDR5_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_PIDR5_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000fd4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_PIDR5", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_PIDR5 cavm_apbrom_horizontal_pidr5_t
#define bustype_CAVM_APBROM_HORIZONTAL_PIDR5 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_PIDR5 "APBROM_HORIZONTAL_PIDR5"
#define busnum_CAVM_APBROM_HORIZONTAL_PIDR5 0
#define arguments_CAVM_APBROM_HORIZONTAL_PIDR5 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_pidr6
 *
 * APBROM Horizontal Pidr6 Register
 * The PIDR6 register is part of the set of peripheral identification registers.
 */
union cavm_apbrom_horizontal_pidr6
{
    uint32_t u;
    struct cavm_apbrom_horizontal_pidr6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t pidr6                 : 8;  /**< [  7:  0](RO) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t pidr6                 : 8;  /**< [  7:  0](RO) Reserved. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_pidr6_s cn; */
};
typedef union cavm_apbrom_horizontal_pidr6 cavm_apbrom_horizontal_pidr6_t;

#define CAVM_APBROM_HORIZONTAL_PIDR6 CAVM_APBROM_HORIZONTAL_PIDR6_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_PIDR6_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_PIDR6_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000fd8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_PIDR6", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_PIDR6 cavm_apbrom_horizontal_pidr6_t
#define bustype_CAVM_APBROM_HORIZONTAL_PIDR6 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_PIDR6 "APBROM_HORIZONTAL_PIDR6"
#define busnum_CAVM_APBROM_HORIZONTAL_PIDR6 0
#define arguments_CAVM_APBROM_HORIZONTAL_PIDR6 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_pidr7
 *
 * APBROM Horizontal Pidr7 Register
 * The PIDR7 register is part of the set of peripheral identification registers.
 */
union cavm_apbrom_horizontal_pidr7
{
    uint32_t u;
    struct cavm_apbrom_horizontal_pidr7_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t pidr7                 : 8;  /**< [  7:  0](RO) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t pidr7                 : 8;  /**< [  7:  0](RO) Reserved. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_pidr7_s cn; */
};
typedef union cavm_apbrom_horizontal_pidr7 cavm_apbrom_horizontal_pidr7_t;

#define CAVM_APBROM_HORIZONTAL_PIDR7 CAVM_APBROM_HORIZONTAL_PIDR7_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_PIDR7_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_PIDR7_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000fdcll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_PIDR7", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_PIDR7 cavm_apbrom_horizontal_pidr7_t
#define bustype_CAVM_APBROM_HORIZONTAL_PIDR7 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_PIDR7 "APBROM_HORIZONTAL_PIDR7"
#define busnum_CAVM_APBROM_HORIZONTAL_PIDR7 0
#define arguments_CAVM_APBROM_HORIZONTAL_PIDR7 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry0
 *
 * APBROM Horizontal Romentry0 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry0
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry0_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry0 cavm_apbrom_horizontal_romentry0_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY0 CAVM_APBROM_HORIZONTAL_ROMENTRY0_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY0_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000000ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY0", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY0 cavm_apbrom_horizontal_romentry0_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY0 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY0 "APBROM_HORIZONTAL_ROMENTRY0"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY0 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY0 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry1
 *
 * APBROM Horizontal Romentry1 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry1
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry1_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry1 cavm_apbrom_horizontal_romentry1_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY1 CAVM_APBROM_HORIZONTAL_ROMENTRY1_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY1_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000004ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY1", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY1 cavm_apbrom_horizontal_romentry1_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY1 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY1 "APBROM_HORIZONTAL_ROMENTRY1"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY1 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY1 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry10
 *
 * APBROM Horizontal Romentry10 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry10
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry10_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry10_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry10 cavm_apbrom_horizontal_romentry10_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY10 CAVM_APBROM_HORIZONTAL_ROMENTRY10_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY10_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY10_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000028ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY10", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY10 cavm_apbrom_horizontal_romentry10_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY10 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY10 "APBROM_HORIZONTAL_ROMENTRY10"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY10 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY10 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry100
 *
 * APBROM Horizontal Romentry100 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry100
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry100_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry100_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry100 cavm_apbrom_horizontal_romentry100_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY100 CAVM_APBROM_HORIZONTAL_ROMENTRY100_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY100_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY100_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000190ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY100", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY100 cavm_apbrom_horizontal_romentry100_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY100 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY100 "APBROM_HORIZONTAL_ROMENTRY100"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY100 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY100 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry101
 *
 * APBROM Horizontal Romentry101 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry101
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry101_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry101_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry101 cavm_apbrom_horizontal_romentry101_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY101 CAVM_APBROM_HORIZONTAL_ROMENTRY101_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY101_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY101_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000194ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY101", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY101 cavm_apbrom_horizontal_romentry101_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY101 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY101 "APBROM_HORIZONTAL_ROMENTRY101"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY101 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY101 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry102
 *
 * APBROM Horizontal Romentry102 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry102
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry102_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry102_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry102 cavm_apbrom_horizontal_romentry102_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY102 CAVM_APBROM_HORIZONTAL_ROMENTRY102_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY102_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY102_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000198ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY102", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY102 cavm_apbrom_horizontal_romentry102_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY102 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY102 "APBROM_HORIZONTAL_ROMENTRY102"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY102 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY102 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry103
 *
 * APBROM Horizontal Romentry103 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry103
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry103_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry103_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry103 cavm_apbrom_horizontal_romentry103_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY103 CAVM_APBROM_HORIZONTAL_ROMENTRY103_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY103_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY103_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600019cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY103", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY103 cavm_apbrom_horizontal_romentry103_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY103 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY103 "APBROM_HORIZONTAL_ROMENTRY103"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY103 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY103 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry104
 *
 * APBROM Horizontal Romentry104 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry104
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry104_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry104_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry104 cavm_apbrom_horizontal_romentry104_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY104 CAVM_APBROM_HORIZONTAL_ROMENTRY104_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY104_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY104_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460001a0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY104", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY104 cavm_apbrom_horizontal_romentry104_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY104 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY104 "APBROM_HORIZONTAL_ROMENTRY104"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY104 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY104 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry105
 *
 * APBROM Horizontal Romentry105 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry105
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry105_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry105_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry105 cavm_apbrom_horizontal_romentry105_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY105 CAVM_APBROM_HORIZONTAL_ROMENTRY105_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY105_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY105_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460001a4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY105", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY105 cavm_apbrom_horizontal_romentry105_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY105 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY105 "APBROM_HORIZONTAL_ROMENTRY105"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY105 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY105 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry106
 *
 * APBROM Horizontal Romentry106 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry106
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry106_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry106_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry106 cavm_apbrom_horizontal_romentry106_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY106 CAVM_APBROM_HORIZONTAL_ROMENTRY106_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY106_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY106_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460001a8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY106", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY106 cavm_apbrom_horizontal_romentry106_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY106 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY106 "APBROM_HORIZONTAL_ROMENTRY106"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY106 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY106 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry107
 *
 * APBROM Horizontal Romentry107 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry107
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry107_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry107_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry107 cavm_apbrom_horizontal_romentry107_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY107 CAVM_APBROM_HORIZONTAL_ROMENTRY107_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY107_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY107_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460001acll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY107", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY107 cavm_apbrom_horizontal_romentry107_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY107 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY107 "APBROM_HORIZONTAL_ROMENTRY107"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY107 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY107 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry108
 *
 * APBROM Horizontal Romentry108 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry108
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry108_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry108_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry108 cavm_apbrom_horizontal_romentry108_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY108 CAVM_APBROM_HORIZONTAL_ROMENTRY108_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY108_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY108_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460001b0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY108", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY108 cavm_apbrom_horizontal_romentry108_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY108 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY108 "APBROM_HORIZONTAL_ROMENTRY108"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY108 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY108 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry109
 *
 * APBROM Horizontal Romentry109 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry109
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry109_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry109_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry109 cavm_apbrom_horizontal_romentry109_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY109 CAVM_APBROM_HORIZONTAL_ROMENTRY109_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY109_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY109_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460001b4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY109", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY109 cavm_apbrom_horizontal_romentry109_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY109 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY109 "APBROM_HORIZONTAL_ROMENTRY109"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY109 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY109 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry11
 *
 * APBROM Horizontal Romentry11 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry11
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry11_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry11_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry11 cavm_apbrom_horizontal_romentry11_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY11 CAVM_APBROM_HORIZONTAL_ROMENTRY11_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY11_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY11_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600002cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY11", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY11 cavm_apbrom_horizontal_romentry11_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY11 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY11 "APBROM_HORIZONTAL_ROMENTRY11"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY11 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY11 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry110
 *
 * APBROM Horizontal Romentry110 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry110
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry110_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry110_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry110 cavm_apbrom_horizontal_romentry110_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY110 CAVM_APBROM_HORIZONTAL_ROMENTRY110_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY110_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY110_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460001b8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY110", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY110 cavm_apbrom_horizontal_romentry110_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY110 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY110 "APBROM_HORIZONTAL_ROMENTRY110"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY110 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY110 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry111
 *
 * APBROM Horizontal Romentry111 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry111
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry111_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry111_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry111 cavm_apbrom_horizontal_romentry111_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY111 CAVM_APBROM_HORIZONTAL_ROMENTRY111_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY111_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY111_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460001bcll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY111", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY111 cavm_apbrom_horizontal_romentry111_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY111 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY111 "APBROM_HORIZONTAL_ROMENTRY111"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY111 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY111 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry112
 *
 * APBROM Horizontal Romentry112 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry112
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry112_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry112_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry112 cavm_apbrom_horizontal_romentry112_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY112 CAVM_APBROM_HORIZONTAL_ROMENTRY112_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY112_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY112_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460001c0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY112", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY112 cavm_apbrom_horizontal_romentry112_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY112 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY112 "APBROM_HORIZONTAL_ROMENTRY112"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY112 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY112 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry113
 *
 * APBROM Horizontal Romentry113 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry113
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry113_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry113_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry113 cavm_apbrom_horizontal_romentry113_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY113 CAVM_APBROM_HORIZONTAL_ROMENTRY113_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY113_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY113_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460001c4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY113", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY113 cavm_apbrom_horizontal_romentry113_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY113 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY113 "APBROM_HORIZONTAL_ROMENTRY113"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY113 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY113 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry114
 *
 * APBROM Horizontal Romentry114 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry114
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry114_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry114_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry114 cavm_apbrom_horizontal_romentry114_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY114 CAVM_APBROM_HORIZONTAL_ROMENTRY114_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY114_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY114_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460001c8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY114", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY114 cavm_apbrom_horizontal_romentry114_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY114 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY114 "APBROM_HORIZONTAL_ROMENTRY114"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY114 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY114 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry115
 *
 * APBROM Horizontal Romentry115 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry115
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry115_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry115_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry115 cavm_apbrom_horizontal_romentry115_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY115 CAVM_APBROM_HORIZONTAL_ROMENTRY115_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY115_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY115_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460001ccll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY115", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY115 cavm_apbrom_horizontal_romentry115_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY115 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY115 "APBROM_HORIZONTAL_ROMENTRY115"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY115 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY115 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry116
 *
 * APBROM Horizontal Romentry116 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry116
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry116_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry116_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry116 cavm_apbrom_horizontal_romentry116_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY116 CAVM_APBROM_HORIZONTAL_ROMENTRY116_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY116_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY116_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460001d0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY116", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY116 cavm_apbrom_horizontal_romentry116_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY116 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY116 "APBROM_HORIZONTAL_ROMENTRY116"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY116 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY116 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry117
 *
 * APBROM Horizontal Romentry117 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry117
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry117_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry117_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry117 cavm_apbrom_horizontal_romentry117_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY117 CAVM_APBROM_HORIZONTAL_ROMENTRY117_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY117_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY117_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460001d4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY117", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY117 cavm_apbrom_horizontal_romentry117_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY117 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY117 "APBROM_HORIZONTAL_ROMENTRY117"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY117 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY117 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry118
 *
 * APBROM Horizontal Romentry118 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry118
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry118_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry118_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry118 cavm_apbrom_horizontal_romentry118_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY118 CAVM_APBROM_HORIZONTAL_ROMENTRY118_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY118_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY118_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460001d8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY118", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY118 cavm_apbrom_horizontal_romentry118_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY118 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY118 "APBROM_HORIZONTAL_ROMENTRY118"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY118 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY118 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry119
 *
 * APBROM Horizontal Romentry119 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry119
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry119_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry119_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry119 cavm_apbrom_horizontal_romentry119_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY119 CAVM_APBROM_HORIZONTAL_ROMENTRY119_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY119_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY119_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460001dcll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY119", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY119 cavm_apbrom_horizontal_romentry119_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY119 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY119 "APBROM_HORIZONTAL_ROMENTRY119"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY119 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY119 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry12
 *
 * APBROM Horizontal Romentry12 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry12
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry12_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry12_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry12 cavm_apbrom_horizontal_romentry12_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY12 CAVM_APBROM_HORIZONTAL_ROMENTRY12_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY12_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY12_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000030ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY12", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY12 cavm_apbrom_horizontal_romentry12_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY12 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY12 "APBROM_HORIZONTAL_ROMENTRY12"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY12 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY12 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry120
 *
 * APBROM Horizontal Romentry120 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry120
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry120_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry120_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry120 cavm_apbrom_horizontal_romentry120_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY120 CAVM_APBROM_HORIZONTAL_ROMENTRY120_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY120_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY120_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460001e0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY120", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY120 cavm_apbrom_horizontal_romentry120_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY120 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY120 "APBROM_HORIZONTAL_ROMENTRY120"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY120 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY120 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry121
 *
 * APBROM Horizontal Romentry121 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry121
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry121_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry121_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry121 cavm_apbrom_horizontal_romentry121_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY121 CAVM_APBROM_HORIZONTAL_ROMENTRY121_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY121_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY121_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460001e4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY121", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY121 cavm_apbrom_horizontal_romentry121_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY121 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY121 "APBROM_HORIZONTAL_ROMENTRY121"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY121 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY121 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry122
 *
 * APBROM Horizontal Romentry122 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry122
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry122_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry122_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry122 cavm_apbrom_horizontal_romentry122_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY122 CAVM_APBROM_HORIZONTAL_ROMENTRY122_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY122_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY122_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460001e8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY122", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY122 cavm_apbrom_horizontal_romentry122_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY122 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY122 "APBROM_HORIZONTAL_ROMENTRY122"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY122 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY122 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry123
 *
 * APBROM Horizontal Romentry123 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry123
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry123_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry123_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry123 cavm_apbrom_horizontal_romentry123_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY123 CAVM_APBROM_HORIZONTAL_ROMENTRY123_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY123_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY123_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460001ecll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY123", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY123 cavm_apbrom_horizontal_romentry123_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY123 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY123 "APBROM_HORIZONTAL_ROMENTRY123"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY123 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY123 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry124
 *
 * APBROM Horizontal Romentry124 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry124
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry124_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry124_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry124 cavm_apbrom_horizontal_romentry124_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY124 CAVM_APBROM_HORIZONTAL_ROMENTRY124_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY124_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY124_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460001f0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY124", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY124 cavm_apbrom_horizontal_romentry124_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY124 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY124 "APBROM_HORIZONTAL_ROMENTRY124"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY124 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY124 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry125
 *
 * APBROM Horizontal Romentry125 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry125
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry125_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry125_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry125 cavm_apbrom_horizontal_romentry125_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY125 CAVM_APBROM_HORIZONTAL_ROMENTRY125_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY125_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY125_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460001f4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY125", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY125 cavm_apbrom_horizontal_romentry125_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY125 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY125 "APBROM_HORIZONTAL_ROMENTRY125"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY125 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY125 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry126
 *
 * APBROM Horizontal Romentry126 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry126
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry126_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry126_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry126 cavm_apbrom_horizontal_romentry126_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY126 CAVM_APBROM_HORIZONTAL_ROMENTRY126_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY126_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY126_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460001f8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY126", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY126 cavm_apbrom_horizontal_romentry126_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY126 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY126 "APBROM_HORIZONTAL_ROMENTRY126"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY126 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY126 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry127
 *
 * APBROM Horizontal Romentry127 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry127
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry127_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry127_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry127 cavm_apbrom_horizontal_romentry127_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY127 CAVM_APBROM_HORIZONTAL_ROMENTRY127_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY127_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY127_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460001fcll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY127", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY127 cavm_apbrom_horizontal_romentry127_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY127 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY127 "APBROM_HORIZONTAL_ROMENTRY127"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY127 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY127 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry128
 *
 * APBROM Horizontal Romentry128 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry128
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry128_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry128_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry128 cavm_apbrom_horizontal_romentry128_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY128 CAVM_APBROM_HORIZONTAL_ROMENTRY128_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY128_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY128_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000200ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY128", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY128 cavm_apbrom_horizontal_romentry128_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY128 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY128 "APBROM_HORIZONTAL_ROMENTRY128"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY128 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY128 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry129
 *
 * APBROM Horizontal Romentry129 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry129
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry129_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry129_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry129 cavm_apbrom_horizontal_romentry129_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY129 CAVM_APBROM_HORIZONTAL_ROMENTRY129_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY129_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY129_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000204ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY129", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY129 cavm_apbrom_horizontal_romentry129_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY129 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY129 "APBROM_HORIZONTAL_ROMENTRY129"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY129 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY129 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry13
 *
 * APBROM Horizontal Romentry13 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry13
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry13_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry13_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry13 cavm_apbrom_horizontal_romentry13_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY13 CAVM_APBROM_HORIZONTAL_ROMENTRY13_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY13_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY13_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000034ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY13", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY13 cavm_apbrom_horizontal_romentry13_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY13 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY13 "APBROM_HORIZONTAL_ROMENTRY13"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY13 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY13 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry130
 *
 * APBROM Horizontal Romentry130 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry130
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry130_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry130_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry130 cavm_apbrom_horizontal_romentry130_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY130 CAVM_APBROM_HORIZONTAL_ROMENTRY130_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY130_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY130_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000208ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY130", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY130 cavm_apbrom_horizontal_romentry130_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY130 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY130 "APBROM_HORIZONTAL_ROMENTRY130"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY130 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY130 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry131
 *
 * APBROM Horizontal Romentry131 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry131
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry131_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry131_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry131 cavm_apbrom_horizontal_romentry131_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY131 CAVM_APBROM_HORIZONTAL_ROMENTRY131_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY131_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY131_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600020cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY131", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY131 cavm_apbrom_horizontal_romentry131_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY131 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY131 "APBROM_HORIZONTAL_ROMENTRY131"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY131 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY131 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry132
 *
 * APBROM Horizontal Romentry132 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry132
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry132_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry132_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry132 cavm_apbrom_horizontal_romentry132_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY132 CAVM_APBROM_HORIZONTAL_ROMENTRY132_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY132_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY132_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000210ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY132", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY132 cavm_apbrom_horizontal_romentry132_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY132 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY132 "APBROM_HORIZONTAL_ROMENTRY132"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY132 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY132 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry133
 *
 * APBROM Horizontal Romentry133 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry133
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry133_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry133_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry133 cavm_apbrom_horizontal_romentry133_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY133 CAVM_APBROM_HORIZONTAL_ROMENTRY133_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY133_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY133_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000214ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY133", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY133 cavm_apbrom_horizontal_romentry133_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY133 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY133 "APBROM_HORIZONTAL_ROMENTRY133"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY133 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY133 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry134
 *
 * APBROM Horizontal Romentry134 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry134
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry134_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry134_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry134 cavm_apbrom_horizontal_romentry134_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY134 CAVM_APBROM_HORIZONTAL_ROMENTRY134_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY134_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY134_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000218ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY134", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY134 cavm_apbrom_horizontal_romentry134_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY134 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY134 "APBROM_HORIZONTAL_ROMENTRY134"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY134 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY134 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry135
 *
 * APBROM Horizontal Romentry135 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry135
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry135_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry135_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry135 cavm_apbrom_horizontal_romentry135_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY135 CAVM_APBROM_HORIZONTAL_ROMENTRY135_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY135_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY135_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600021cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY135", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY135 cavm_apbrom_horizontal_romentry135_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY135 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY135 "APBROM_HORIZONTAL_ROMENTRY135"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY135 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY135 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry136
 *
 * APBROM Horizontal Romentry136 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry136
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry136_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry136_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry136 cavm_apbrom_horizontal_romentry136_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY136 CAVM_APBROM_HORIZONTAL_ROMENTRY136_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY136_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY136_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000220ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY136", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY136 cavm_apbrom_horizontal_romentry136_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY136 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY136 "APBROM_HORIZONTAL_ROMENTRY136"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY136 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY136 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry137
 *
 * APBROM Horizontal Romentry137 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry137
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry137_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry137_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry137 cavm_apbrom_horizontal_romentry137_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY137 CAVM_APBROM_HORIZONTAL_ROMENTRY137_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY137_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY137_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000224ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY137", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY137 cavm_apbrom_horizontal_romentry137_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY137 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY137 "APBROM_HORIZONTAL_ROMENTRY137"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY137 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY137 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry138
 *
 * APBROM Horizontal Romentry138 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry138
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry138_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry138_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry138 cavm_apbrom_horizontal_romentry138_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY138 CAVM_APBROM_HORIZONTAL_ROMENTRY138_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY138_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY138_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000228ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY138", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY138 cavm_apbrom_horizontal_romentry138_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY138 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY138 "APBROM_HORIZONTAL_ROMENTRY138"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY138 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY138 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry139
 *
 * APBROM Horizontal Romentry139 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry139
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry139_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry139_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry139 cavm_apbrom_horizontal_romentry139_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY139 CAVM_APBROM_HORIZONTAL_ROMENTRY139_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY139_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY139_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600022cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY139", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY139 cavm_apbrom_horizontal_romentry139_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY139 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY139 "APBROM_HORIZONTAL_ROMENTRY139"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY139 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY139 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry14
 *
 * APBROM Horizontal Romentry14 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry14
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry14_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry14_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry14 cavm_apbrom_horizontal_romentry14_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY14 CAVM_APBROM_HORIZONTAL_ROMENTRY14_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY14_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY14_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000038ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY14", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY14 cavm_apbrom_horizontal_romentry14_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY14 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY14 "APBROM_HORIZONTAL_ROMENTRY14"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY14 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY14 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry140
 *
 * APBROM Horizontal Romentry140 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry140
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry140_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry140_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry140 cavm_apbrom_horizontal_romentry140_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY140 CAVM_APBROM_HORIZONTAL_ROMENTRY140_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY140_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY140_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000230ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY140", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY140 cavm_apbrom_horizontal_romentry140_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY140 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY140 "APBROM_HORIZONTAL_ROMENTRY140"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY140 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY140 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry141
 *
 * APBROM Horizontal Romentry141 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry141
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry141_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry141_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry141 cavm_apbrom_horizontal_romentry141_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY141 CAVM_APBROM_HORIZONTAL_ROMENTRY141_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY141_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY141_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000234ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY141", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY141 cavm_apbrom_horizontal_romentry141_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY141 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY141 "APBROM_HORIZONTAL_ROMENTRY141"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY141 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY141 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry142
 *
 * APBROM Horizontal Romentry142 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry142
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry142_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry142_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry142 cavm_apbrom_horizontal_romentry142_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY142 CAVM_APBROM_HORIZONTAL_ROMENTRY142_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY142_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY142_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000238ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY142", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY142 cavm_apbrom_horizontal_romentry142_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY142 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY142 "APBROM_HORIZONTAL_ROMENTRY142"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY142 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY142 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry143
 *
 * APBROM Horizontal Romentry143 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry143
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry143_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry143_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry143 cavm_apbrom_horizontal_romentry143_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY143 CAVM_APBROM_HORIZONTAL_ROMENTRY143_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY143_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY143_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600023cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY143", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY143 cavm_apbrom_horizontal_romentry143_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY143 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY143 "APBROM_HORIZONTAL_ROMENTRY143"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY143 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY143 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry144
 *
 * APBROM Horizontal Romentry144 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry144
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry144_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry144_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry144 cavm_apbrom_horizontal_romentry144_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY144 CAVM_APBROM_HORIZONTAL_ROMENTRY144_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY144_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY144_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000240ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY144", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY144 cavm_apbrom_horizontal_romentry144_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY144 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY144 "APBROM_HORIZONTAL_ROMENTRY144"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY144 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY144 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry145
 *
 * APBROM Horizontal Romentry145 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry145
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry145_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry145_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry145 cavm_apbrom_horizontal_romentry145_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY145 CAVM_APBROM_HORIZONTAL_ROMENTRY145_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY145_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY145_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000244ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY145", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY145 cavm_apbrom_horizontal_romentry145_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY145 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY145 "APBROM_HORIZONTAL_ROMENTRY145"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY145 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY145 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry146
 *
 * APBROM Horizontal Romentry146 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry146
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry146_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry146_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry146 cavm_apbrom_horizontal_romentry146_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY146 CAVM_APBROM_HORIZONTAL_ROMENTRY146_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY146_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY146_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000248ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY146", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY146 cavm_apbrom_horizontal_romentry146_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY146 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY146 "APBROM_HORIZONTAL_ROMENTRY146"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY146 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY146 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry147
 *
 * APBROM Horizontal Romentry147 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry147
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry147_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry147_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry147 cavm_apbrom_horizontal_romentry147_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY147 CAVM_APBROM_HORIZONTAL_ROMENTRY147_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY147_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY147_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600024cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY147", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY147 cavm_apbrom_horizontal_romentry147_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY147 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY147 "APBROM_HORIZONTAL_ROMENTRY147"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY147 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY147 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry148
 *
 * APBROM Horizontal Romentry148 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry148
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry148_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry148_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry148 cavm_apbrom_horizontal_romentry148_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY148 CAVM_APBROM_HORIZONTAL_ROMENTRY148_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY148_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY148_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000250ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY148", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY148 cavm_apbrom_horizontal_romentry148_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY148 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY148 "APBROM_HORIZONTAL_ROMENTRY148"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY148 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY148 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry149
 *
 * APBROM Horizontal Romentry149 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry149
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry149_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry149_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry149 cavm_apbrom_horizontal_romentry149_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY149 CAVM_APBROM_HORIZONTAL_ROMENTRY149_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY149_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY149_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000254ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY149", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY149 cavm_apbrom_horizontal_romentry149_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY149 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY149 "APBROM_HORIZONTAL_ROMENTRY149"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY149 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY149 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry15
 *
 * APBROM Horizontal Romentry15 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry15
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry15_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry15_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry15 cavm_apbrom_horizontal_romentry15_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY15 CAVM_APBROM_HORIZONTAL_ROMENTRY15_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY15_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY15_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600003cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY15", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY15 cavm_apbrom_horizontal_romentry15_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY15 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY15 "APBROM_HORIZONTAL_ROMENTRY15"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY15 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY15 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry150
 *
 * APBROM Horizontal Romentry150 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry150
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry150_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry150_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry150 cavm_apbrom_horizontal_romentry150_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY150 CAVM_APBROM_HORIZONTAL_ROMENTRY150_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY150_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY150_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000258ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY150", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY150 cavm_apbrom_horizontal_romentry150_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY150 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY150 "APBROM_HORIZONTAL_ROMENTRY150"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY150 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY150 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry151
 *
 * APBROM Horizontal Romentry151 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry151
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry151_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry151_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry151 cavm_apbrom_horizontal_romentry151_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY151 CAVM_APBROM_HORIZONTAL_ROMENTRY151_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY151_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY151_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600025cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY151", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY151 cavm_apbrom_horizontal_romentry151_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY151 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY151 "APBROM_HORIZONTAL_ROMENTRY151"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY151 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY151 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry152
 *
 * APBROM Horizontal Romentry152 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry152
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry152_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry152_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry152 cavm_apbrom_horizontal_romentry152_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY152 CAVM_APBROM_HORIZONTAL_ROMENTRY152_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY152_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY152_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000260ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY152", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY152 cavm_apbrom_horizontal_romentry152_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY152 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY152 "APBROM_HORIZONTAL_ROMENTRY152"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY152 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY152 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry153
 *
 * APBROM Horizontal Romentry153 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry153
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry153_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry153_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry153 cavm_apbrom_horizontal_romentry153_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY153 CAVM_APBROM_HORIZONTAL_ROMENTRY153_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY153_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY153_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000264ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY153", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY153 cavm_apbrom_horizontal_romentry153_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY153 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY153 "APBROM_HORIZONTAL_ROMENTRY153"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY153 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY153 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry154
 *
 * APBROM Horizontal Romentry154 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry154
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry154_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry154_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry154 cavm_apbrom_horizontal_romentry154_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY154 CAVM_APBROM_HORIZONTAL_ROMENTRY154_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY154_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY154_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000268ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY154", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY154 cavm_apbrom_horizontal_romentry154_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY154 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY154 "APBROM_HORIZONTAL_ROMENTRY154"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY154 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY154 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry155
 *
 * APBROM Horizontal Romentry155 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry155
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry155_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry155_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry155 cavm_apbrom_horizontal_romentry155_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY155 CAVM_APBROM_HORIZONTAL_ROMENTRY155_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY155_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY155_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600026cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY155", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY155 cavm_apbrom_horizontal_romentry155_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY155 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY155 "APBROM_HORIZONTAL_ROMENTRY155"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY155 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY155 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry156
 *
 * APBROM Horizontal Romentry156 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry156
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry156_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry156_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry156 cavm_apbrom_horizontal_romentry156_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY156 CAVM_APBROM_HORIZONTAL_ROMENTRY156_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY156_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY156_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000270ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY156", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY156 cavm_apbrom_horizontal_romentry156_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY156 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY156 "APBROM_HORIZONTAL_ROMENTRY156"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY156 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY156 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry157
 *
 * APBROM Horizontal Romentry157 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry157
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry157_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry157_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry157 cavm_apbrom_horizontal_romentry157_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY157 CAVM_APBROM_HORIZONTAL_ROMENTRY157_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY157_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY157_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000274ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY157", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY157 cavm_apbrom_horizontal_romentry157_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY157 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY157 "APBROM_HORIZONTAL_ROMENTRY157"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY157 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY157 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry158
 *
 * APBROM Horizontal Romentry158 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry158
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry158_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry158_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry158 cavm_apbrom_horizontal_romentry158_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY158 CAVM_APBROM_HORIZONTAL_ROMENTRY158_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY158_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY158_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000278ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY158", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY158 cavm_apbrom_horizontal_romentry158_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY158 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY158 "APBROM_HORIZONTAL_ROMENTRY158"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY158 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY158 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry159
 *
 * APBROM Horizontal Romentry159 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry159
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry159_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry159_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry159 cavm_apbrom_horizontal_romentry159_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY159 CAVM_APBROM_HORIZONTAL_ROMENTRY159_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY159_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY159_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600027cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY159", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY159 cavm_apbrom_horizontal_romentry159_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY159 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY159 "APBROM_HORIZONTAL_ROMENTRY159"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY159 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY159 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry16
 *
 * APBROM Horizontal Romentry16 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry16
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry16_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry16_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry16 cavm_apbrom_horizontal_romentry16_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY16 CAVM_APBROM_HORIZONTAL_ROMENTRY16_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY16_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY16_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000040ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY16", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY16 cavm_apbrom_horizontal_romentry16_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY16 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY16 "APBROM_HORIZONTAL_ROMENTRY16"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY16 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY16 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry160
 *
 * APBROM Horizontal Romentry160 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry160
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry160_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry160_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry160 cavm_apbrom_horizontal_romentry160_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY160 CAVM_APBROM_HORIZONTAL_ROMENTRY160_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY160_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY160_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000280ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY160", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY160 cavm_apbrom_horizontal_romentry160_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY160 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY160 "APBROM_HORIZONTAL_ROMENTRY160"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY160 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY160 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry161
 *
 * APBROM Horizontal Romentry161 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry161
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry161_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry161_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry161 cavm_apbrom_horizontal_romentry161_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY161 CAVM_APBROM_HORIZONTAL_ROMENTRY161_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY161_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY161_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000284ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY161", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY161 cavm_apbrom_horizontal_romentry161_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY161 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY161 "APBROM_HORIZONTAL_ROMENTRY161"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY161 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY161 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry162
 *
 * APBROM Horizontal Romentry162 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry162
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry162_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry162_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry162 cavm_apbrom_horizontal_romentry162_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY162 CAVM_APBROM_HORIZONTAL_ROMENTRY162_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY162_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY162_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000288ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY162", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY162 cavm_apbrom_horizontal_romentry162_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY162 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY162 "APBROM_HORIZONTAL_ROMENTRY162"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY162 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY162 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry163
 *
 * APBROM Horizontal Romentry163 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry163
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry163_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry163_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry163 cavm_apbrom_horizontal_romentry163_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY163 CAVM_APBROM_HORIZONTAL_ROMENTRY163_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY163_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY163_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600028cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY163", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY163 cavm_apbrom_horizontal_romentry163_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY163 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY163 "APBROM_HORIZONTAL_ROMENTRY163"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY163 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY163 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry164
 *
 * APBROM Horizontal Romentry164 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry164
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry164_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry164_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry164 cavm_apbrom_horizontal_romentry164_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY164 CAVM_APBROM_HORIZONTAL_ROMENTRY164_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY164_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY164_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000290ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY164", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY164 cavm_apbrom_horizontal_romentry164_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY164 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY164 "APBROM_HORIZONTAL_ROMENTRY164"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY164 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY164 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry165
 *
 * APBROM Horizontal Romentry165 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry165
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry165_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry165_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry165 cavm_apbrom_horizontal_romentry165_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY165 CAVM_APBROM_HORIZONTAL_ROMENTRY165_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY165_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY165_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000294ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY165", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY165 cavm_apbrom_horizontal_romentry165_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY165 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY165 "APBROM_HORIZONTAL_ROMENTRY165"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY165 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY165 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry166
 *
 * APBROM Horizontal Romentry166 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry166
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry166_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry166_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry166 cavm_apbrom_horizontal_romentry166_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY166 CAVM_APBROM_HORIZONTAL_ROMENTRY166_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY166_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY166_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000298ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY166", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY166 cavm_apbrom_horizontal_romentry166_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY166 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY166 "APBROM_HORIZONTAL_ROMENTRY166"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY166 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY166 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry167
 *
 * APBROM Horizontal Romentry167 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry167
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry167_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry167_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry167 cavm_apbrom_horizontal_romentry167_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY167 CAVM_APBROM_HORIZONTAL_ROMENTRY167_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY167_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY167_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600029cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY167", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY167 cavm_apbrom_horizontal_romentry167_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY167 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY167 "APBROM_HORIZONTAL_ROMENTRY167"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY167 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY167 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry168
 *
 * APBROM Horizontal Romentry168 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry168
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry168_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry168_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry168 cavm_apbrom_horizontal_romentry168_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY168 CAVM_APBROM_HORIZONTAL_ROMENTRY168_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY168_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY168_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460002a0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY168", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY168 cavm_apbrom_horizontal_romentry168_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY168 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY168 "APBROM_HORIZONTAL_ROMENTRY168"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY168 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY168 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry169
 *
 * APBROM Horizontal Romentry169 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry169
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry169_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry169_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry169 cavm_apbrom_horizontal_romentry169_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY169 CAVM_APBROM_HORIZONTAL_ROMENTRY169_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY169_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY169_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460002a4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY169", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY169 cavm_apbrom_horizontal_romentry169_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY169 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY169 "APBROM_HORIZONTAL_ROMENTRY169"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY169 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY169 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry17
 *
 * APBROM Horizontal Romentry17 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry17
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry17_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry17_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry17 cavm_apbrom_horizontal_romentry17_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY17 CAVM_APBROM_HORIZONTAL_ROMENTRY17_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY17_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY17_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000044ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY17", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY17 cavm_apbrom_horizontal_romentry17_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY17 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY17 "APBROM_HORIZONTAL_ROMENTRY17"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY17 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY17 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry170
 *
 * APBROM Horizontal Romentry170 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry170
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry170_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry170_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry170 cavm_apbrom_horizontal_romentry170_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY170 CAVM_APBROM_HORIZONTAL_ROMENTRY170_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY170_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY170_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460002a8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY170", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY170 cavm_apbrom_horizontal_romentry170_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY170 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY170 "APBROM_HORIZONTAL_ROMENTRY170"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY170 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY170 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry171
 *
 * APBROM Horizontal Romentry171 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry171
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry171_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry171_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry171 cavm_apbrom_horizontal_romentry171_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY171 CAVM_APBROM_HORIZONTAL_ROMENTRY171_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY171_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY171_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460002acll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY171", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY171 cavm_apbrom_horizontal_romentry171_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY171 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY171 "APBROM_HORIZONTAL_ROMENTRY171"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY171 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY171 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry172
 *
 * APBROM Horizontal Romentry172 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry172
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry172_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry172_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry172 cavm_apbrom_horizontal_romentry172_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY172 CAVM_APBROM_HORIZONTAL_ROMENTRY172_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY172_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY172_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460002b0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY172", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY172 cavm_apbrom_horizontal_romentry172_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY172 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY172 "APBROM_HORIZONTAL_ROMENTRY172"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY172 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY172 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry173
 *
 * APBROM Horizontal Romentry173 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry173
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry173_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry173_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry173 cavm_apbrom_horizontal_romentry173_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY173 CAVM_APBROM_HORIZONTAL_ROMENTRY173_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY173_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY173_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460002b4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY173", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY173 cavm_apbrom_horizontal_romentry173_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY173 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY173 "APBROM_HORIZONTAL_ROMENTRY173"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY173 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY173 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry174
 *
 * APBROM Horizontal Romentry174 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry174
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry174_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry174_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry174 cavm_apbrom_horizontal_romentry174_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY174 CAVM_APBROM_HORIZONTAL_ROMENTRY174_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY174_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY174_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460002b8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY174", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY174 cavm_apbrom_horizontal_romentry174_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY174 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY174 "APBROM_HORIZONTAL_ROMENTRY174"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY174 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY174 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry175
 *
 * APBROM Horizontal Romentry175 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry175
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry175_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry175_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry175 cavm_apbrom_horizontal_romentry175_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY175 CAVM_APBROM_HORIZONTAL_ROMENTRY175_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY175_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY175_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460002bcll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY175", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY175 cavm_apbrom_horizontal_romentry175_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY175 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY175 "APBROM_HORIZONTAL_ROMENTRY175"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY175 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY175 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry176
 *
 * APBROM Horizontal Romentry176 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry176
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry176_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry176_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry176 cavm_apbrom_horizontal_romentry176_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY176 CAVM_APBROM_HORIZONTAL_ROMENTRY176_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY176_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY176_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460002c0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY176", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY176 cavm_apbrom_horizontal_romentry176_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY176 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY176 "APBROM_HORIZONTAL_ROMENTRY176"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY176 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY176 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry177
 *
 * APBROM Horizontal Romentry177 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry177
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry177_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry177_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry177 cavm_apbrom_horizontal_romentry177_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY177 CAVM_APBROM_HORIZONTAL_ROMENTRY177_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY177_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY177_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460002c4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY177", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY177 cavm_apbrom_horizontal_romentry177_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY177 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY177 "APBROM_HORIZONTAL_ROMENTRY177"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY177 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY177 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry178
 *
 * APBROM Horizontal Romentry178 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry178
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry178_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry178_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry178 cavm_apbrom_horizontal_romentry178_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY178 CAVM_APBROM_HORIZONTAL_ROMENTRY178_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY178_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY178_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460002c8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY178", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY178 cavm_apbrom_horizontal_romentry178_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY178 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY178 "APBROM_HORIZONTAL_ROMENTRY178"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY178 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY178 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry179
 *
 * APBROM Horizontal Romentry179 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry179
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry179_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry179_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry179 cavm_apbrom_horizontal_romentry179_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY179 CAVM_APBROM_HORIZONTAL_ROMENTRY179_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY179_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY179_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460002ccll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY179", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY179 cavm_apbrom_horizontal_romentry179_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY179 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY179 "APBROM_HORIZONTAL_ROMENTRY179"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY179 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY179 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry18
 *
 * APBROM Horizontal Romentry18 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry18
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry18_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry18_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry18 cavm_apbrom_horizontal_romentry18_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY18 CAVM_APBROM_HORIZONTAL_ROMENTRY18_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY18_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY18_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000048ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY18", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY18 cavm_apbrom_horizontal_romentry18_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY18 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY18 "APBROM_HORIZONTAL_ROMENTRY18"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY18 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY18 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry180
 *
 * APBROM Horizontal Romentry180 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry180
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry180_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry180_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry180 cavm_apbrom_horizontal_romentry180_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY180 CAVM_APBROM_HORIZONTAL_ROMENTRY180_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY180_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY180_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460002d0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY180", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY180 cavm_apbrom_horizontal_romentry180_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY180 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY180 "APBROM_HORIZONTAL_ROMENTRY180"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY180 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY180 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry181
 *
 * APBROM Horizontal Romentry181 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry181
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry181_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry181_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry181 cavm_apbrom_horizontal_romentry181_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY181 CAVM_APBROM_HORIZONTAL_ROMENTRY181_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY181_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY181_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460002d4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY181", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY181 cavm_apbrom_horizontal_romentry181_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY181 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY181 "APBROM_HORIZONTAL_ROMENTRY181"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY181 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY181 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry182
 *
 * APBROM Horizontal Romentry182 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry182
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry182_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry182_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry182 cavm_apbrom_horizontal_romentry182_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY182 CAVM_APBROM_HORIZONTAL_ROMENTRY182_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY182_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY182_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460002d8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY182", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY182 cavm_apbrom_horizontal_romentry182_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY182 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY182 "APBROM_HORIZONTAL_ROMENTRY182"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY182 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY182 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry183
 *
 * APBROM Horizontal Romentry183 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry183
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry183_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry183_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry183 cavm_apbrom_horizontal_romentry183_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY183 CAVM_APBROM_HORIZONTAL_ROMENTRY183_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY183_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY183_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460002dcll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY183", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY183 cavm_apbrom_horizontal_romentry183_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY183 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY183 "APBROM_HORIZONTAL_ROMENTRY183"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY183 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY183 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry184
 *
 * APBROM Horizontal Romentry184 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry184
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry184_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry184_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry184 cavm_apbrom_horizontal_romentry184_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY184 CAVM_APBROM_HORIZONTAL_ROMENTRY184_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY184_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY184_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460002e0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY184", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY184 cavm_apbrom_horizontal_romentry184_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY184 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY184 "APBROM_HORIZONTAL_ROMENTRY184"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY184 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY184 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry185
 *
 * APBROM Horizontal Romentry185 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry185
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry185_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry185_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry185 cavm_apbrom_horizontal_romentry185_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY185 CAVM_APBROM_HORIZONTAL_ROMENTRY185_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY185_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY185_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460002e4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY185", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY185 cavm_apbrom_horizontal_romentry185_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY185 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY185 "APBROM_HORIZONTAL_ROMENTRY185"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY185 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY185 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry186
 *
 * APBROM Horizontal Romentry186 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry186
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry186_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry186_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry186 cavm_apbrom_horizontal_romentry186_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY186 CAVM_APBROM_HORIZONTAL_ROMENTRY186_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY186_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY186_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460002e8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY186", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY186 cavm_apbrom_horizontal_romentry186_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY186 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY186 "APBROM_HORIZONTAL_ROMENTRY186"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY186 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY186 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry187
 *
 * APBROM Horizontal Romentry187 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry187
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry187_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry187_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry187 cavm_apbrom_horizontal_romentry187_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY187 CAVM_APBROM_HORIZONTAL_ROMENTRY187_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY187_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY187_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460002ecll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY187", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY187 cavm_apbrom_horizontal_romentry187_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY187 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY187 "APBROM_HORIZONTAL_ROMENTRY187"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY187 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY187 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry188
 *
 * APBROM Horizontal Romentry188 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry188
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry188_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry188_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry188 cavm_apbrom_horizontal_romentry188_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY188 CAVM_APBROM_HORIZONTAL_ROMENTRY188_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY188_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY188_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460002f0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY188", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY188 cavm_apbrom_horizontal_romentry188_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY188 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY188 "APBROM_HORIZONTAL_ROMENTRY188"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY188 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY188 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry189
 *
 * APBROM Horizontal Romentry189 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry189
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry189_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry189_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry189 cavm_apbrom_horizontal_romentry189_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY189 CAVM_APBROM_HORIZONTAL_ROMENTRY189_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY189_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY189_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460002f4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY189", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY189 cavm_apbrom_horizontal_romentry189_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY189 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY189 "APBROM_HORIZONTAL_ROMENTRY189"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY189 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY189 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry19
 *
 * APBROM Horizontal Romentry19 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry19
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry19_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry19_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry19 cavm_apbrom_horizontal_romentry19_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY19 CAVM_APBROM_HORIZONTAL_ROMENTRY19_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY19_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY19_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600004cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY19", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY19 cavm_apbrom_horizontal_romentry19_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY19 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY19 "APBROM_HORIZONTAL_ROMENTRY19"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY19 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY19 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry190
 *
 * APBROM Horizontal Romentry190 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry190
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry190_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry190_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry190 cavm_apbrom_horizontal_romentry190_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY190 CAVM_APBROM_HORIZONTAL_ROMENTRY190_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY190_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY190_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460002f8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY190", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY190 cavm_apbrom_horizontal_romentry190_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY190 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY190 "APBROM_HORIZONTAL_ROMENTRY190"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY190 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY190 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry191
 *
 * APBROM Horizontal Romentry191 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry191
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry191_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry191_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry191 cavm_apbrom_horizontal_romentry191_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY191 CAVM_APBROM_HORIZONTAL_ROMENTRY191_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY191_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY191_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460002fcll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY191", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY191 cavm_apbrom_horizontal_romentry191_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY191 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY191 "APBROM_HORIZONTAL_ROMENTRY191"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY191 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY191 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry192
 *
 * APBROM Horizontal Romentry192 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry192
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry192_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry192_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry192 cavm_apbrom_horizontal_romentry192_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY192 CAVM_APBROM_HORIZONTAL_ROMENTRY192_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY192_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY192_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000300ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY192", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY192 cavm_apbrom_horizontal_romentry192_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY192 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY192 "APBROM_HORIZONTAL_ROMENTRY192"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY192 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY192 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry193
 *
 * APBROM Horizontal Romentry193 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry193
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry193_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry193_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry193 cavm_apbrom_horizontal_romentry193_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY193 CAVM_APBROM_HORIZONTAL_ROMENTRY193_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY193_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY193_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000304ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY193", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY193 cavm_apbrom_horizontal_romentry193_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY193 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY193 "APBROM_HORIZONTAL_ROMENTRY193"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY193 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY193 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry194
 *
 * APBROM Horizontal Romentry194 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry194
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry194_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry194_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry194 cavm_apbrom_horizontal_romentry194_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY194 CAVM_APBROM_HORIZONTAL_ROMENTRY194_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY194_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY194_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000308ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY194", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY194 cavm_apbrom_horizontal_romentry194_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY194 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY194 "APBROM_HORIZONTAL_ROMENTRY194"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY194 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY194 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry195
 *
 * APBROM Horizontal Romentry195 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry195
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry195_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry195_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry195 cavm_apbrom_horizontal_romentry195_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY195 CAVM_APBROM_HORIZONTAL_ROMENTRY195_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY195_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY195_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600030cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY195", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY195 cavm_apbrom_horizontal_romentry195_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY195 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY195 "APBROM_HORIZONTAL_ROMENTRY195"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY195 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY195 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry196
 *
 * APBROM Horizontal Romentry196 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry196
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry196_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry196_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry196 cavm_apbrom_horizontal_romentry196_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY196 CAVM_APBROM_HORIZONTAL_ROMENTRY196_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY196_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY196_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000310ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY196", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY196 cavm_apbrom_horizontal_romentry196_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY196 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY196 "APBROM_HORIZONTAL_ROMENTRY196"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY196 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY196 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry197
 *
 * APBROM Horizontal Romentry197 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry197
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry197_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry197_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry197 cavm_apbrom_horizontal_romentry197_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY197 CAVM_APBROM_HORIZONTAL_ROMENTRY197_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY197_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY197_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000314ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY197", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY197 cavm_apbrom_horizontal_romentry197_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY197 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY197 "APBROM_HORIZONTAL_ROMENTRY197"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY197 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY197 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry198
 *
 * APBROM Horizontal Romentry198 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry198
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry198_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry198_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry198 cavm_apbrom_horizontal_romentry198_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY198 CAVM_APBROM_HORIZONTAL_ROMENTRY198_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY198_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY198_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000318ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY198", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY198 cavm_apbrom_horizontal_romentry198_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY198 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY198 "APBROM_HORIZONTAL_ROMENTRY198"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY198 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY198 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry199
 *
 * APBROM Horizontal Romentry199 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry199
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry199_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry199_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry199 cavm_apbrom_horizontal_romentry199_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY199 CAVM_APBROM_HORIZONTAL_ROMENTRY199_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY199_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY199_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600031cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY199", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY199 cavm_apbrom_horizontal_romentry199_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY199 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY199 "APBROM_HORIZONTAL_ROMENTRY199"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY199 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY199 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry2
 *
 * APBROM Horizontal Romentry2 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry2
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry2_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry2 cavm_apbrom_horizontal_romentry2_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY2 CAVM_APBROM_HORIZONTAL_ROMENTRY2_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY2_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000008ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY2", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY2 cavm_apbrom_horizontal_romentry2_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY2 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY2 "APBROM_HORIZONTAL_ROMENTRY2"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY2 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY2 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry20
 *
 * APBROM Horizontal Romentry20 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry20
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry20_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry20_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry20 cavm_apbrom_horizontal_romentry20_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY20 CAVM_APBROM_HORIZONTAL_ROMENTRY20_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY20_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY20_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000050ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY20", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY20 cavm_apbrom_horizontal_romentry20_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY20 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY20 "APBROM_HORIZONTAL_ROMENTRY20"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY20 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY20 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry200
 *
 * APBROM Horizontal Romentry200 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry200
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry200_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry200_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry200 cavm_apbrom_horizontal_romentry200_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY200 CAVM_APBROM_HORIZONTAL_ROMENTRY200_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY200_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY200_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000320ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY200", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY200 cavm_apbrom_horizontal_romentry200_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY200 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY200 "APBROM_HORIZONTAL_ROMENTRY200"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY200 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY200 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry201
 *
 * APBROM Horizontal Romentry201 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry201
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry201_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry201_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry201 cavm_apbrom_horizontal_romentry201_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY201 CAVM_APBROM_HORIZONTAL_ROMENTRY201_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY201_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY201_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000324ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY201", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY201 cavm_apbrom_horizontal_romentry201_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY201 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY201 "APBROM_HORIZONTAL_ROMENTRY201"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY201 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY201 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry202
 *
 * APBROM Horizontal Romentry202 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry202
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry202_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry202_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry202 cavm_apbrom_horizontal_romentry202_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY202 CAVM_APBROM_HORIZONTAL_ROMENTRY202_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY202_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY202_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000328ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY202", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY202 cavm_apbrom_horizontal_romentry202_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY202 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY202 "APBROM_HORIZONTAL_ROMENTRY202"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY202 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY202 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry203
 *
 * APBROM Horizontal Romentry203 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry203
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry203_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry203_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry203 cavm_apbrom_horizontal_romentry203_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY203 CAVM_APBROM_HORIZONTAL_ROMENTRY203_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY203_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY203_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600032cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY203", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY203 cavm_apbrom_horizontal_romentry203_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY203 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY203 "APBROM_HORIZONTAL_ROMENTRY203"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY203 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY203 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry204
 *
 * APBROM Horizontal Romentry204 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry204
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry204_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry204_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry204 cavm_apbrom_horizontal_romentry204_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY204 CAVM_APBROM_HORIZONTAL_ROMENTRY204_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY204_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY204_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000330ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY204", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY204 cavm_apbrom_horizontal_romentry204_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY204 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY204 "APBROM_HORIZONTAL_ROMENTRY204"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY204 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY204 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry205
 *
 * APBROM Horizontal Romentry205 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry205
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry205_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry205_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry205 cavm_apbrom_horizontal_romentry205_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY205 CAVM_APBROM_HORIZONTAL_ROMENTRY205_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY205_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY205_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000334ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY205", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY205 cavm_apbrom_horizontal_romentry205_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY205 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY205 "APBROM_HORIZONTAL_ROMENTRY205"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY205 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY205 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry206
 *
 * APBROM Horizontal Romentry206 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry206
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry206_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry206_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry206 cavm_apbrom_horizontal_romentry206_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY206 CAVM_APBROM_HORIZONTAL_ROMENTRY206_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY206_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY206_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000338ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY206", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY206 cavm_apbrom_horizontal_romentry206_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY206 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY206 "APBROM_HORIZONTAL_ROMENTRY206"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY206 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY206 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry207
 *
 * APBROM Horizontal Romentry207 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry207
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry207_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry207_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry207 cavm_apbrom_horizontal_romentry207_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY207 CAVM_APBROM_HORIZONTAL_ROMENTRY207_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY207_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY207_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600033cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY207", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY207 cavm_apbrom_horizontal_romentry207_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY207 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY207 "APBROM_HORIZONTAL_ROMENTRY207"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY207 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY207 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry208
 *
 * APBROM Horizontal Romentry208 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry208
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry208_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry208_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry208 cavm_apbrom_horizontal_romentry208_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY208 CAVM_APBROM_HORIZONTAL_ROMENTRY208_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY208_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY208_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000340ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY208", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY208 cavm_apbrom_horizontal_romentry208_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY208 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY208 "APBROM_HORIZONTAL_ROMENTRY208"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY208 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY208 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry209
 *
 * APBROM Horizontal Romentry209 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry209
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry209_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry209_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry209 cavm_apbrom_horizontal_romentry209_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY209 CAVM_APBROM_HORIZONTAL_ROMENTRY209_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY209_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY209_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000344ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY209", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY209 cavm_apbrom_horizontal_romentry209_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY209 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY209 "APBROM_HORIZONTAL_ROMENTRY209"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY209 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY209 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry21
 *
 * APBROM Horizontal Romentry21 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry21
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry21_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry21_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry21 cavm_apbrom_horizontal_romentry21_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY21 CAVM_APBROM_HORIZONTAL_ROMENTRY21_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY21_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY21_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000054ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY21", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY21 cavm_apbrom_horizontal_romentry21_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY21 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY21 "APBROM_HORIZONTAL_ROMENTRY21"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY21 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY21 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry210
 *
 * APBROM Horizontal Romentry210 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry210
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry210_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry210_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry210 cavm_apbrom_horizontal_romentry210_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY210 CAVM_APBROM_HORIZONTAL_ROMENTRY210_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY210_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY210_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000348ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY210", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY210 cavm_apbrom_horizontal_romentry210_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY210 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY210 "APBROM_HORIZONTAL_ROMENTRY210"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY210 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY210 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry211
 *
 * APBROM Horizontal Romentry211 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry211
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry211_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry211_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry211 cavm_apbrom_horizontal_romentry211_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY211 CAVM_APBROM_HORIZONTAL_ROMENTRY211_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY211_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY211_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600034cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY211", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY211 cavm_apbrom_horizontal_romentry211_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY211 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY211 "APBROM_HORIZONTAL_ROMENTRY211"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY211 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY211 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry212
 *
 * APBROM Horizontal Romentry212 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry212
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry212_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry212_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry212 cavm_apbrom_horizontal_romentry212_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY212 CAVM_APBROM_HORIZONTAL_ROMENTRY212_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY212_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY212_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000350ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY212", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY212 cavm_apbrom_horizontal_romentry212_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY212 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY212 "APBROM_HORIZONTAL_ROMENTRY212"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY212 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY212 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry213
 *
 * APBROM Horizontal Romentry213 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry213
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry213_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry213_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry213 cavm_apbrom_horizontal_romentry213_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY213 CAVM_APBROM_HORIZONTAL_ROMENTRY213_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY213_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY213_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000354ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY213", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY213 cavm_apbrom_horizontal_romentry213_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY213 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY213 "APBROM_HORIZONTAL_ROMENTRY213"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY213 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY213 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry214
 *
 * APBROM Horizontal Romentry214 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry214
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry214_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry214_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry214 cavm_apbrom_horizontal_romentry214_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY214 CAVM_APBROM_HORIZONTAL_ROMENTRY214_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY214_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY214_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000358ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY214", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY214 cavm_apbrom_horizontal_romentry214_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY214 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY214 "APBROM_HORIZONTAL_ROMENTRY214"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY214 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY214 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry215
 *
 * APBROM Horizontal Romentry215 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry215
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry215_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry215_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry215 cavm_apbrom_horizontal_romentry215_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY215 CAVM_APBROM_HORIZONTAL_ROMENTRY215_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY215_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY215_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600035cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY215", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY215 cavm_apbrom_horizontal_romentry215_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY215 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY215 "APBROM_HORIZONTAL_ROMENTRY215"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY215 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY215 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry216
 *
 * APBROM Horizontal Romentry216 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry216
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry216_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry216_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry216 cavm_apbrom_horizontal_romentry216_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY216 CAVM_APBROM_HORIZONTAL_ROMENTRY216_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY216_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY216_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000360ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY216", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY216 cavm_apbrom_horizontal_romentry216_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY216 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY216 "APBROM_HORIZONTAL_ROMENTRY216"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY216 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY216 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry217
 *
 * APBROM Horizontal Romentry217 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry217
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry217_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry217_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry217 cavm_apbrom_horizontal_romentry217_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY217 CAVM_APBROM_HORIZONTAL_ROMENTRY217_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY217_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY217_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000364ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY217", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY217 cavm_apbrom_horizontal_romentry217_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY217 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY217 "APBROM_HORIZONTAL_ROMENTRY217"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY217 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY217 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry218
 *
 * APBROM Horizontal Romentry218 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry218
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry218_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry218_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry218 cavm_apbrom_horizontal_romentry218_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY218 CAVM_APBROM_HORIZONTAL_ROMENTRY218_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY218_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY218_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000368ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY218", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY218 cavm_apbrom_horizontal_romentry218_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY218 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY218 "APBROM_HORIZONTAL_ROMENTRY218"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY218 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY218 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry219
 *
 * APBROM Horizontal Romentry219 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry219
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry219_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry219_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry219 cavm_apbrom_horizontal_romentry219_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY219 CAVM_APBROM_HORIZONTAL_ROMENTRY219_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY219_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY219_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600036cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY219", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY219 cavm_apbrom_horizontal_romentry219_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY219 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY219 "APBROM_HORIZONTAL_ROMENTRY219"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY219 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY219 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry22
 *
 * APBROM Horizontal Romentry22 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry22
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry22_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry22_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry22 cavm_apbrom_horizontal_romentry22_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY22 CAVM_APBROM_HORIZONTAL_ROMENTRY22_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY22_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY22_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000058ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY22", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY22 cavm_apbrom_horizontal_romentry22_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY22 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY22 "APBROM_HORIZONTAL_ROMENTRY22"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY22 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY22 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry220
 *
 * APBROM Horizontal Romentry220 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry220
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry220_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry220_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry220 cavm_apbrom_horizontal_romentry220_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY220 CAVM_APBROM_HORIZONTAL_ROMENTRY220_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY220_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY220_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000370ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY220", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY220 cavm_apbrom_horizontal_romentry220_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY220 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY220 "APBROM_HORIZONTAL_ROMENTRY220"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY220 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY220 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry221
 *
 * APBROM Horizontal Romentry221 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry221
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry221_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry221_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry221 cavm_apbrom_horizontal_romentry221_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY221 CAVM_APBROM_HORIZONTAL_ROMENTRY221_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY221_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY221_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000374ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY221", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY221 cavm_apbrom_horizontal_romentry221_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY221 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY221 "APBROM_HORIZONTAL_ROMENTRY221"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY221 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY221 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry222
 *
 * APBROM Horizontal Romentry222 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry222
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry222_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry222_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry222 cavm_apbrom_horizontal_romentry222_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY222 CAVM_APBROM_HORIZONTAL_ROMENTRY222_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY222_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY222_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000378ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY222", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY222 cavm_apbrom_horizontal_romentry222_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY222 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY222 "APBROM_HORIZONTAL_ROMENTRY222"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY222 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY222 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry223
 *
 * APBROM Horizontal Romentry223 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry223
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry223_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry223_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry223 cavm_apbrom_horizontal_romentry223_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY223 CAVM_APBROM_HORIZONTAL_ROMENTRY223_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY223_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY223_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600037cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY223", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY223 cavm_apbrom_horizontal_romentry223_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY223 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY223 "APBROM_HORIZONTAL_ROMENTRY223"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY223 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY223 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry224
 *
 * APBROM Horizontal Romentry224 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry224
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry224_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry224_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry224 cavm_apbrom_horizontal_romentry224_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY224 CAVM_APBROM_HORIZONTAL_ROMENTRY224_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY224_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY224_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000380ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY224", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY224 cavm_apbrom_horizontal_romentry224_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY224 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY224 "APBROM_HORIZONTAL_ROMENTRY224"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY224 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY224 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry225
 *
 * APBROM Horizontal Romentry225 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry225
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry225_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry225_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry225 cavm_apbrom_horizontal_romentry225_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY225 CAVM_APBROM_HORIZONTAL_ROMENTRY225_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY225_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY225_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000384ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY225", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY225 cavm_apbrom_horizontal_romentry225_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY225 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY225 "APBROM_HORIZONTAL_ROMENTRY225"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY225 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY225 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry226
 *
 * APBROM Horizontal Romentry226 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry226
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry226_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry226_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry226 cavm_apbrom_horizontal_romentry226_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY226 CAVM_APBROM_HORIZONTAL_ROMENTRY226_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY226_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY226_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000388ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY226", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY226 cavm_apbrom_horizontal_romentry226_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY226 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY226 "APBROM_HORIZONTAL_ROMENTRY226"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY226 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY226 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry227
 *
 * APBROM Horizontal Romentry227 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry227
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry227_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry227_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry227 cavm_apbrom_horizontal_romentry227_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY227 CAVM_APBROM_HORIZONTAL_ROMENTRY227_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY227_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY227_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600038cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY227", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY227 cavm_apbrom_horizontal_romentry227_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY227 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY227 "APBROM_HORIZONTAL_ROMENTRY227"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY227 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY227 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry228
 *
 * APBROM Horizontal Romentry228 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry228
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry228_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry228_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry228 cavm_apbrom_horizontal_romentry228_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY228 CAVM_APBROM_HORIZONTAL_ROMENTRY228_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY228_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY228_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000390ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY228", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY228 cavm_apbrom_horizontal_romentry228_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY228 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY228 "APBROM_HORIZONTAL_ROMENTRY228"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY228 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY228 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry229
 *
 * APBROM Horizontal Romentry229 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry229
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry229_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry229_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry229 cavm_apbrom_horizontal_romentry229_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY229 CAVM_APBROM_HORIZONTAL_ROMENTRY229_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY229_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY229_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000394ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY229", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY229 cavm_apbrom_horizontal_romentry229_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY229 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY229 "APBROM_HORIZONTAL_ROMENTRY229"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY229 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY229 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry23
 *
 * APBROM Horizontal Romentry23 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry23
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry23_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry23_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry23 cavm_apbrom_horizontal_romentry23_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY23 CAVM_APBROM_HORIZONTAL_ROMENTRY23_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY23_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY23_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600005cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY23", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY23 cavm_apbrom_horizontal_romentry23_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY23 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY23 "APBROM_HORIZONTAL_ROMENTRY23"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY23 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY23 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry230
 *
 * APBROM Horizontal Romentry230 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry230
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry230_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry230_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry230 cavm_apbrom_horizontal_romentry230_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY230 CAVM_APBROM_HORIZONTAL_ROMENTRY230_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY230_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY230_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000398ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY230", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY230 cavm_apbrom_horizontal_romentry230_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY230 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY230 "APBROM_HORIZONTAL_ROMENTRY230"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY230 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY230 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry231
 *
 * APBROM Horizontal Romentry231 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry231
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry231_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry231_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry231 cavm_apbrom_horizontal_romentry231_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY231 CAVM_APBROM_HORIZONTAL_ROMENTRY231_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY231_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY231_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600039cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY231", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY231 cavm_apbrom_horizontal_romentry231_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY231 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY231 "APBROM_HORIZONTAL_ROMENTRY231"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY231 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY231 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry232
 *
 * APBROM Horizontal Romentry232 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry232
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry232_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry232_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry232 cavm_apbrom_horizontal_romentry232_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY232 CAVM_APBROM_HORIZONTAL_ROMENTRY232_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY232_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY232_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460003a0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY232", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY232 cavm_apbrom_horizontal_romentry232_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY232 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY232 "APBROM_HORIZONTAL_ROMENTRY232"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY232 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY232 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry233
 *
 * APBROM Horizontal Romentry233 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry233
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry233_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry233_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry233 cavm_apbrom_horizontal_romentry233_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY233 CAVM_APBROM_HORIZONTAL_ROMENTRY233_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY233_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY233_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460003a4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY233", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY233 cavm_apbrom_horizontal_romentry233_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY233 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY233 "APBROM_HORIZONTAL_ROMENTRY233"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY233 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY233 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry234
 *
 * APBROM Horizontal Romentry234 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry234
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry234_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry234_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry234 cavm_apbrom_horizontal_romentry234_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY234 CAVM_APBROM_HORIZONTAL_ROMENTRY234_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY234_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY234_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460003a8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY234", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY234 cavm_apbrom_horizontal_romentry234_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY234 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY234 "APBROM_HORIZONTAL_ROMENTRY234"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY234 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY234 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry235
 *
 * APBROM Horizontal Romentry235 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry235
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry235_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry235_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry235 cavm_apbrom_horizontal_romentry235_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY235 CAVM_APBROM_HORIZONTAL_ROMENTRY235_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY235_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY235_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460003acll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY235", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY235 cavm_apbrom_horizontal_romentry235_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY235 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY235 "APBROM_HORIZONTAL_ROMENTRY235"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY235 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY235 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry236
 *
 * APBROM Horizontal Romentry236 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry236
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry236_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry236_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry236 cavm_apbrom_horizontal_romentry236_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY236 CAVM_APBROM_HORIZONTAL_ROMENTRY236_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY236_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY236_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460003b0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY236", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY236 cavm_apbrom_horizontal_romentry236_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY236 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY236 "APBROM_HORIZONTAL_ROMENTRY236"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY236 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY236 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry237
 *
 * APBROM Horizontal Romentry237 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry237
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry237_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry237_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry237 cavm_apbrom_horizontal_romentry237_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY237 CAVM_APBROM_HORIZONTAL_ROMENTRY237_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY237_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY237_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460003b4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY237", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY237 cavm_apbrom_horizontal_romentry237_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY237 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY237 "APBROM_HORIZONTAL_ROMENTRY237"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY237 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY237 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry238
 *
 * APBROM Horizontal Romentry238 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry238
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry238_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry238_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry238 cavm_apbrom_horizontal_romentry238_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY238 CAVM_APBROM_HORIZONTAL_ROMENTRY238_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY238_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY238_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460003b8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY238", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY238 cavm_apbrom_horizontal_romentry238_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY238 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY238 "APBROM_HORIZONTAL_ROMENTRY238"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY238 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY238 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry239
 *
 * APBROM Horizontal Romentry239 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry239
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry239_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry239_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry239 cavm_apbrom_horizontal_romentry239_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY239 CAVM_APBROM_HORIZONTAL_ROMENTRY239_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY239_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY239_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460003bcll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY239", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY239 cavm_apbrom_horizontal_romentry239_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY239 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY239 "APBROM_HORIZONTAL_ROMENTRY239"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY239 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY239 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry24
 *
 * APBROM Horizontal Romentry24 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry24
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry24_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry24_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry24 cavm_apbrom_horizontal_romentry24_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY24 CAVM_APBROM_HORIZONTAL_ROMENTRY24_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY24_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY24_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000060ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY24", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY24 cavm_apbrom_horizontal_romentry24_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY24 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY24 "APBROM_HORIZONTAL_ROMENTRY24"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY24 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY24 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry240
 *
 * APBROM Horizontal Romentry240 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry240
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry240_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry240_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry240 cavm_apbrom_horizontal_romentry240_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY240 CAVM_APBROM_HORIZONTAL_ROMENTRY240_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY240_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY240_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460003c0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY240", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY240 cavm_apbrom_horizontal_romentry240_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY240 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY240 "APBROM_HORIZONTAL_ROMENTRY240"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY240 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY240 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry241
 *
 * APBROM Horizontal Romentry241 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry241
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry241_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry241_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry241 cavm_apbrom_horizontal_romentry241_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY241 CAVM_APBROM_HORIZONTAL_ROMENTRY241_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY241_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY241_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460003c4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY241", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY241 cavm_apbrom_horizontal_romentry241_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY241 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY241 "APBROM_HORIZONTAL_ROMENTRY241"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY241 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY241 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry242
 *
 * APBROM Horizontal Romentry242 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry242
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry242_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry242_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry242 cavm_apbrom_horizontal_romentry242_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY242 CAVM_APBROM_HORIZONTAL_ROMENTRY242_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY242_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY242_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460003c8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY242", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY242 cavm_apbrom_horizontal_romentry242_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY242 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY242 "APBROM_HORIZONTAL_ROMENTRY242"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY242 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY242 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry243
 *
 * APBROM Horizontal Romentry243 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry243
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry243_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry243_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry243 cavm_apbrom_horizontal_romentry243_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY243 CAVM_APBROM_HORIZONTAL_ROMENTRY243_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY243_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY243_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460003ccll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY243", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY243 cavm_apbrom_horizontal_romentry243_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY243 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY243 "APBROM_HORIZONTAL_ROMENTRY243"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY243 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY243 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry244
 *
 * APBROM Horizontal Romentry244 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry244
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry244_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry244_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry244 cavm_apbrom_horizontal_romentry244_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY244 CAVM_APBROM_HORIZONTAL_ROMENTRY244_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY244_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY244_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460003d0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY244", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY244 cavm_apbrom_horizontal_romentry244_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY244 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY244 "APBROM_HORIZONTAL_ROMENTRY244"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY244 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY244 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry245
 *
 * APBROM Horizontal Romentry245 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry245
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry245_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry245_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry245 cavm_apbrom_horizontal_romentry245_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY245 CAVM_APBROM_HORIZONTAL_ROMENTRY245_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY245_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY245_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460003d4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY245", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY245 cavm_apbrom_horizontal_romentry245_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY245 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY245 "APBROM_HORIZONTAL_ROMENTRY245"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY245 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY245 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry246
 *
 * APBROM Horizontal Romentry246 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry246
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry246_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry246_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry246 cavm_apbrom_horizontal_romentry246_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY246 CAVM_APBROM_HORIZONTAL_ROMENTRY246_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY246_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY246_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460003d8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY246", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY246 cavm_apbrom_horizontal_romentry246_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY246 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY246 "APBROM_HORIZONTAL_ROMENTRY246"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY246 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY246 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry247
 *
 * APBROM Horizontal Romentry247 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry247
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry247_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry247_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry247 cavm_apbrom_horizontal_romentry247_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY247 CAVM_APBROM_HORIZONTAL_ROMENTRY247_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY247_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY247_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460003dcll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY247", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY247 cavm_apbrom_horizontal_romentry247_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY247 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY247 "APBROM_HORIZONTAL_ROMENTRY247"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY247 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY247 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry248
 *
 * APBROM Horizontal Romentry248 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry248
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry248_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry248_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry248 cavm_apbrom_horizontal_romentry248_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY248 CAVM_APBROM_HORIZONTAL_ROMENTRY248_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY248_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY248_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460003e0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY248", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY248 cavm_apbrom_horizontal_romentry248_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY248 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY248 "APBROM_HORIZONTAL_ROMENTRY248"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY248 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY248 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry249
 *
 * APBROM Horizontal Romentry249 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry249
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry249_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry249_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry249 cavm_apbrom_horizontal_romentry249_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY249 CAVM_APBROM_HORIZONTAL_ROMENTRY249_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY249_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY249_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460003e4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY249", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY249 cavm_apbrom_horizontal_romentry249_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY249 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY249 "APBROM_HORIZONTAL_ROMENTRY249"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY249 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY249 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry25
 *
 * APBROM Horizontal Romentry25 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry25
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry25_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry25_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry25 cavm_apbrom_horizontal_romentry25_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY25 CAVM_APBROM_HORIZONTAL_ROMENTRY25_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY25_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY25_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000064ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY25", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY25 cavm_apbrom_horizontal_romentry25_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY25 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY25 "APBROM_HORIZONTAL_ROMENTRY25"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY25 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY25 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry250
 *
 * APBROM Horizontal Romentry250 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry250
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry250_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry250_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry250 cavm_apbrom_horizontal_romentry250_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY250 CAVM_APBROM_HORIZONTAL_ROMENTRY250_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY250_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY250_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460003e8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY250", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY250 cavm_apbrom_horizontal_romentry250_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY250 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY250 "APBROM_HORIZONTAL_ROMENTRY250"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY250 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY250 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry251
 *
 * APBROM Horizontal Romentry251 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry251
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry251_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry251_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry251 cavm_apbrom_horizontal_romentry251_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY251 CAVM_APBROM_HORIZONTAL_ROMENTRY251_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY251_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY251_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460003ecll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY251", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY251 cavm_apbrom_horizontal_romentry251_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY251 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY251 "APBROM_HORIZONTAL_ROMENTRY251"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY251 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY251 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry252
 *
 * APBROM Horizontal Romentry252 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry252
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry252_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry252_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry252 cavm_apbrom_horizontal_romentry252_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY252 CAVM_APBROM_HORIZONTAL_ROMENTRY252_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY252_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY252_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460003f0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY252", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY252 cavm_apbrom_horizontal_romentry252_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY252 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY252 "APBROM_HORIZONTAL_ROMENTRY252"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY252 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY252 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry253
 *
 * APBROM Horizontal Romentry253 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry253
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry253_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry253_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry253 cavm_apbrom_horizontal_romentry253_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY253 CAVM_APBROM_HORIZONTAL_ROMENTRY253_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY253_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY253_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460003f4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY253", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY253 cavm_apbrom_horizontal_romentry253_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY253 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY253 "APBROM_HORIZONTAL_ROMENTRY253"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY253 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY253 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry254
 *
 * APBROM Horizontal Romentry254 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry254
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry254_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry254_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry254 cavm_apbrom_horizontal_romentry254_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY254 CAVM_APBROM_HORIZONTAL_ROMENTRY254_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY254_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY254_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460003f8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY254", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY254 cavm_apbrom_horizontal_romentry254_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY254 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY254 "APBROM_HORIZONTAL_ROMENTRY254"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY254 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY254 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry255
 *
 * APBROM Horizontal Romentry255 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry255
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry255_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry255_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry255 cavm_apbrom_horizontal_romentry255_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY255 CAVM_APBROM_HORIZONTAL_ROMENTRY255_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY255_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY255_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460003fcll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY255", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY255 cavm_apbrom_horizontal_romentry255_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY255 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY255 "APBROM_HORIZONTAL_ROMENTRY255"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY255 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY255 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry256
 *
 * APBROM Horizontal Romentry256 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry256
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry256_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry256_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry256 cavm_apbrom_horizontal_romentry256_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY256 CAVM_APBROM_HORIZONTAL_ROMENTRY256_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY256_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY256_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000400ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY256", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY256 cavm_apbrom_horizontal_romentry256_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY256 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY256 "APBROM_HORIZONTAL_ROMENTRY256"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY256 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY256 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry257
 *
 * APBROM Horizontal Romentry257 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry257
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry257_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry257_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry257 cavm_apbrom_horizontal_romentry257_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY257 CAVM_APBROM_HORIZONTAL_ROMENTRY257_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY257_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY257_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000404ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY257", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY257 cavm_apbrom_horizontal_romentry257_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY257 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY257 "APBROM_HORIZONTAL_ROMENTRY257"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY257 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY257 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry258
 *
 * APBROM Horizontal Romentry258 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry258
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry258_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry258_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry258 cavm_apbrom_horizontal_romentry258_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY258 CAVM_APBROM_HORIZONTAL_ROMENTRY258_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY258_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY258_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000408ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY258", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY258 cavm_apbrom_horizontal_romentry258_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY258 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY258 "APBROM_HORIZONTAL_ROMENTRY258"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY258 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY258 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry259
 *
 * APBROM Horizontal Romentry259 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry259
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry259_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry259_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry259 cavm_apbrom_horizontal_romentry259_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY259 CAVM_APBROM_HORIZONTAL_ROMENTRY259_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY259_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY259_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600040cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY259", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY259 cavm_apbrom_horizontal_romentry259_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY259 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY259 "APBROM_HORIZONTAL_ROMENTRY259"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY259 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY259 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry26
 *
 * APBROM Horizontal Romentry26 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry26
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry26_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry26_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry26 cavm_apbrom_horizontal_romentry26_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY26 CAVM_APBROM_HORIZONTAL_ROMENTRY26_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY26_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY26_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000068ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY26", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY26 cavm_apbrom_horizontal_romentry26_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY26 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY26 "APBROM_HORIZONTAL_ROMENTRY26"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY26 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY26 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry260
 *
 * APBROM Horizontal Romentry260 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry260
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry260_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry260_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry260 cavm_apbrom_horizontal_romentry260_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY260 CAVM_APBROM_HORIZONTAL_ROMENTRY260_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY260_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY260_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000410ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY260", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY260 cavm_apbrom_horizontal_romentry260_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY260 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY260 "APBROM_HORIZONTAL_ROMENTRY260"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY260 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY260 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry261
 *
 * APBROM Horizontal Romentry261 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry261
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry261_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry261_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry261 cavm_apbrom_horizontal_romentry261_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY261 CAVM_APBROM_HORIZONTAL_ROMENTRY261_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY261_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY261_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000414ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY261", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY261 cavm_apbrom_horizontal_romentry261_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY261 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY261 "APBROM_HORIZONTAL_ROMENTRY261"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY261 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY261 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry262
 *
 * APBROM Horizontal Romentry262 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry262
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry262_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry262_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry262 cavm_apbrom_horizontal_romentry262_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY262 CAVM_APBROM_HORIZONTAL_ROMENTRY262_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY262_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY262_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000418ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY262", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY262 cavm_apbrom_horizontal_romentry262_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY262 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY262 "APBROM_HORIZONTAL_ROMENTRY262"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY262 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY262 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry263
 *
 * APBROM Horizontal Romentry263 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry263
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry263_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry263_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry263 cavm_apbrom_horizontal_romentry263_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY263 CAVM_APBROM_HORIZONTAL_ROMENTRY263_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY263_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY263_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600041cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY263", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY263 cavm_apbrom_horizontal_romentry263_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY263 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY263 "APBROM_HORIZONTAL_ROMENTRY263"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY263 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY263 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry264
 *
 * APBROM Horizontal Romentry264 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry264
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry264_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry264_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry264 cavm_apbrom_horizontal_romentry264_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY264 CAVM_APBROM_HORIZONTAL_ROMENTRY264_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY264_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY264_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000420ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY264", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY264 cavm_apbrom_horizontal_romentry264_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY264 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY264 "APBROM_HORIZONTAL_ROMENTRY264"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY264 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY264 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry265
 *
 * APBROM Horizontal Romentry265 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry265
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry265_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry265_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry265 cavm_apbrom_horizontal_romentry265_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY265 CAVM_APBROM_HORIZONTAL_ROMENTRY265_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY265_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY265_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000424ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY265", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY265 cavm_apbrom_horizontal_romentry265_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY265 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY265 "APBROM_HORIZONTAL_ROMENTRY265"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY265 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY265 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry266
 *
 * APBROM Horizontal Romentry266 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry266
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry266_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry266_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry266 cavm_apbrom_horizontal_romentry266_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY266 CAVM_APBROM_HORIZONTAL_ROMENTRY266_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY266_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY266_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000428ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY266", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY266 cavm_apbrom_horizontal_romentry266_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY266 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY266 "APBROM_HORIZONTAL_ROMENTRY266"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY266 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY266 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry267
 *
 * APBROM Horizontal Romentry267 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry267
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry267_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry267_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry267 cavm_apbrom_horizontal_romentry267_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY267 CAVM_APBROM_HORIZONTAL_ROMENTRY267_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY267_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY267_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600042cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY267", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY267 cavm_apbrom_horizontal_romentry267_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY267 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY267 "APBROM_HORIZONTAL_ROMENTRY267"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY267 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY267 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry268
 *
 * APBROM Horizontal Romentry268 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry268
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry268_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry268_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry268 cavm_apbrom_horizontal_romentry268_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY268 CAVM_APBROM_HORIZONTAL_ROMENTRY268_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY268_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY268_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000430ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY268", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY268 cavm_apbrom_horizontal_romentry268_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY268 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY268 "APBROM_HORIZONTAL_ROMENTRY268"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY268 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY268 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry269
 *
 * APBROM Horizontal Romentry269 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry269
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry269_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry269_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry269 cavm_apbrom_horizontal_romentry269_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY269 CAVM_APBROM_HORIZONTAL_ROMENTRY269_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY269_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY269_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000434ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY269", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY269 cavm_apbrom_horizontal_romentry269_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY269 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY269 "APBROM_HORIZONTAL_ROMENTRY269"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY269 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY269 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry27
 *
 * APBROM Horizontal Romentry27 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry27
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry27_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry27_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry27 cavm_apbrom_horizontal_romentry27_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY27 CAVM_APBROM_HORIZONTAL_ROMENTRY27_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY27_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY27_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600006cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY27", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY27 cavm_apbrom_horizontal_romentry27_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY27 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY27 "APBROM_HORIZONTAL_ROMENTRY27"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY27 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY27 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry270
 *
 * APBROM Horizontal Romentry270 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry270
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry270_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry270_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry270 cavm_apbrom_horizontal_romentry270_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY270 CAVM_APBROM_HORIZONTAL_ROMENTRY270_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY270_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY270_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000438ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY270", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY270 cavm_apbrom_horizontal_romentry270_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY270 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY270 "APBROM_HORIZONTAL_ROMENTRY270"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY270 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY270 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry271
 *
 * APBROM Horizontal Romentry271 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry271
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry271_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry271_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry271 cavm_apbrom_horizontal_romentry271_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY271 CAVM_APBROM_HORIZONTAL_ROMENTRY271_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY271_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY271_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600043cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY271", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY271 cavm_apbrom_horizontal_romentry271_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY271 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY271 "APBROM_HORIZONTAL_ROMENTRY271"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY271 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY271 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry272
 *
 * APBROM Horizontal Romentry272 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry272
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry272_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry272_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry272 cavm_apbrom_horizontal_romentry272_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY272 CAVM_APBROM_HORIZONTAL_ROMENTRY272_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY272_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY272_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000440ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY272", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY272 cavm_apbrom_horizontal_romentry272_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY272 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY272 "APBROM_HORIZONTAL_ROMENTRY272"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY272 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY272 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry273
 *
 * APBROM Horizontal Romentry273 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry273
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry273_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry273_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry273 cavm_apbrom_horizontal_romentry273_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY273 CAVM_APBROM_HORIZONTAL_ROMENTRY273_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY273_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY273_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000444ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY273", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY273 cavm_apbrom_horizontal_romentry273_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY273 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY273 "APBROM_HORIZONTAL_ROMENTRY273"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY273 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY273 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry274
 *
 * APBROM Horizontal Romentry274 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry274
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry274_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry274_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry274 cavm_apbrom_horizontal_romentry274_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY274 CAVM_APBROM_HORIZONTAL_ROMENTRY274_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY274_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY274_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000448ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY274", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY274 cavm_apbrom_horizontal_romentry274_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY274 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY274 "APBROM_HORIZONTAL_ROMENTRY274"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY274 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY274 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry275
 *
 * APBROM Horizontal Romentry275 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry275
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry275_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry275_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry275 cavm_apbrom_horizontal_romentry275_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY275 CAVM_APBROM_HORIZONTAL_ROMENTRY275_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY275_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY275_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600044cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY275", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY275 cavm_apbrom_horizontal_romentry275_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY275 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY275 "APBROM_HORIZONTAL_ROMENTRY275"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY275 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY275 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry276
 *
 * APBROM Horizontal Romentry276 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry276
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry276_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry276_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry276 cavm_apbrom_horizontal_romentry276_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY276 CAVM_APBROM_HORIZONTAL_ROMENTRY276_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY276_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY276_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000450ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY276", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY276 cavm_apbrom_horizontal_romentry276_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY276 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY276 "APBROM_HORIZONTAL_ROMENTRY276"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY276 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY276 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry277
 *
 * APBROM Horizontal Romentry277 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry277
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry277_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry277_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry277 cavm_apbrom_horizontal_romentry277_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY277 CAVM_APBROM_HORIZONTAL_ROMENTRY277_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY277_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY277_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000454ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY277", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY277 cavm_apbrom_horizontal_romentry277_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY277 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY277 "APBROM_HORIZONTAL_ROMENTRY277"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY277 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY277 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry278
 *
 * APBROM Horizontal Romentry278 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry278
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry278_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry278_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry278 cavm_apbrom_horizontal_romentry278_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY278 CAVM_APBROM_HORIZONTAL_ROMENTRY278_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY278_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY278_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000458ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY278", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY278 cavm_apbrom_horizontal_romentry278_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY278 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY278 "APBROM_HORIZONTAL_ROMENTRY278"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY278 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY278 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry279
 *
 * APBROM Horizontal Romentry279 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry279
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry279_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry279_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry279 cavm_apbrom_horizontal_romentry279_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY279 CAVM_APBROM_HORIZONTAL_ROMENTRY279_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY279_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY279_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600045cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY279", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY279 cavm_apbrom_horizontal_romentry279_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY279 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY279 "APBROM_HORIZONTAL_ROMENTRY279"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY279 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY279 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry28
 *
 * APBROM Horizontal Romentry28 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry28
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry28_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry28_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry28 cavm_apbrom_horizontal_romentry28_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY28 CAVM_APBROM_HORIZONTAL_ROMENTRY28_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY28_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY28_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000070ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY28", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY28 cavm_apbrom_horizontal_romentry28_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY28 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY28 "APBROM_HORIZONTAL_ROMENTRY28"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY28 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY28 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry280
 *
 * APBROM Horizontal Romentry280 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry280
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry280_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry280_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry280 cavm_apbrom_horizontal_romentry280_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY280 CAVM_APBROM_HORIZONTAL_ROMENTRY280_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY280_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY280_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000460ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY280", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY280 cavm_apbrom_horizontal_romentry280_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY280 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY280 "APBROM_HORIZONTAL_ROMENTRY280"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY280 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY280 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry281
 *
 * APBROM Horizontal Romentry281 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry281
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry281_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry281_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry281 cavm_apbrom_horizontal_romentry281_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY281 CAVM_APBROM_HORIZONTAL_ROMENTRY281_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY281_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY281_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000464ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY281", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY281 cavm_apbrom_horizontal_romentry281_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY281 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY281 "APBROM_HORIZONTAL_ROMENTRY281"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY281 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY281 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry282
 *
 * APBROM Horizontal Romentry282 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry282
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry282_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry282_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry282 cavm_apbrom_horizontal_romentry282_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY282 CAVM_APBROM_HORIZONTAL_ROMENTRY282_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY282_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY282_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000468ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY282", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY282 cavm_apbrom_horizontal_romentry282_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY282 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY282 "APBROM_HORIZONTAL_ROMENTRY282"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY282 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY282 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry283
 *
 * APBROM Horizontal Romentry283 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry283
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry283_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry283_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry283 cavm_apbrom_horizontal_romentry283_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY283 CAVM_APBROM_HORIZONTAL_ROMENTRY283_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY283_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY283_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600046cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY283", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY283 cavm_apbrom_horizontal_romentry283_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY283 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY283 "APBROM_HORIZONTAL_ROMENTRY283"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY283 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY283 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry284
 *
 * APBROM Horizontal Romentry284 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry284
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry284_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry284_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry284 cavm_apbrom_horizontal_romentry284_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY284 CAVM_APBROM_HORIZONTAL_ROMENTRY284_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY284_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY284_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000470ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY284", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY284 cavm_apbrom_horizontal_romentry284_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY284 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY284 "APBROM_HORIZONTAL_ROMENTRY284"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY284 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY284 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry285
 *
 * APBROM Horizontal Romentry285 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry285
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry285_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry285_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry285 cavm_apbrom_horizontal_romentry285_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY285 CAVM_APBROM_HORIZONTAL_ROMENTRY285_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY285_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY285_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000474ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY285", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY285 cavm_apbrom_horizontal_romentry285_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY285 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY285 "APBROM_HORIZONTAL_ROMENTRY285"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY285 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY285 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry286
 *
 * APBROM Horizontal Romentry286 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry286
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry286_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry286_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry286 cavm_apbrom_horizontal_romentry286_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY286 CAVM_APBROM_HORIZONTAL_ROMENTRY286_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY286_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY286_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000478ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY286", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY286 cavm_apbrom_horizontal_romentry286_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY286 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY286 "APBROM_HORIZONTAL_ROMENTRY286"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY286 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY286 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry287
 *
 * APBROM Horizontal Romentry287 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry287
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry287_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry287_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry287 cavm_apbrom_horizontal_romentry287_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY287 CAVM_APBROM_HORIZONTAL_ROMENTRY287_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY287_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY287_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600047cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY287", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY287 cavm_apbrom_horizontal_romentry287_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY287 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY287 "APBROM_HORIZONTAL_ROMENTRY287"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY287 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY287 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry288
 *
 * APBROM Horizontal Romentry288 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry288
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry288_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry288_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry288 cavm_apbrom_horizontal_romentry288_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY288 CAVM_APBROM_HORIZONTAL_ROMENTRY288_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY288_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY288_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000480ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY288", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY288 cavm_apbrom_horizontal_romentry288_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY288 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY288 "APBROM_HORIZONTAL_ROMENTRY288"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY288 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY288 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry289
 *
 * APBROM Horizontal Romentry289 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry289
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry289_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry289_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry289 cavm_apbrom_horizontal_romentry289_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY289 CAVM_APBROM_HORIZONTAL_ROMENTRY289_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY289_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY289_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000484ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY289", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY289 cavm_apbrom_horizontal_romentry289_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY289 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY289 "APBROM_HORIZONTAL_ROMENTRY289"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY289 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY289 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry29
 *
 * APBROM Horizontal Romentry29 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry29
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry29_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry29_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry29 cavm_apbrom_horizontal_romentry29_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY29 CAVM_APBROM_HORIZONTAL_ROMENTRY29_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY29_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY29_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000074ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY29", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY29 cavm_apbrom_horizontal_romentry29_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY29 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY29 "APBROM_HORIZONTAL_ROMENTRY29"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY29 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY29 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry290
 *
 * APBROM Horizontal Romentry290 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry290
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry290_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry290_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry290 cavm_apbrom_horizontal_romentry290_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY290 CAVM_APBROM_HORIZONTAL_ROMENTRY290_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY290_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY290_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000488ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY290", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY290 cavm_apbrom_horizontal_romentry290_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY290 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY290 "APBROM_HORIZONTAL_ROMENTRY290"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY290 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY290 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry291
 *
 * APBROM Horizontal Romentry291 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry291
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry291_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry291_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry291 cavm_apbrom_horizontal_romentry291_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY291 CAVM_APBROM_HORIZONTAL_ROMENTRY291_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY291_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY291_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600048cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY291", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY291 cavm_apbrom_horizontal_romentry291_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY291 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY291 "APBROM_HORIZONTAL_ROMENTRY291"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY291 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY291 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry292
 *
 * APBROM Horizontal Romentry292 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry292
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry292_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry292_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry292 cavm_apbrom_horizontal_romentry292_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY292 CAVM_APBROM_HORIZONTAL_ROMENTRY292_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY292_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY292_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000490ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY292", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY292 cavm_apbrom_horizontal_romentry292_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY292 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY292 "APBROM_HORIZONTAL_ROMENTRY292"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY292 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY292 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry293
 *
 * APBROM Horizontal Romentry293 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry293
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry293_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry293_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry293 cavm_apbrom_horizontal_romentry293_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY293 CAVM_APBROM_HORIZONTAL_ROMENTRY293_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY293_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY293_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000494ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY293", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY293 cavm_apbrom_horizontal_romentry293_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY293 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY293 "APBROM_HORIZONTAL_ROMENTRY293"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY293 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY293 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry294
 *
 * APBROM Horizontal Romentry294 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry294
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry294_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry294_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry294 cavm_apbrom_horizontal_romentry294_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY294 CAVM_APBROM_HORIZONTAL_ROMENTRY294_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY294_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY294_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000498ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY294", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY294 cavm_apbrom_horizontal_romentry294_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY294 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY294 "APBROM_HORIZONTAL_ROMENTRY294"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY294 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY294 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry295
 *
 * APBROM Horizontal Romentry295 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry295
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry295_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry295_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry295 cavm_apbrom_horizontal_romentry295_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY295 CAVM_APBROM_HORIZONTAL_ROMENTRY295_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY295_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY295_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600049cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY295", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY295 cavm_apbrom_horizontal_romentry295_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY295 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY295 "APBROM_HORIZONTAL_ROMENTRY295"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY295 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY295 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry296
 *
 * APBROM Horizontal Romentry296 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry296
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry296_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry296_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry296 cavm_apbrom_horizontal_romentry296_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY296 CAVM_APBROM_HORIZONTAL_ROMENTRY296_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY296_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY296_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460004a0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY296", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY296 cavm_apbrom_horizontal_romentry296_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY296 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY296 "APBROM_HORIZONTAL_ROMENTRY296"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY296 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY296 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry297
 *
 * APBROM Horizontal Romentry297 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry297
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry297_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry297_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry297 cavm_apbrom_horizontal_romentry297_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY297 CAVM_APBROM_HORIZONTAL_ROMENTRY297_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY297_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY297_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460004a4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY297", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY297 cavm_apbrom_horizontal_romentry297_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY297 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY297 "APBROM_HORIZONTAL_ROMENTRY297"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY297 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY297 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry298
 *
 * APBROM Horizontal Romentry298 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry298
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry298_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry298_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry298 cavm_apbrom_horizontal_romentry298_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY298 CAVM_APBROM_HORIZONTAL_ROMENTRY298_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY298_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY298_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460004a8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY298", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY298 cavm_apbrom_horizontal_romentry298_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY298 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY298 "APBROM_HORIZONTAL_ROMENTRY298"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY298 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY298 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry299
 *
 * APBROM Horizontal Romentry299 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry299
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry299_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry299_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry299 cavm_apbrom_horizontal_romentry299_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY299 CAVM_APBROM_HORIZONTAL_ROMENTRY299_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY299_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY299_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460004acll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY299", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY299 cavm_apbrom_horizontal_romentry299_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY299 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY299 "APBROM_HORIZONTAL_ROMENTRY299"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY299 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY299 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry3
 *
 * APBROM Horizontal Romentry3 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry3
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry3_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry3 cavm_apbrom_horizontal_romentry3_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY3 CAVM_APBROM_HORIZONTAL_ROMENTRY3_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY3_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY3_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600000cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY3", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY3 cavm_apbrom_horizontal_romentry3_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY3 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY3 "APBROM_HORIZONTAL_ROMENTRY3"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY3 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY3 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry30
 *
 * APBROM Horizontal Romentry30 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry30
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry30_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry30_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry30 cavm_apbrom_horizontal_romentry30_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY30 CAVM_APBROM_HORIZONTAL_ROMENTRY30_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY30_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY30_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000078ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY30", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY30 cavm_apbrom_horizontal_romentry30_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY30 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY30 "APBROM_HORIZONTAL_ROMENTRY30"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY30 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY30 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry300
 *
 * APBROM Horizontal Romentry300 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry300
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry300_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry300_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry300 cavm_apbrom_horizontal_romentry300_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY300 CAVM_APBROM_HORIZONTAL_ROMENTRY300_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY300_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY300_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460004b0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY300", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY300 cavm_apbrom_horizontal_romentry300_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY300 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY300 "APBROM_HORIZONTAL_ROMENTRY300"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY300 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY300 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry301
 *
 * APBROM Horizontal Romentry301 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry301
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry301_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry301_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry301 cavm_apbrom_horizontal_romentry301_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY301 CAVM_APBROM_HORIZONTAL_ROMENTRY301_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY301_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY301_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460004b4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY301", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY301 cavm_apbrom_horizontal_romentry301_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY301 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY301 "APBROM_HORIZONTAL_ROMENTRY301"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY301 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY301 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry302
 *
 * APBROM Horizontal Romentry302 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry302
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry302_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry302_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry302 cavm_apbrom_horizontal_romentry302_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY302 CAVM_APBROM_HORIZONTAL_ROMENTRY302_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY302_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY302_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460004b8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY302", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY302 cavm_apbrom_horizontal_romentry302_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY302 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY302 "APBROM_HORIZONTAL_ROMENTRY302"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY302 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY302 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry303
 *
 * APBROM Horizontal Romentry303 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry303
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry303_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry303_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry303 cavm_apbrom_horizontal_romentry303_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY303 CAVM_APBROM_HORIZONTAL_ROMENTRY303_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY303_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY303_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460004bcll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY303", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY303 cavm_apbrom_horizontal_romentry303_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY303 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY303 "APBROM_HORIZONTAL_ROMENTRY303"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY303 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY303 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry304
 *
 * APBROM Horizontal Romentry304 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry304
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry304_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry304_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry304 cavm_apbrom_horizontal_romentry304_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY304 CAVM_APBROM_HORIZONTAL_ROMENTRY304_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY304_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY304_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460004c0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY304", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY304 cavm_apbrom_horizontal_romentry304_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY304 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY304 "APBROM_HORIZONTAL_ROMENTRY304"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY304 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY304 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry305
 *
 * APBROM Horizontal Romentry305 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry305
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry305_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry305_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry305 cavm_apbrom_horizontal_romentry305_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY305 CAVM_APBROM_HORIZONTAL_ROMENTRY305_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY305_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY305_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460004c4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY305", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY305 cavm_apbrom_horizontal_romentry305_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY305 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY305 "APBROM_HORIZONTAL_ROMENTRY305"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY305 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY305 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry306
 *
 * APBROM Horizontal Romentry306 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry306
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry306_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry306_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry306 cavm_apbrom_horizontal_romentry306_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY306 CAVM_APBROM_HORIZONTAL_ROMENTRY306_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY306_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY306_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460004c8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY306", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY306 cavm_apbrom_horizontal_romentry306_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY306 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY306 "APBROM_HORIZONTAL_ROMENTRY306"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY306 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY306 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry307
 *
 * APBROM Horizontal Romentry307 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry307
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry307_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry307_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry307 cavm_apbrom_horizontal_romentry307_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY307 CAVM_APBROM_HORIZONTAL_ROMENTRY307_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY307_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY307_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460004ccll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY307", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY307 cavm_apbrom_horizontal_romentry307_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY307 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY307 "APBROM_HORIZONTAL_ROMENTRY307"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY307 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY307 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry308
 *
 * APBROM Horizontal Romentry308 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry308
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry308_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry308_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry308 cavm_apbrom_horizontal_romentry308_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY308 CAVM_APBROM_HORIZONTAL_ROMENTRY308_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY308_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY308_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460004d0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY308", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY308 cavm_apbrom_horizontal_romentry308_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY308 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY308 "APBROM_HORIZONTAL_ROMENTRY308"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY308 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY308 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry309
 *
 * APBROM Horizontal Romentry309 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry309
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry309_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry309_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry309 cavm_apbrom_horizontal_romentry309_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY309 CAVM_APBROM_HORIZONTAL_ROMENTRY309_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY309_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY309_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460004d4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY309", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY309 cavm_apbrom_horizontal_romentry309_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY309 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY309 "APBROM_HORIZONTAL_ROMENTRY309"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY309 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY309 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry31
 *
 * APBROM Horizontal Romentry31 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry31
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry31_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry31_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry31 cavm_apbrom_horizontal_romentry31_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY31 CAVM_APBROM_HORIZONTAL_ROMENTRY31_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY31_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY31_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600007cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY31", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY31 cavm_apbrom_horizontal_romentry31_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY31 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY31 "APBROM_HORIZONTAL_ROMENTRY31"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY31 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY31 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry310
 *
 * APBROM Horizontal Romentry310 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry310
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry310_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry310_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry310 cavm_apbrom_horizontal_romentry310_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY310 CAVM_APBROM_HORIZONTAL_ROMENTRY310_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY310_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY310_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460004d8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY310", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY310 cavm_apbrom_horizontal_romentry310_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY310 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY310 "APBROM_HORIZONTAL_ROMENTRY310"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY310 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY310 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry311
 *
 * APBROM Horizontal Romentry311 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry311
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry311_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry311_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry311 cavm_apbrom_horizontal_romentry311_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY311 CAVM_APBROM_HORIZONTAL_ROMENTRY311_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY311_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY311_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460004dcll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY311", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY311 cavm_apbrom_horizontal_romentry311_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY311 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY311 "APBROM_HORIZONTAL_ROMENTRY311"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY311 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY311 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry312
 *
 * APBROM Horizontal Romentry312 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry312
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry312_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry312_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry312 cavm_apbrom_horizontal_romentry312_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY312 CAVM_APBROM_HORIZONTAL_ROMENTRY312_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY312_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY312_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460004e0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY312", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY312 cavm_apbrom_horizontal_romentry312_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY312 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY312 "APBROM_HORIZONTAL_ROMENTRY312"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY312 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY312 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry313
 *
 * APBROM Horizontal Romentry313 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry313
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry313_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry313_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry313 cavm_apbrom_horizontal_romentry313_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY313 CAVM_APBROM_HORIZONTAL_ROMENTRY313_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY313_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY313_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460004e4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY313", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY313 cavm_apbrom_horizontal_romentry313_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY313 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY313 "APBROM_HORIZONTAL_ROMENTRY313"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY313 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY313 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry314
 *
 * APBROM Horizontal Romentry314 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry314
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry314_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry314_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry314 cavm_apbrom_horizontal_romentry314_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY314 CAVM_APBROM_HORIZONTAL_ROMENTRY314_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY314_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY314_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460004e8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY314", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY314 cavm_apbrom_horizontal_romentry314_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY314 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY314 "APBROM_HORIZONTAL_ROMENTRY314"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY314 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY314 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry315
 *
 * APBROM Horizontal Romentry315 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry315
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry315_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry315_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry315 cavm_apbrom_horizontal_romentry315_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY315 CAVM_APBROM_HORIZONTAL_ROMENTRY315_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY315_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY315_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460004ecll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY315", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY315 cavm_apbrom_horizontal_romentry315_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY315 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY315 "APBROM_HORIZONTAL_ROMENTRY315"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY315 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY315 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry316
 *
 * APBROM Horizontal Romentry316 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry316
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry316_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry316_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry316 cavm_apbrom_horizontal_romentry316_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY316 CAVM_APBROM_HORIZONTAL_ROMENTRY316_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY316_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY316_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460004f0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY316", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY316 cavm_apbrom_horizontal_romentry316_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY316 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY316 "APBROM_HORIZONTAL_ROMENTRY316"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY316 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY316 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry317
 *
 * APBROM Horizontal Romentry317 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry317
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry317_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry317_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry317 cavm_apbrom_horizontal_romentry317_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY317 CAVM_APBROM_HORIZONTAL_ROMENTRY317_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY317_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY317_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460004f4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY317", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY317 cavm_apbrom_horizontal_romentry317_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY317 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY317 "APBROM_HORIZONTAL_ROMENTRY317"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY317 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY317 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry318
 *
 * APBROM Horizontal Romentry318 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry318
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry318_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry318_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry318 cavm_apbrom_horizontal_romentry318_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY318 CAVM_APBROM_HORIZONTAL_ROMENTRY318_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY318_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY318_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460004f8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY318", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY318 cavm_apbrom_horizontal_romentry318_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY318 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY318 "APBROM_HORIZONTAL_ROMENTRY318"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY318 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY318 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry319
 *
 * APBROM Horizontal Romentry319 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry319
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry319_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry319_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry319 cavm_apbrom_horizontal_romentry319_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY319 CAVM_APBROM_HORIZONTAL_ROMENTRY319_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY319_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY319_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460004fcll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY319", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY319 cavm_apbrom_horizontal_romentry319_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY319 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY319 "APBROM_HORIZONTAL_ROMENTRY319"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY319 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY319 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry32
 *
 * APBROM Horizontal Romentry32 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry32
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry32_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry32_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry32 cavm_apbrom_horizontal_romentry32_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY32 CAVM_APBROM_HORIZONTAL_ROMENTRY32_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY32_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY32_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000080ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY32", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY32 cavm_apbrom_horizontal_romentry32_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY32 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY32 "APBROM_HORIZONTAL_ROMENTRY32"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY32 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY32 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry320
 *
 * APBROM Horizontal Romentry320 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry320
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry320_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry320_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry320 cavm_apbrom_horizontal_romentry320_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY320 CAVM_APBROM_HORIZONTAL_ROMENTRY320_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY320_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY320_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000500ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY320", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY320 cavm_apbrom_horizontal_romentry320_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY320 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY320 "APBROM_HORIZONTAL_ROMENTRY320"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY320 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY320 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry321
 *
 * APBROM Horizontal Romentry321 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry321
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry321_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry321_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry321 cavm_apbrom_horizontal_romentry321_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY321 CAVM_APBROM_HORIZONTAL_ROMENTRY321_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY321_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY321_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000504ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY321", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY321 cavm_apbrom_horizontal_romentry321_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY321 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY321 "APBROM_HORIZONTAL_ROMENTRY321"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY321 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY321 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry322
 *
 * APBROM Horizontal Romentry322 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry322
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry322_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry322_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry322 cavm_apbrom_horizontal_romentry322_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY322 CAVM_APBROM_HORIZONTAL_ROMENTRY322_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY322_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY322_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000508ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY322", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY322 cavm_apbrom_horizontal_romentry322_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY322 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY322 "APBROM_HORIZONTAL_ROMENTRY322"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY322 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY322 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry323
 *
 * APBROM Horizontal Romentry323 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry323
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry323_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry323_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry323 cavm_apbrom_horizontal_romentry323_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY323 CAVM_APBROM_HORIZONTAL_ROMENTRY323_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY323_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY323_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600050cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY323", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY323 cavm_apbrom_horizontal_romentry323_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY323 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY323 "APBROM_HORIZONTAL_ROMENTRY323"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY323 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY323 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry324
 *
 * APBROM Horizontal Romentry324 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry324
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry324_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry324_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry324 cavm_apbrom_horizontal_romentry324_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY324 CAVM_APBROM_HORIZONTAL_ROMENTRY324_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY324_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY324_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000510ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY324", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY324 cavm_apbrom_horizontal_romentry324_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY324 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY324 "APBROM_HORIZONTAL_ROMENTRY324"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY324 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY324 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry325
 *
 * APBROM Horizontal Romentry325 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry325
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry325_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry325_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry325 cavm_apbrom_horizontal_romentry325_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY325 CAVM_APBROM_HORIZONTAL_ROMENTRY325_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY325_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY325_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000514ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY325", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY325 cavm_apbrom_horizontal_romentry325_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY325 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY325 "APBROM_HORIZONTAL_ROMENTRY325"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY325 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY325 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry326
 *
 * APBROM Horizontal Romentry326 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry326
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry326_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry326_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry326 cavm_apbrom_horizontal_romentry326_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY326 CAVM_APBROM_HORIZONTAL_ROMENTRY326_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY326_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY326_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000518ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY326", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY326 cavm_apbrom_horizontal_romentry326_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY326 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY326 "APBROM_HORIZONTAL_ROMENTRY326"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY326 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY326 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry327
 *
 * APBROM Horizontal Romentry327 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry327
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry327_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry327_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry327 cavm_apbrom_horizontal_romentry327_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY327 CAVM_APBROM_HORIZONTAL_ROMENTRY327_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY327_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY327_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600051cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY327", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY327 cavm_apbrom_horizontal_romentry327_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY327 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY327 "APBROM_HORIZONTAL_ROMENTRY327"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY327 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY327 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry328
 *
 * APBROM Horizontal Romentry328 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry328
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry328_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry328_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry328 cavm_apbrom_horizontal_romentry328_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY328 CAVM_APBROM_HORIZONTAL_ROMENTRY328_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY328_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY328_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000520ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY328", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY328 cavm_apbrom_horizontal_romentry328_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY328 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY328 "APBROM_HORIZONTAL_ROMENTRY328"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY328 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY328 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry329
 *
 * APBROM Horizontal Romentry329 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry329
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry329_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry329_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry329 cavm_apbrom_horizontal_romentry329_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY329 CAVM_APBROM_HORIZONTAL_ROMENTRY329_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY329_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY329_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000524ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY329", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY329 cavm_apbrom_horizontal_romentry329_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY329 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY329 "APBROM_HORIZONTAL_ROMENTRY329"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY329 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY329 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry33
 *
 * APBROM Horizontal Romentry33 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry33
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry33_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry33_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry33 cavm_apbrom_horizontal_romentry33_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY33 CAVM_APBROM_HORIZONTAL_ROMENTRY33_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY33_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY33_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000084ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY33", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY33 cavm_apbrom_horizontal_romentry33_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY33 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY33 "APBROM_HORIZONTAL_ROMENTRY33"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY33 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY33 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry330
 *
 * APBROM Horizontal Romentry330 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry330
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry330_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry330_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry330 cavm_apbrom_horizontal_romentry330_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY330 CAVM_APBROM_HORIZONTAL_ROMENTRY330_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY330_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY330_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000528ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY330", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY330 cavm_apbrom_horizontal_romentry330_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY330 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY330 "APBROM_HORIZONTAL_ROMENTRY330"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY330 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY330 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry331
 *
 * APBROM Horizontal Romentry331 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry331
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry331_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry331_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry331 cavm_apbrom_horizontal_romentry331_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY331 CAVM_APBROM_HORIZONTAL_ROMENTRY331_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY331_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY331_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600052cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY331", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY331 cavm_apbrom_horizontal_romentry331_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY331 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY331 "APBROM_HORIZONTAL_ROMENTRY331"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY331 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY331 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry332
 *
 * APBROM Horizontal Romentry332 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry332
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry332_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry332_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry332 cavm_apbrom_horizontal_romentry332_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY332 CAVM_APBROM_HORIZONTAL_ROMENTRY332_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY332_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY332_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000530ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY332", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY332 cavm_apbrom_horizontal_romentry332_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY332 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY332 "APBROM_HORIZONTAL_ROMENTRY332"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY332 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY332 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry333
 *
 * APBROM Horizontal Romentry333 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry333
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry333_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry333_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry333 cavm_apbrom_horizontal_romentry333_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY333 CAVM_APBROM_HORIZONTAL_ROMENTRY333_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY333_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY333_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000534ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY333", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY333 cavm_apbrom_horizontal_romentry333_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY333 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY333 "APBROM_HORIZONTAL_ROMENTRY333"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY333 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY333 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry334
 *
 * APBROM Horizontal Romentry334 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry334
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry334_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry334_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry334 cavm_apbrom_horizontal_romentry334_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY334 CAVM_APBROM_HORIZONTAL_ROMENTRY334_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY334_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY334_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000538ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY334", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY334 cavm_apbrom_horizontal_romentry334_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY334 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY334 "APBROM_HORIZONTAL_ROMENTRY334"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY334 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY334 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry335
 *
 * APBROM Horizontal Romentry335 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry335
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry335_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry335_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry335 cavm_apbrom_horizontal_romentry335_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY335 CAVM_APBROM_HORIZONTAL_ROMENTRY335_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY335_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY335_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600053cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY335", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY335 cavm_apbrom_horizontal_romentry335_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY335 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY335 "APBROM_HORIZONTAL_ROMENTRY335"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY335 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY335 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry336
 *
 * APBROM Horizontal Romentry336 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry336
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry336_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry336_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry336 cavm_apbrom_horizontal_romentry336_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY336 CAVM_APBROM_HORIZONTAL_ROMENTRY336_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY336_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY336_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000540ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY336", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY336 cavm_apbrom_horizontal_romentry336_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY336 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY336 "APBROM_HORIZONTAL_ROMENTRY336"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY336 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY336 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry337
 *
 * APBROM Horizontal Romentry337 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry337
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry337_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry337_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry337 cavm_apbrom_horizontal_romentry337_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY337 CAVM_APBROM_HORIZONTAL_ROMENTRY337_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY337_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY337_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000544ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY337", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY337 cavm_apbrom_horizontal_romentry337_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY337 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY337 "APBROM_HORIZONTAL_ROMENTRY337"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY337 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY337 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry338
 *
 * APBROM Horizontal Romentry338 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry338
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry338_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry338_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry338 cavm_apbrom_horizontal_romentry338_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY338 CAVM_APBROM_HORIZONTAL_ROMENTRY338_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY338_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY338_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000548ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY338", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY338 cavm_apbrom_horizontal_romentry338_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY338 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY338 "APBROM_HORIZONTAL_ROMENTRY338"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY338 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY338 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry339
 *
 * APBROM Horizontal Romentry339 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry339
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry339_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry339_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry339 cavm_apbrom_horizontal_romentry339_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY339 CAVM_APBROM_HORIZONTAL_ROMENTRY339_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY339_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY339_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600054cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY339", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY339 cavm_apbrom_horizontal_romentry339_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY339 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY339 "APBROM_HORIZONTAL_ROMENTRY339"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY339 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY339 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry34
 *
 * APBROM Horizontal Romentry34 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry34
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry34_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry34_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry34 cavm_apbrom_horizontal_romentry34_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY34 CAVM_APBROM_HORIZONTAL_ROMENTRY34_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY34_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY34_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000088ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY34", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY34 cavm_apbrom_horizontal_romentry34_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY34 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY34 "APBROM_HORIZONTAL_ROMENTRY34"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY34 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY34 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry340
 *
 * APBROM Horizontal Romentry340 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry340
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry340_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry340_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry340 cavm_apbrom_horizontal_romentry340_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY340 CAVM_APBROM_HORIZONTAL_ROMENTRY340_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY340_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY340_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000550ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY340", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY340 cavm_apbrom_horizontal_romentry340_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY340 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY340 "APBROM_HORIZONTAL_ROMENTRY340"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY340 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY340 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry341
 *
 * APBROM Horizontal Romentry341 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry341
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry341_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry341_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry341 cavm_apbrom_horizontal_romentry341_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY341 CAVM_APBROM_HORIZONTAL_ROMENTRY341_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY341_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY341_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000554ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY341", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY341 cavm_apbrom_horizontal_romentry341_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY341 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY341 "APBROM_HORIZONTAL_ROMENTRY341"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY341 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY341 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry342
 *
 * APBROM Horizontal Romentry342 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry342
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry342_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry342_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry342 cavm_apbrom_horizontal_romentry342_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY342 CAVM_APBROM_HORIZONTAL_ROMENTRY342_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY342_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY342_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000558ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY342", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY342 cavm_apbrom_horizontal_romentry342_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY342 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY342 "APBROM_HORIZONTAL_ROMENTRY342"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY342 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY342 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry343
 *
 * APBROM Horizontal Romentry343 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry343
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry343_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry343_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry343 cavm_apbrom_horizontal_romentry343_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY343 CAVM_APBROM_HORIZONTAL_ROMENTRY343_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY343_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY343_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600055cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY343", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY343 cavm_apbrom_horizontal_romentry343_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY343 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY343 "APBROM_HORIZONTAL_ROMENTRY343"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY343 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY343 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry344
 *
 * APBROM Horizontal Romentry344 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry344
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry344_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry344_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry344 cavm_apbrom_horizontal_romentry344_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY344 CAVM_APBROM_HORIZONTAL_ROMENTRY344_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY344_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY344_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000560ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY344", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY344 cavm_apbrom_horizontal_romentry344_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY344 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY344 "APBROM_HORIZONTAL_ROMENTRY344"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY344 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY344 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry345
 *
 * APBROM Horizontal Romentry345 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry345
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry345_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry345_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry345 cavm_apbrom_horizontal_romentry345_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY345 CAVM_APBROM_HORIZONTAL_ROMENTRY345_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY345_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY345_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000564ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY345", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY345 cavm_apbrom_horizontal_romentry345_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY345 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY345 "APBROM_HORIZONTAL_ROMENTRY345"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY345 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY345 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry346
 *
 * APBROM Horizontal Romentry346 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry346
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry346_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry346_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry346 cavm_apbrom_horizontal_romentry346_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY346 CAVM_APBROM_HORIZONTAL_ROMENTRY346_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY346_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY346_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000568ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY346", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY346 cavm_apbrom_horizontal_romentry346_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY346 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY346 "APBROM_HORIZONTAL_ROMENTRY346"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY346 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY346 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry347
 *
 * APBROM Horizontal Romentry347 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry347
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry347_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry347_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry347 cavm_apbrom_horizontal_romentry347_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY347 CAVM_APBROM_HORIZONTAL_ROMENTRY347_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY347_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY347_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600056cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY347", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY347 cavm_apbrom_horizontal_romentry347_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY347 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY347 "APBROM_HORIZONTAL_ROMENTRY347"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY347 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY347 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry348
 *
 * APBROM Horizontal Romentry348 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry348
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry348_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry348_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry348 cavm_apbrom_horizontal_romentry348_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY348 CAVM_APBROM_HORIZONTAL_ROMENTRY348_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY348_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY348_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000570ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY348", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY348 cavm_apbrom_horizontal_romentry348_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY348 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY348 "APBROM_HORIZONTAL_ROMENTRY348"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY348 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY348 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry349
 *
 * APBROM Horizontal Romentry349 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry349
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry349_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry349_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry349 cavm_apbrom_horizontal_romentry349_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY349 CAVM_APBROM_HORIZONTAL_ROMENTRY349_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY349_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY349_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000574ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY349", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY349 cavm_apbrom_horizontal_romentry349_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY349 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY349 "APBROM_HORIZONTAL_ROMENTRY349"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY349 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY349 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry35
 *
 * APBROM Horizontal Romentry35 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry35
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry35_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry35_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry35 cavm_apbrom_horizontal_romentry35_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY35 CAVM_APBROM_HORIZONTAL_ROMENTRY35_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY35_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY35_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600008cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY35", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY35 cavm_apbrom_horizontal_romentry35_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY35 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY35 "APBROM_HORIZONTAL_ROMENTRY35"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY35 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY35 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry350
 *
 * APBROM Horizontal Romentry350 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry350
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry350_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry350_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry350 cavm_apbrom_horizontal_romentry350_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY350 CAVM_APBROM_HORIZONTAL_ROMENTRY350_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY350_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY350_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000578ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY350", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY350 cavm_apbrom_horizontal_romentry350_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY350 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY350 "APBROM_HORIZONTAL_ROMENTRY350"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY350 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY350 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry351
 *
 * APBROM Horizontal Romentry351 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry351
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry351_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry351_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry351 cavm_apbrom_horizontal_romentry351_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY351 CAVM_APBROM_HORIZONTAL_ROMENTRY351_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY351_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY351_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600057cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY351", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY351 cavm_apbrom_horizontal_romentry351_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY351 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY351 "APBROM_HORIZONTAL_ROMENTRY351"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY351 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY351 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry352
 *
 * APBROM Horizontal Romentry352 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry352
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry352_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry352_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry352 cavm_apbrom_horizontal_romentry352_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY352 CAVM_APBROM_HORIZONTAL_ROMENTRY352_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY352_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY352_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000580ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY352", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY352 cavm_apbrom_horizontal_romentry352_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY352 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY352 "APBROM_HORIZONTAL_ROMENTRY352"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY352 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY352 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry353
 *
 * APBROM Horizontal Romentry353 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry353
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry353_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry353_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry353 cavm_apbrom_horizontal_romentry353_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY353 CAVM_APBROM_HORIZONTAL_ROMENTRY353_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY353_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY353_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000584ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY353", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY353 cavm_apbrom_horizontal_romentry353_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY353 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY353 "APBROM_HORIZONTAL_ROMENTRY353"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY353 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY353 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry354
 *
 * APBROM Horizontal Romentry354 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry354
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry354_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry354_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry354 cavm_apbrom_horizontal_romentry354_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY354 CAVM_APBROM_HORIZONTAL_ROMENTRY354_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY354_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY354_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000588ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY354", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY354 cavm_apbrom_horizontal_romentry354_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY354 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY354 "APBROM_HORIZONTAL_ROMENTRY354"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY354 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY354 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry355
 *
 * APBROM Horizontal Romentry355 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry355
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry355_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry355_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry355 cavm_apbrom_horizontal_romentry355_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY355 CAVM_APBROM_HORIZONTAL_ROMENTRY355_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY355_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY355_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600058cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY355", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY355 cavm_apbrom_horizontal_romentry355_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY355 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY355 "APBROM_HORIZONTAL_ROMENTRY355"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY355 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY355 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry356
 *
 * APBROM Horizontal Romentry356 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry356
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry356_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry356_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry356 cavm_apbrom_horizontal_romentry356_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY356 CAVM_APBROM_HORIZONTAL_ROMENTRY356_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY356_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY356_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000590ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY356", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY356 cavm_apbrom_horizontal_romentry356_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY356 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY356 "APBROM_HORIZONTAL_ROMENTRY356"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY356 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY356 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry357
 *
 * APBROM Horizontal Romentry357 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry357
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry357_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry357_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry357 cavm_apbrom_horizontal_romentry357_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY357 CAVM_APBROM_HORIZONTAL_ROMENTRY357_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY357_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY357_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000594ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY357", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY357 cavm_apbrom_horizontal_romentry357_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY357 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY357 "APBROM_HORIZONTAL_ROMENTRY357"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY357 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY357 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry358
 *
 * APBROM Horizontal Romentry358 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry358
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry358_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry358_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry358 cavm_apbrom_horizontal_romentry358_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY358 CAVM_APBROM_HORIZONTAL_ROMENTRY358_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY358_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY358_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000598ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY358", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY358 cavm_apbrom_horizontal_romentry358_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY358 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY358 "APBROM_HORIZONTAL_ROMENTRY358"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY358 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY358 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry359
 *
 * APBROM Horizontal Romentry359 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry359
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry359_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry359_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry359 cavm_apbrom_horizontal_romentry359_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY359 CAVM_APBROM_HORIZONTAL_ROMENTRY359_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY359_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY359_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600059cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY359", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY359 cavm_apbrom_horizontal_romentry359_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY359 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY359 "APBROM_HORIZONTAL_ROMENTRY359"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY359 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY359 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry36
 *
 * APBROM Horizontal Romentry36 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry36
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry36_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry36_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry36 cavm_apbrom_horizontal_romentry36_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY36 CAVM_APBROM_HORIZONTAL_ROMENTRY36_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY36_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY36_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000090ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY36", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY36 cavm_apbrom_horizontal_romentry36_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY36 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY36 "APBROM_HORIZONTAL_ROMENTRY36"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY36 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY36 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry360
 *
 * APBROM Horizontal Romentry360 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry360
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry360_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry360_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry360 cavm_apbrom_horizontal_romentry360_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY360 CAVM_APBROM_HORIZONTAL_ROMENTRY360_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY360_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY360_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460005a0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY360", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY360 cavm_apbrom_horizontal_romentry360_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY360 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY360 "APBROM_HORIZONTAL_ROMENTRY360"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY360 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY360 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry361
 *
 * APBROM Horizontal Romentry361 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry361
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry361_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry361_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry361 cavm_apbrom_horizontal_romentry361_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY361 CAVM_APBROM_HORIZONTAL_ROMENTRY361_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY361_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY361_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460005a4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY361", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY361 cavm_apbrom_horizontal_romentry361_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY361 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY361 "APBROM_HORIZONTAL_ROMENTRY361"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY361 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY361 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry362
 *
 * APBROM Horizontal Romentry362 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry362
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry362_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry362_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry362 cavm_apbrom_horizontal_romentry362_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY362 CAVM_APBROM_HORIZONTAL_ROMENTRY362_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY362_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY362_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460005a8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY362", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY362 cavm_apbrom_horizontal_romentry362_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY362 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY362 "APBROM_HORIZONTAL_ROMENTRY362"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY362 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY362 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry363
 *
 * APBROM Horizontal Romentry363 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry363
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry363_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry363_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry363 cavm_apbrom_horizontal_romentry363_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY363 CAVM_APBROM_HORIZONTAL_ROMENTRY363_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY363_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY363_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460005acll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY363", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY363 cavm_apbrom_horizontal_romentry363_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY363 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY363 "APBROM_HORIZONTAL_ROMENTRY363"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY363 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY363 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry364
 *
 * APBROM Horizontal Romentry364 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry364
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry364_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry364_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry364 cavm_apbrom_horizontal_romentry364_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY364 CAVM_APBROM_HORIZONTAL_ROMENTRY364_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY364_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY364_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460005b0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY364", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY364 cavm_apbrom_horizontal_romentry364_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY364 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY364 "APBROM_HORIZONTAL_ROMENTRY364"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY364 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY364 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry365
 *
 * APBROM Horizontal Romentry365 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry365
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry365_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry365_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry365 cavm_apbrom_horizontal_romentry365_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY365 CAVM_APBROM_HORIZONTAL_ROMENTRY365_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY365_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY365_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460005b4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY365", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY365 cavm_apbrom_horizontal_romentry365_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY365 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY365 "APBROM_HORIZONTAL_ROMENTRY365"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY365 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY365 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry366
 *
 * APBROM Horizontal Romentry366 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry366
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry366_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry366_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry366 cavm_apbrom_horizontal_romentry366_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY366 CAVM_APBROM_HORIZONTAL_ROMENTRY366_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY366_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY366_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460005b8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY366", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY366 cavm_apbrom_horizontal_romentry366_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY366 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY366 "APBROM_HORIZONTAL_ROMENTRY366"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY366 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY366 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry367
 *
 * APBROM Horizontal Romentry367 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry367
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry367_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry367_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry367 cavm_apbrom_horizontal_romentry367_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY367 CAVM_APBROM_HORIZONTAL_ROMENTRY367_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY367_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY367_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460005bcll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY367", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY367 cavm_apbrom_horizontal_romentry367_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY367 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY367 "APBROM_HORIZONTAL_ROMENTRY367"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY367 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY367 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry368
 *
 * APBROM Horizontal Romentry368 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry368
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry368_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry368_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry368 cavm_apbrom_horizontal_romentry368_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY368 CAVM_APBROM_HORIZONTAL_ROMENTRY368_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY368_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY368_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460005c0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY368", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY368 cavm_apbrom_horizontal_romentry368_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY368 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY368 "APBROM_HORIZONTAL_ROMENTRY368"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY368 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY368 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry369
 *
 * APBROM Horizontal Romentry369 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry369
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry369_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry369_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry369 cavm_apbrom_horizontal_romentry369_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY369 CAVM_APBROM_HORIZONTAL_ROMENTRY369_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY369_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY369_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460005c4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY369", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY369 cavm_apbrom_horizontal_romentry369_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY369 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY369 "APBROM_HORIZONTAL_ROMENTRY369"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY369 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY369 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry37
 *
 * APBROM Horizontal Romentry37 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry37
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry37_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry37_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry37 cavm_apbrom_horizontal_romentry37_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY37 CAVM_APBROM_HORIZONTAL_ROMENTRY37_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY37_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY37_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000094ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY37", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY37 cavm_apbrom_horizontal_romentry37_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY37 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY37 "APBROM_HORIZONTAL_ROMENTRY37"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY37 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY37 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry370
 *
 * APBROM Horizontal Romentry370 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry370
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry370_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry370_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry370 cavm_apbrom_horizontal_romentry370_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY370 CAVM_APBROM_HORIZONTAL_ROMENTRY370_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY370_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY370_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460005c8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY370", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY370 cavm_apbrom_horizontal_romentry370_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY370 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY370 "APBROM_HORIZONTAL_ROMENTRY370"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY370 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY370 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry371
 *
 * APBROM Horizontal Romentry371 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry371
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry371_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry371_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry371 cavm_apbrom_horizontal_romentry371_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY371 CAVM_APBROM_HORIZONTAL_ROMENTRY371_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY371_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY371_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460005ccll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY371", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY371 cavm_apbrom_horizontal_romentry371_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY371 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY371 "APBROM_HORIZONTAL_ROMENTRY371"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY371 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY371 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry372
 *
 * APBROM Horizontal Romentry372 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry372
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry372_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry372_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry372 cavm_apbrom_horizontal_romentry372_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY372 CAVM_APBROM_HORIZONTAL_ROMENTRY372_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY372_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY372_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460005d0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY372", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY372 cavm_apbrom_horizontal_romentry372_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY372 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY372 "APBROM_HORIZONTAL_ROMENTRY372"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY372 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY372 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry373
 *
 * APBROM Horizontal Romentry373 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry373
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry373_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry373_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry373 cavm_apbrom_horizontal_romentry373_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY373 CAVM_APBROM_HORIZONTAL_ROMENTRY373_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY373_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY373_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460005d4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY373", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY373 cavm_apbrom_horizontal_romentry373_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY373 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY373 "APBROM_HORIZONTAL_ROMENTRY373"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY373 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY373 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry374
 *
 * APBROM Horizontal Romentry374 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry374
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry374_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry374_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry374 cavm_apbrom_horizontal_romentry374_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY374 CAVM_APBROM_HORIZONTAL_ROMENTRY374_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY374_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY374_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460005d8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY374", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY374 cavm_apbrom_horizontal_romentry374_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY374 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY374 "APBROM_HORIZONTAL_ROMENTRY374"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY374 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY374 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry375
 *
 * APBROM Horizontal Romentry375 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry375
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry375_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry375_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry375 cavm_apbrom_horizontal_romentry375_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY375 CAVM_APBROM_HORIZONTAL_ROMENTRY375_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY375_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY375_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460005dcll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY375", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY375 cavm_apbrom_horizontal_romentry375_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY375 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY375 "APBROM_HORIZONTAL_ROMENTRY375"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY375 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY375 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry376
 *
 * APBROM Horizontal Romentry376 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry376
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry376_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry376_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry376 cavm_apbrom_horizontal_romentry376_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY376 CAVM_APBROM_HORIZONTAL_ROMENTRY376_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY376_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY376_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460005e0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY376", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY376 cavm_apbrom_horizontal_romentry376_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY376 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY376 "APBROM_HORIZONTAL_ROMENTRY376"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY376 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY376 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry377
 *
 * APBROM Horizontal Romentry377 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry377
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry377_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry377_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry377 cavm_apbrom_horizontal_romentry377_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY377 CAVM_APBROM_HORIZONTAL_ROMENTRY377_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY377_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY377_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460005e4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY377", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY377 cavm_apbrom_horizontal_romentry377_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY377 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY377 "APBROM_HORIZONTAL_ROMENTRY377"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY377 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY377 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry378
 *
 * APBROM Horizontal Romentry378 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry378
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry378_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry378_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry378 cavm_apbrom_horizontal_romentry378_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY378 CAVM_APBROM_HORIZONTAL_ROMENTRY378_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY378_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY378_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460005e8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY378", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY378 cavm_apbrom_horizontal_romentry378_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY378 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY378 "APBROM_HORIZONTAL_ROMENTRY378"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY378 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY378 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry379
 *
 * APBROM Horizontal Romentry379 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry379
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry379_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry379_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry379 cavm_apbrom_horizontal_romentry379_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY379 CAVM_APBROM_HORIZONTAL_ROMENTRY379_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY379_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY379_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460005ecll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY379", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY379 cavm_apbrom_horizontal_romentry379_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY379 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY379 "APBROM_HORIZONTAL_ROMENTRY379"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY379 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY379 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry38
 *
 * APBROM Horizontal Romentry38 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry38
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry38_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry38_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry38 cavm_apbrom_horizontal_romentry38_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY38 CAVM_APBROM_HORIZONTAL_ROMENTRY38_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY38_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY38_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000098ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY38", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY38 cavm_apbrom_horizontal_romentry38_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY38 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY38 "APBROM_HORIZONTAL_ROMENTRY38"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY38 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY38 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry380
 *
 * APBROM Horizontal Romentry380 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry380
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry380_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry380_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry380 cavm_apbrom_horizontal_romentry380_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY380 CAVM_APBROM_HORIZONTAL_ROMENTRY380_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY380_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY380_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460005f0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY380", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY380 cavm_apbrom_horizontal_romentry380_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY380 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY380 "APBROM_HORIZONTAL_ROMENTRY380"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY380 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY380 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry381
 *
 * APBROM Horizontal Romentry381 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry381
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry381_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry381_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry381 cavm_apbrom_horizontal_romentry381_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY381 CAVM_APBROM_HORIZONTAL_ROMENTRY381_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY381_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY381_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460005f4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY381", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY381 cavm_apbrom_horizontal_romentry381_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY381 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY381 "APBROM_HORIZONTAL_ROMENTRY381"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY381 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY381 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry382
 *
 * APBROM Horizontal Romentry382 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry382
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry382_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry382_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry382 cavm_apbrom_horizontal_romentry382_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY382 CAVM_APBROM_HORIZONTAL_ROMENTRY382_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY382_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY382_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460005f8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY382", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY382 cavm_apbrom_horizontal_romentry382_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY382 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY382 "APBROM_HORIZONTAL_ROMENTRY382"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY382 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY382 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry383
 *
 * APBROM Horizontal Romentry383 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry383
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry383_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry383_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry383 cavm_apbrom_horizontal_romentry383_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY383 CAVM_APBROM_HORIZONTAL_ROMENTRY383_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY383_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY383_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460005fcll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY383", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY383 cavm_apbrom_horizontal_romentry383_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY383 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY383 "APBROM_HORIZONTAL_ROMENTRY383"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY383 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY383 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry384
 *
 * APBROM Horizontal Romentry384 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry384
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry384_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry384_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry384 cavm_apbrom_horizontal_romentry384_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY384 CAVM_APBROM_HORIZONTAL_ROMENTRY384_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY384_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY384_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000600ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY384", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY384 cavm_apbrom_horizontal_romentry384_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY384 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY384 "APBROM_HORIZONTAL_ROMENTRY384"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY384 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY384 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry385
 *
 * APBROM Horizontal Romentry385 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry385
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry385_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry385_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry385 cavm_apbrom_horizontal_romentry385_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY385 CAVM_APBROM_HORIZONTAL_ROMENTRY385_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY385_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY385_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000604ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY385", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY385 cavm_apbrom_horizontal_romentry385_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY385 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY385 "APBROM_HORIZONTAL_ROMENTRY385"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY385 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY385 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry386
 *
 * APBROM Horizontal Romentry386 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry386
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry386_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry386_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry386 cavm_apbrom_horizontal_romentry386_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY386 CAVM_APBROM_HORIZONTAL_ROMENTRY386_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY386_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY386_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000608ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY386", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY386 cavm_apbrom_horizontal_romentry386_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY386 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY386 "APBROM_HORIZONTAL_ROMENTRY386"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY386 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY386 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry387
 *
 * APBROM Horizontal Romentry387 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry387
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry387_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry387_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry387 cavm_apbrom_horizontal_romentry387_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY387 CAVM_APBROM_HORIZONTAL_ROMENTRY387_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY387_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY387_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600060cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY387", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY387 cavm_apbrom_horizontal_romentry387_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY387 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY387 "APBROM_HORIZONTAL_ROMENTRY387"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY387 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY387 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry388
 *
 * APBROM Horizontal Romentry388 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry388
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry388_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry388_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry388 cavm_apbrom_horizontal_romentry388_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY388 CAVM_APBROM_HORIZONTAL_ROMENTRY388_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY388_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY388_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000610ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY388", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY388 cavm_apbrom_horizontal_romentry388_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY388 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY388 "APBROM_HORIZONTAL_ROMENTRY388"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY388 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY388 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry389
 *
 * APBROM Horizontal Romentry389 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry389
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry389_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry389_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry389 cavm_apbrom_horizontal_romentry389_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY389 CAVM_APBROM_HORIZONTAL_ROMENTRY389_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY389_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY389_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000614ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY389", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY389 cavm_apbrom_horizontal_romentry389_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY389 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY389 "APBROM_HORIZONTAL_ROMENTRY389"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY389 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY389 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry39
 *
 * APBROM Horizontal Romentry39 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry39
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry39_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry39_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry39 cavm_apbrom_horizontal_romentry39_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY39 CAVM_APBROM_HORIZONTAL_ROMENTRY39_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY39_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY39_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600009cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY39", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY39 cavm_apbrom_horizontal_romentry39_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY39 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY39 "APBROM_HORIZONTAL_ROMENTRY39"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY39 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY39 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry390
 *
 * APBROM Horizontal Romentry390 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry390
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry390_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry390_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry390 cavm_apbrom_horizontal_romentry390_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY390 CAVM_APBROM_HORIZONTAL_ROMENTRY390_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY390_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY390_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000618ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY390", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY390 cavm_apbrom_horizontal_romentry390_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY390 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY390 "APBROM_HORIZONTAL_ROMENTRY390"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY390 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY390 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry391
 *
 * APBROM Horizontal Romentry391 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry391
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry391_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry391_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry391 cavm_apbrom_horizontal_romentry391_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY391 CAVM_APBROM_HORIZONTAL_ROMENTRY391_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY391_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY391_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600061cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY391", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY391 cavm_apbrom_horizontal_romentry391_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY391 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY391 "APBROM_HORIZONTAL_ROMENTRY391"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY391 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY391 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry392
 *
 * APBROM Horizontal Romentry392 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry392
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry392_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry392_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry392 cavm_apbrom_horizontal_romentry392_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY392 CAVM_APBROM_HORIZONTAL_ROMENTRY392_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY392_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY392_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000620ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY392", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY392 cavm_apbrom_horizontal_romentry392_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY392 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY392 "APBROM_HORIZONTAL_ROMENTRY392"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY392 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY392 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry393
 *
 * APBROM Horizontal Romentry393 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry393
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry393_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry393_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry393 cavm_apbrom_horizontal_romentry393_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY393 CAVM_APBROM_HORIZONTAL_ROMENTRY393_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY393_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY393_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000624ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY393", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY393 cavm_apbrom_horizontal_romentry393_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY393 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY393 "APBROM_HORIZONTAL_ROMENTRY393"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY393 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY393 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry394
 *
 * APBROM Horizontal Romentry394 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry394
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry394_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry394_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry394 cavm_apbrom_horizontal_romentry394_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY394 CAVM_APBROM_HORIZONTAL_ROMENTRY394_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY394_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY394_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000628ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY394", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY394 cavm_apbrom_horizontal_romentry394_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY394 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY394 "APBROM_HORIZONTAL_ROMENTRY394"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY394 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY394 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry395
 *
 * APBROM Horizontal Romentry395 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry395
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry395_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry395_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry395 cavm_apbrom_horizontal_romentry395_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY395 CAVM_APBROM_HORIZONTAL_ROMENTRY395_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY395_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY395_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600062cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY395", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY395 cavm_apbrom_horizontal_romentry395_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY395 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY395 "APBROM_HORIZONTAL_ROMENTRY395"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY395 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY395 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry396
 *
 * APBROM Horizontal Romentry396 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry396
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry396_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry396_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry396 cavm_apbrom_horizontal_romentry396_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY396 CAVM_APBROM_HORIZONTAL_ROMENTRY396_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY396_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY396_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000630ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY396", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY396 cavm_apbrom_horizontal_romentry396_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY396 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY396 "APBROM_HORIZONTAL_ROMENTRY396"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY396 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY396 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry397
 *
 * APBROM Horizontal Romentry397 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry397
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry397_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry397_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry397 cavm_apbrom_horizontal_romentry397_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY397 CAVM_APBROM_HORIZONTAL_ROMENTRY397_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY397_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY397_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000634ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY397", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY397 cavm_apbrom_horizontal_romentry397_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY397 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY397 "APBROM_HORIZONTAL_ROMENTRY397"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY397 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY397 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry398
 *
 * APBROM Horizontal Romentry398 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry398
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry398_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry398_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry398 cavm_apbrom_horizontal_romentry398_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY398 CAVM_APBROM_HORIZONTAL_ROMENTRY398_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY398_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY398_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000638ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY398", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY398 cavm_apbrom_horizontal_romentry398_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY398 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY398 "APBROM_HORIZONTAL_ROMENTRY398"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY398 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY398 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry399
 *
 * APBROM Horizontal Romentry399 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry399
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry399_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry399_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry399 cavm_apbrom_horizontal_romentry399_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY399 CAVM_APBROM_HORIZONTAL_ROMENTRY399_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY399_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY399_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600063cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY399", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY399 cavm_apbrom_horizontal_romentry399_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY399 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY399 "APBROM_HORIZONTAL_ROMENTRY399"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY399 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY399 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry4
 *
 * APBROM Horizontal Romentry4 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry4
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry4_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry4 cavm_apbrom_horizontal_romentry4_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY4 CAVM_APBROM_HORIZONTAL_ROMENTRY4_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY4_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY4_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000010ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY4", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY4 cavm_apbrom_horizontal_romentry4_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY4 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY4 "APBROM_HORIZONTAL_ROMENTRY4"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY4 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY4 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry40
 *
 * APBROM Horizontal Romentry40 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry40
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry40_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry40_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry40 cavm_apbrom_horizontal_romentry40_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY40 CAVM_APBROM_HORIZONTAL_ROMENTRY40_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY40_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY40_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460000a0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY40", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY40 cavm_apbrom_horizontal_romentry40_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY40 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY40 "APBROM_HORIZONTAL_ROMENTRY40"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY40 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY40 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry400
 *
 * APBROM Horizontal Romentry400 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry400
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry400_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry400_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry400 cavm_apbrom_horizontal_romentry400_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY400 CAVM_APBROM_HORIZONTAL_ROMENTRY400_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY400_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY400_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000640ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY400", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY400 cavm_apbrom_horizontal_romentry400_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY400 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY400 "APBROM_HORIZONTAL_ROMENTRY400"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY400 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY400 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry401
 *
 * APBROM Horizontal Romentry401 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry401
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry401_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry401_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry401 cavm_apbrom_horizontal_romentry401_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY401 CAVM_APBROM_HORIZONTAL_ROMENTRY401_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY401_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY401_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000644ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY401", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY401 cavm_apbrom_horizontal_romentry401_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY401 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY401 "APBROM_HORIZONTAL_ROMENTRY401"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY401 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY401 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry402
 *
 * APBROM Horizontal Romentry402 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry402
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry402_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry402_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry402 cavm_apbrom_horizontal_romentry402_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY402 CAVM_APBROM_HORIZONTAL_ROMENTRY402_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY402_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY402_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000648ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY402", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY402 cavm_apbrom_horizontal_romentry402_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY402 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY402 "APBROM_HORIZONTAL_ROMENTRY402"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY402 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY402 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry403
 *
 * APBROM Horizontal Romentry403 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry403
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry403_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry403_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry403 cavm_apbrom_horizontal_romentry403_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY403 CAVM_APBROM_HORIZONTAL_ROMENTRY403_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY403_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY403_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600064cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY403", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY403 cavm_apbrom_horizontal_romentry403_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY403 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY403 "APBROM_HORIZONTAL_ROMENTRY403"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY403 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY403 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry404
 *
 * APBROM Horizontal Romentry404 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry404
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry404_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry404_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry404 cavm_apbrom_horizontal_romentry404_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY404 CAVM_APBROM_HORIZONTAL_ROMENTRY404_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY404_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY404_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000650ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY404", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY404 cavm_apbrom_horizontal_romentry404_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY404 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY404 "APBROM_HORIZONTAL_ROMENTRY404"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY404 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY404 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry405
 *
 * APBROM Horizontal Romentry405 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry405
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry405_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry405_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry405 cavm_apbrom_horizontal_romentry405_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY405 CAVM_APBROM_HORIZONTAL_ROMENTRY405_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY405_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY405_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000654ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY405", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY405 cavm_apbrom_horizontal_romentry405_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY405 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY405 "APBROM_HORIZONTAL_ROMENTRY405"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY405 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY405 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry406
 *
 * APBROM Horizontal Romentry406 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry406
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry406_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry406_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry406 cavm_apbrom_horizontal_romentry406_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY406 CAVM_APBROM_HORIZONTAL_ROMENTRY406_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY406_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY406_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000658ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY406", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY406 cavm_apbrom_horizontal_romentry406_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY406 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY406 "APBROM_HORIZONTAL_ROMENTRY406"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY406 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY406 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry407
 *
 * APBROM Horizontal Romentry407 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry407
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry407_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry407_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry407 cavm_apbrom_horizontal_romentry407_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY407 CAVM_APBROM_HORIZONTAL_ROMENTRY407_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY407_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY407_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600065cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY407", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY407 cavm_apbrom_horizontal_romentry407_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY407 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY407 "APBROM_HORIZONTAL_ROMENTRY407"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY407 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY407 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry408
 *
 * APBROM Horizontal Romentry408 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry408
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry408_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry408_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry408 cavm_apbrom_horizontal_romentry408_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY408 CAVM_APBROM_HORIZONTAL_ROMENTRY408_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY408_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY408_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000660ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY408", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY408 cavm_apbrom_horizontal_romentry408_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY408 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY408 "APBROM_HORIZONTAL_ROMENTRY408"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY408 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY408 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry409
 *
 * APBROM Horizontal Romentry409 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry409
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry409_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry409_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry409 cavm_apbrom_horizontal_romentry409_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY409 CAVM_APBROM_HORIZONTAL_ROMENTRY409_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY409_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY409_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000664ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY409", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY409 cavm_apbrom_horizontal_romentry409_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY409 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY409 "APBROM_HORIZONTAL_ROMENTRY409"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY409 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY409 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry41
 *
 * APBROM Horizontal Romentry41 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry41
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry41_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry41_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry41 cavm_apbrom_horizontal_romentry41_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY41 CAVM_APBROM_HORIZONTAL_ROMENTRY41_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY41_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY41_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460000a4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY41", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY41 cavm_apbrom_horizontal_romentry41_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY41 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY41 "APBROM_HORIZONTAL_ROMENTRY41"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY41 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY41 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry410
 *
 * APBROM Horizontal Romentry410 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry410
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry410_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry410_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry410 cavm_apbrom_horizontal_romentry410_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY410 CAVM_APBROM_HORIZONTAL_ROMENTRY410_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY410_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY410_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000668ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY410", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY410 cavm_apbrom_horizontal_romentry410_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY410 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY410 "APBROM_HORIZONTAL_ROMENTRY410"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY410 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY410 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry411
 *
 * APBROM Horizontal Romentry411 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry411
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry411_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry411_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry411 cavm_apbrom_horizontal_romentry411_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY411 CAVM_APBROM_HORIZONTAL_ROMENTRY411_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY411_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY411_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600066cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY411", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY411 cavm_apbrom_horizontal_romentry411_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY411 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY411 "APBROM_HORIZONTAL_ROMENTRY411"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY411 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY411 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry412
 *
 * APBROM Horizontal Romentry412 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry412
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry412_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry412_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry412 cavm_apbrom_horizontal_romentry412_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY412 CAVM_APBROM_HORIZONTAL_ROMENTRY412_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY412_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY412_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000670ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY412", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY412 cavm_apbrom_horizontal_romentry412_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY412 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY412 "APBROM_HORIZONTAL_ROMENTRY412"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY412 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY412 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry413
 *
 * APBROM Horizontal Romentry413 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry413
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry413_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry413_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry413 cavm_apbrom_horizontal_romentry413_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY413 CAVM_APBROM_HORIZONTAL_ROMENTRY413_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY413_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY413_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000674ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY413", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY413 cavm_apbrom_horizontal_romentry413_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY413 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY413 "APBROM_HORIZONTAL_ROMENTRY413"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY413 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY413 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry414
 *
 * APBROM Horizontal Romentry414 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry414
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry414_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry414_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry414 cavm_apbrom_horizontal_romentry414_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY414 CAVM_APBROM_HORIZONTAL_ROMENTRY414_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY414_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY414_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000678ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY414", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY414 cavm_apbrom_horizontal_romentry414_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY414 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY414 "APBROM_HORIZONTAL_ROMENTRY414"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY414 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY414 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry415
 *
 * APBROM Horizontal Romentry415 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry415
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry415_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry415_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry415 cavm_apbrom_horizontal_romentry415_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY415 CAVM_APBROM_HORIZONTAL_ROMENTRY415_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY415_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY415_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600067cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY415", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY415 cavm_apbrom_horizontal_romentry415_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY415 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY415 "APBROM_HORIZONTAL_ROMENTRY415"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY415 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY415 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry416
 *
 * APBROM Horizontal Romentry416 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry416
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry416_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry416_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry416 cavm_apbrom_horizontal_romentry416_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY416 CAVM_APBROM_HORIZONTAL_ROMENTRY416_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY416_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY416_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000680ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY416", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY416 cavm_apbrom_horizontal_romentry416_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY416 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY416 "APBROM_HORIZONTAL_ROMENTRY416"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY416 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY416 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry417
 *
 * APBROM Horizontal Romentry417 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry417
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry417_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry417_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry417 cavm_apbrom_horizontal_romentry417_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY417 CAVM_APBROM_HORIZONTAL_ROMENTRY417_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY417_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY417_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000684ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY417", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY417 cavm_apbrom_horizontal_romentry417_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY417 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY417 "APBROM_HORIZONTAL_ROMENTRY417"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY417 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY417 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry418
 *
 * APBROM Horizontal Romentry418 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry418
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry418_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry418_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry418 cavm_apbrom_horizontal_romentry418_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY418 CAVM_APBROM_HORIZONTAL_ROMENTRY418_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY418_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY418_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000688ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY418", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY418 cavm_apbrom_horizontal_romentry418_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY418 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY418 "APBROM_HORIZONTAL_ROMENTRY418"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY418 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY418 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry419
 *
 * APBROM Horizontal Romentry419 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry419
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry419_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry419_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry419 cavm_apbrom_horizontal_romentry419_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY419 CAVM_APBROM_HORIZONTAL_ROMENTRY419_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY419_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY419_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600068cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY419", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY419 cavm_apbrom_horizontal_romentry419_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY419 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY419 "APBROM_HORIZONTAL_ROMENTRY419"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY419 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY419 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry42
 *
 * APBROM Horizontal Romentry42 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry42
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry42_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry42_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry42 cavm_apbrom_horizontal_romentry42_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY42 CAVM_APBROM_HORIZONTAL_ROMENTRY42_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY42_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY42_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460000a8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY42", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY42 cavm_apbrom_horizontal_romentry42_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY42 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY42 "APBROM_HORIZONTAL_ROMENTRY42"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY42 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY42 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry420
 *
 * APBROM Horizontal Romentry420 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry420
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry420_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry420_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry420 cavm_apbrom_horizontal_romentry420_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY420 CAVM_APBROM_HORIZONTAL_ROMENTRY420_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY420_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY420_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000690ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY420", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY420 cavm_apbrom_horizontal_romentry420_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY420 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY420 "APBROM_HORIZONTAL_ROMENTRY420"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY420 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY420 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry421
 *
 * APBROM Horizontal Romentry421 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry421
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry421_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry421_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry421 cavm_apbrom_horizontal_romentry421_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY421 CAVM_APBROM_HORIZONTAL_ROMENTRY421_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY421_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY421_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000694ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY421", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY421 cavm_apbrom_horizontal_romentry421_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY421 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY421 "APBROM_HORIZONTAL_ROMENTRY421"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY421 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY421 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry422
 *
 * APBROM Horizontal Romentry422 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry422
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry422_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry422_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry422 cavm_apbrom_horizontal_romentry422_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY422 CAVM_APBROM_HORIZONTAL_ROMENTRY422_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY422_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY422_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000698ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY422", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY422 cavm_apbrom_horizontal_romentry422_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY422 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY422 "APBROM_HORIZONTAL_ROMENTRY422"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY422 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY422 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry423
 *
 * APBROM Horizontal Romentry423 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry423
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry423_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry423_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry423 cavm_apbrom_horizontal_romentry423_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY423 CAVM_APBROM_HORIZONTAL_ROMENTRY423_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY423_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY423_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600069cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY423", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY423 cavm_apbrom_horizontal_romentry423_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY423 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY423 "APBROM_HORIZONTAL_ROMENTRY423"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY423 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY423 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry424
 *
 * APBROM Horizontal Romentry424 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry424
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry424_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry424_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry424 cavm_apbrom_horizontal_romentry424_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY424 CAVM_APBROM_HORIZONTAL_ROMENTRY424_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY424_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY424_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460006a0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY424", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY424 cavm_apbrom_horizontal_romentry424_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY424 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY424 "APBROM_HORIZONTAL_ROMENTRY424"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY424 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY424 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry425
 *
 * APBROM Horizontal Romentry425 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry425
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry425_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry425_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry425 cavm_apbrom_horizontal_romentry425_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY425 CAVM_APBROM_HORIZONTAL_ROMENTRY425_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY425_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY425_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460006a4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY425", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY425 cavm_apbrom_horizontal_romentry425_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY425 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY425 "APBROM_HORIZONTAL_ROMENTRY425"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY425 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY425 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry426
 *
 * APBROM Horizontal Romentry426 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry426
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry426_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry426_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry426 cavm_apbrom_horizontal_romentry426_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY426 CAVM_APBROM_HORIZONTAL_ROMENTRY426_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY426_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY426_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460006a8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY426", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY426 cavm_apbrom_horizontal_romentry426_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY426 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY426 "APBROM_HORIZONTAL_ROMENTRY426"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY426 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY426 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry427
 *
 * APBROM Horizontal Romentry427 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry427
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry427_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry427_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry427 cavm_apbrom_horizontal_romentry427_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY427 CAVM_APBROM_HORIZONTAL_ROMENTRY427_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY427_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY427_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460006acll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY427", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY427 cavm_apbrom_horizontal_romentry427_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY427 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY427 "APBROM_HORIZONTAL_ROMENTRY427"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY427 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY427 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry428
 *
 * APBROM Horizontal Romentry428 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry428
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry428_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry428_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry428 cavm_apbrom_horizontal_romentry428_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY428 CAVM_APBROM_HORIZONTAL_ROMENTRY428_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY428_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY428_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460006b0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY428", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY428 cavm_apbrom_horizontal_romentry428_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY428 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY428 "APBROM_HORIZONTAL_ROMENTRY428"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY428 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY428 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry429
 *
 * APBROM Horizontal Romentry429 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry429
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry429_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry429_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry429 cavm_apbrom_horizontal_romentry429_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY429 CAVM_APBROM_HORIZONTAL_ROMENTRY429_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY429_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY429_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460006b4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY429", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY429 cavm_apbrom_horizontal_romentry429_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY429 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY429 "APBROM_HORIZONTAL_ROMENTRY429"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY429 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY429 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry43
 *
 * APBROM Horizontal Romentry43 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry43
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry43_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry43_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry43 cavm_apbrom_horizontal_romentry43_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY43 CAVM_APBROM_HORIZONTAL_ROMENTRY43_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY43_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY43_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460000acll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY43", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY43 cavm_apbrom_horizontal_romentry43_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY43 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY43 "APBROM_HORIZONTAL_ROMENTRY43"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY43 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY43 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry430
 *
 * APBROM Horizontal Romentry430 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry430
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry430_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry430_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry430 cavm_apbrom_horizontal_romentry430_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY430 CAVM_APBROM_HORIZONTAL_ROMENTRY430_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY430_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY430_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460006b8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY430", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY430 cavm_apbrom_horizontal_romentry430_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY430 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY430 "APBROM_HORIZONTAL_ROMENTRY430"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY430 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY430 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry431
 *
 * APBROM Horizontal Romentry431 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry431
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry431_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry431_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry431 cavm_apbrom_horizontal_romentry431_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY431 CAVM_APBROM_HORIZONTAL_ROMENTRY431_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY431_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY431_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460006bcll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY431", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY431 cavm_apbrom_horizontal_romentry431_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY431 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY431 "APBROM_HORIZONTAL_ROMENTRY431"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY431 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY431 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry432
 *
 * APBROM Horizontal Romentry432 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry432
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry432_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry432_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry432 cavm_apbrom_horizontal_romentry432_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY432 CAVM_APBROM_HORIZONTAL_ROMENTRY432_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY432_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY432_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460006c0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY432", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY432 cavm_apbrom_horizontal_romentry432_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY432 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY432 "APBROM_HORIZONTAL_ROMENTRY432"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY432 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY432 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry433
 *
 * APBROM Horizontal Romentry433 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry433
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry433_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry433_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry433 cavm_apbrom_horizontal_romentry433_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY433 CAVM_APBROM_HORIZONTAL_ROMENTRY433_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY433_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY433_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460006c4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY433", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY433 cavm_apbrom_horizontal_romentry433_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY433 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY433 "APBROM_HORIZONTAL_ROMENTRY433"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY433 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY433 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry434
 *
 * APBROM Horizontal Romentry434 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry434
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry434_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry434_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry434 cavm_apbrom_horizontal_romentry434_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY434 CAVM_APBROM_HORIZONTAL_ROMENTRY434_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY434_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY434_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460006c8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY434", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY434 cavm_apbrom_horizontal_romentry434_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY434 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY434 "APBROM_HORIZONTAL_ROMENTRY434"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY434 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY434 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry435
 *
 * APBROM Horizontal Romentry435 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry435
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry435_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry435_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry435 cavm_apbrom_horizontal_romentry435_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY435 CAVM_APBROM_HORIZONTAL_ROMENTRY435_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY435_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY435_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460006ccll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY435", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY435 cavm_apbrom_horizontal_romentry435_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY435 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY435 "APBROM_HORIZONTAL_ROMENTRY435"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY435 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY435 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry436
 *
 * APBROM Horizontal Romentry436 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry436
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry436_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry436_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry436 cavm_apbrom_horizontal_romentry436_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY436 CAVM_APBROM_HORIZONTAL_ROMENTRY436_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY436_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY436_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460006d0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY436", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY436 cavm_apbrom_horizontal_romentry436_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY436 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY436 "APBROM_HORIZONTAL_ROMENTRY436"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY436 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY436 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry437
 *
 * APBROM Horizontal Romentry437 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry437
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry437_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry437_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry437 cavm_apbrom_horizontal_romentry437_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY437 CAVM_APBROM_HORIZONTAL_ROMENTRY437_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY437_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY437_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460006d4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY437", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY437 cavm_apbrom_horizontal_romentry437_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY437 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY437 "APBROM_HORIZONTAL_ROMENTRY437"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY437 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY437 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry438
 *
 * APBROM Horizontal Romentry438 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry438
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry438_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry438_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry438 cavm_apbrom_horizontal_romentry438_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY438 CAVM_APBROM_HORIZONTAL_ROMENTRY438_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY438_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY438_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460006d8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY438", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY438 cavm_apbrom_horizontal_romentry438_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY438 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY438 "APBROM_HORIZONTAL_ROMENTRY438"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY438 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY438 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry439
 *
 * APBROM Horizontal Romentry439 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry439
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry439_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry439_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry439 cavm_apbrom_horizontal_romentry439_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY439 CAVM_APBROM_HORIZONTAL_ROMENTRY439_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY439_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY439_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460006dcll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY439", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY439 cavm_apbrom_horizontal_romentry439_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY439 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY439 "APBROM_HORIZONTAL_ROMENTRY439"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY439 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY439 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry44
 *
 * APBROM Horizontal Romentry44 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry44
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry44_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry44_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry44 cavm_apbrom_horizontal_romentry44_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY44 CAVM_APBROM_HORIZONTAL_ROMENTRY44_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY44_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY44_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460000b0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY44", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY44 cavm_apbrom_horizontal_romentry44_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY44 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY44 "APBROM_HORIZONTAL_ROMENTRY44"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY44 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY44 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry440
 *
 * APBROM Horizontal Romentry440 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry440
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry440_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry440_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry440 cavm_apbrom_horizontal_romentry440_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY440 CAVM_APBROM_HORIZONTAL_ROMENTRY440_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY440_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY440_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460006e0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY440", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY440 cavm_apbrom_horizontal_romentry440_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY440 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY440 "APBROM_HORIZONTAL_ROMENTRY440"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY440 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY440 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry441
 *
 * APBROM Horizontal Romentry441 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry441
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry441_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry441_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry441 cavm_apbrom_horizontal_romentry441_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY441 CAVM_APBROM_HORIZONTAL_ROMENTRY441_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY441_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY441_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460006e4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY441", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY441 cavm_apbrom_horizontal_romentry441_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY441 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY441 "APBROM_HORIZONTAL_ROMENTRY441"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY441 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY441 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry442
 *
 * APBROM Horizontal Romentry442 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry442
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry442_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry442_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry442 cavm_apbrom_horizontal_romentry442_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY442 CAVM_APBROM_HORIZONTAL_ROMENTRY442_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY442_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY442_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460006e8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY442", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY442 cavm_apbrom_horizontal_romentry442_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY442 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY442 "APBROM_HORIZONTAL_ROMENTRY442"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY442 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY442 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry443
 *
 * APBROM Horizontal Romentry443 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry443
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry443_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry443_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry443 cavm_apbrom_horizontal_romentry443_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY443 CAVM_APBROM_HORIZONTAL_ROMENTRY443_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY443_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY443_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460006ecll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY443", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY443 cavm_apbrom_horizontal_romentry443_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY443 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY443 "APBROM_HORIZONTAL_ROMENTRY443"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY443 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY443 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry444
 *
 * APBROM Horizontal Romentry444 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry444
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry444_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry444_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry444 cavm_apbrom_horizontal_romentry444_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY444 CAVM_APBROM_HORIZONTAL_ROMENTRY444_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY444_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY444_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460006f0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY444", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY444 cavm_apbrom_horizontal_romentry444_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY444 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY444 "APBROM_HORIZONTAL_ROMENTRY444"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY444 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY444 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry445
 *
 * APBROM Horizontal Romentry445 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry445
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry445_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry445_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry445 cavm_apbrom_horizontal_romentry445_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY445 CAVM_APBROM_HORIZONTAL_ROMENTRY445_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY445_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY445_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460006f4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY445", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY445 cavm_apbrom_horizontal_romentry445_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY445 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY445 "APBROM_HORIZONTAL_ROMENTRY445"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY445 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY445 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry446
 *
 * APBROM Horizontal Romentry446 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry446
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry446_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry446_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry446 cavm_apbrom_horizontal_romentry446_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY446 CAVM_APBROM_HORIZONTAL_ROMENTRY446_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY446_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY446_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460006f8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY446", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY446 cavm_apbrom_horizontal_romentry446_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY446 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY446 "APBROM_HORIZONTAL_ROMENTRY446"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY446 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY446 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry447
 *
 * APBROM Horizontal Romentry447 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry447
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry447_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry447_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry447 cavm_apbrom_horizontal_romentry447_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY447 CAVM_APBROM_HORIZONTAL_ROMENTRY447_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY447_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY447_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460006fcll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY447", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY447 cavm_apbrom_horizontal_romentry447_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY447 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY447 "APBROM_HORIZONTAL_ROMENTRY447"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY447 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY447 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry448
 *
 * APBROM Horizontal Romentry448 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry448
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry448_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry448_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry448 cavm_apbrom_horizontal_romentry448_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY448 CAVM_APBROM_HORIZONTAL_ROMENTRY448_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY448_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY448_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000700ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY448", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY448 cavm_apbrom_horizontal_romentry448_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY448 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY448 "APBROM_HORIZONTAL_ROMENTRY448"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY448 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY448 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry449
 *
 * APBROM Horizontal Romentry449 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry449
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry449_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry449_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry449 cavm_apbrom_horizontal_romentry449_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY449 CAVM_APBROM_HORIZONTAL_ROMENTRY449_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY449_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY449_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000704ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY449", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY449 cavm_apbrom_horizontal_romentry449_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY449 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY449 "APBROM_HORIZONTAL_ROMENTRY449"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY449 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY449 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry45
 *
 * APBROM Horizontal Romentry45 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry45
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry45_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry45_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry45 cavm_apbrom_horizontal_romentry45_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY45 CAVM_APBROM_HORIZONTAL_ROMENTRY45_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY45_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY45_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460000b4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY45", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY45 cavm_apbrom_horizontal_romentry45_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY45 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY45 "APBROM_HORIZONTAL_ROMENTRY45"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY45 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY45 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry450
 *
 * APBROM Horizontal Romentry450 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry450
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry450_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry450_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry450 cavm_apbrom_horizontal_romentry450_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY450 CAVM_APBROM_HORIZONTAL_ROMENTRY450_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY450_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY450_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000708ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY450", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY450 cavm_apbrom_horizontal_romentry450_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY450 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY450 "APBROM_HORIZONTAL_ROMENTRY450"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY450 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY450 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry451
 *
 * APBROM Horizontal Romentry451 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry451
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry451_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry451_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry451 cavm_apbrom_horizontal_romentry451_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY451 CAVM_APBROM_HORIZONTAL_ROMENTRY451_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY451_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY451_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600070cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY451", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY451 cavm_apbrom_horizontal_romentry451_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY451 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY451 "APBROM_HORIZONTAL_ROMENTRY451"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY451 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY451 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry452
 *
 * APBROM Horizontal Romentry452 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry452
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry452_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry452_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry452 cavm_apbrom_horizontal_romentry452_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY452 CAVM_APBROM_HORIZONTAL_ROMENTRY452_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY452_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY452_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000710ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY452", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY452 cavm_apbrom_horizontal_romentry452_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY452 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY452 "APBROM_HORIZONTAL_ROMENTRY452"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY452 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY452 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry453
 *
 * APBROM Horizontal Romentry453 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry453
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry453_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry453_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry453 cavm_apbrom_horizontal_romentry453_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY453 CAVM_APBROM_HORIZONTAL_ROMENTRY453_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY453_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY453_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000714ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY453", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY453 cavm_apbrom_horizontal_romentry453_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY453 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY453 "APBROM_HORIZONTAL_ROMENTRY453"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY453 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY453 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry454
 *
 * APBROM Horizontal Romentry454 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry454
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry454_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry454_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry454 cavm_apbrom_horizontal_romentry454_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY454 CAVM_APBROM_HORIZONTAL_ROMENTRY454_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY454_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY454_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000718ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY454", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY454 cavm_apbrom_horizontal_romentry454_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY454 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY454 "APBROM_HORIZONTAL_ROMENTRY454"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY454 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY454 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry455
 *
 * APBROM Horizontal Romentry455 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry455
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry455_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry455_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry455 cavm_apbrom_horizontal_romentry455_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY455 CAVM_APBROM_HORIZONTAL_ROMENTRY455_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY455_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY455_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600071cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY455", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY455 cavm_apbrom_horizontal_romentry455_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY455 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY455 "APBROM_HORIZONTAL_ROMENTRY455"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY455 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY455 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry456
 *
 * APBROM Horizontal Romentry456 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry456
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry456_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry456_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry456 cavm_apbrom_horizontal_romentry456_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY456 CAVM_APBROM_HORIZONTAL_ROMENTRY456_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY456_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY456_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000720ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY456", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY456 cavm_apbrom_horizontal_romentry456_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY456 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY456 "APBROM_HORIZONTAL_ROMENTRY456"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY456 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY456 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry457
 *
 * APBROM Horizontal Romentry457 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry457
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry457_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry457_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry457 cavm_apbrom_horizontal_romentry457_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY457 CAVM_APBROM_HORIZONTAL_ROMENTRY457_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY457_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY457_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000724ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY457", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY457 cavm_apbrom_horizontal_romentry457_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY457 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY457 "APBROM_HORIZONTAL_ROMENTRY457"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY457 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY457 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry458
 *
 * APBROM Horizontal Romentry458 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry458
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry458_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry458_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry458 cavm_apbrom_horizontal_romentry458_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY458 CAVM_APBROM_HORIZONTAL_ROMENTRY458_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY458_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY458_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000728ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY458", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY458 cavm_apbrom_horizontal_romentry458_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY458 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY458 "APBROM_HORIZONTAL_ROMENTRY458"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY458 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY458 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry459
 *
 * APBROM Horizontal Romentry459 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry459
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry459_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry459_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry459 cavm_apbrom_horizontal_romentry459_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY459 CAVM_APBROM_HORIZONTAL_ROMENTRY459_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY459_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY459_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600072cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY459", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY459 cavm_apbrom_horizontal_romentry459_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY459 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY459 "APBROM_HORIZONTAL_ROMENTRY459"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY459 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY459 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry46
 *
 * APBROM Horizontal Romentry46 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry46
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry46_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry46_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry46 cavm_apbrom_horizontal_romentry46_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY46 CAVM_APBROM_HORIZONTAL_ROMENTRY46_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY46_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY46_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460000b8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY46", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY46 cavm_apbrom_horizontal_romentry46_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY46 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY46 "APBROM_HORIZONTAL_ROMENTRY46"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY46 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY46 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry460
 *
 * APBROM Horizontal Romentry460 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry460
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry460_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry460_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry460 cavm_apbrom_horizontal_romentry460_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY460 CAVM_APBROM_HORIZONTAL_ROMENTRY460_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY460_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY460_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000730ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY460", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY460 cavm_apbrom_horizontal_romentry460_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY460 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY460 "APBROM_HORIZONTAL_ROMENTRY460"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY460 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY460 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry461
 *
 * APBROM Horizontal Romentry461 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry461
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry461_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry461_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry461 cavm_apbrom_horizontal_romentry461_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY461 CAVM_APBROM_HORIZONTAL_ROMENTRY461_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY461_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY461_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000734ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY461", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY461 cavm_apbrom_horizontal_romentry461_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY461 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY461 "APBROM_HORIZONTAL_ROMENTRY461"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY461 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY461 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry462
 *
 * APBROM Horizontal Romentry462 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry462
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry462_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry462_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry462 cavm_apbrom_horizontal_romentry462_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY462 CAVM_APBROM_HORIZONTAL_ROMENTRY462_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY462_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY462_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000738ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY462", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY462 cavm_apbrom_horizontal_romentry462_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY462 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY462 "APBROM_HORIZONTAL_ROMENTRY462"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY462 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY462 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry463
 *
 * APBROM Horizontal Romentry463 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry463
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry463_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry463_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry463 cavm_apbrom_horizontal_romentry463_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY463 CAVM_APBROM_HORIZONTAL_ROMENTRY463_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY463_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY463_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600073cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY463", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY463 cavm_apbrom_horizontal_romentry463_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY463 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY463 "APBROM_HORIZONTAL_ROMENTRY463"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY463 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY463 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry464
 *
 * APBROM Horizontal Romentry464 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry464
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry464_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry464_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry464 cavm_apbrom_horizontal_romentry464_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY464 CAVM_APBROM_HORIZONTAL_ROMENTRY464_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY464_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY464_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000740ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY464", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY464 cavm_apbrom_horizontal_romentry464_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY464 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY464 "APBROM_HORIZONTAL_ROMENTRY464"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY464 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY464 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry465
 *
 * APBROM Horizontal Romentry465 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry465
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry465_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry465_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry465 cavm_apbrom_horizontal_romentry465_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY465 CAVM_APBROM_HORIZONTAL_ROMENTRY465_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY465_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY465_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000744ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY465", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY465 cavm_apbrom_horizontal_romentry465_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY465 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY465 "APBROM_HORIZONTAL_ROMENTRY465"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY465 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY465 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry466
 *
 * APBROM Horizontal Romentry466 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry466
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry466_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry466_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry466 cavm_apbrom_horizontal_romentry466_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY466 CAVM_APBROM_HORIZONTAL_ROMENTRY466_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY466_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY466_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000748ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY466", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY466 cavm_apbrom_horizontal_romentry466_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY466 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY466 "APBROM_HORIZONTAL_ROMENTRY466"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY466 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY466 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry467
 *
 * APBROM Horizontal Romentry467 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry467
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry467_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry467_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry467 cavm_apbrom_horizontal_romentry467_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY467 CAVM_APBROM_HORIZONTAL_ROMENTRY467_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY467_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY467_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600074cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY467", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY467 cavm_apbrom_horizontal_romentry467_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY467 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY467 "APBROM_HORIZONTAL_ROMENTRY467"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY467 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY467 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry468
 *
 * APBROM Horizontal Romentry468 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry468
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry468_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry468_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry468 cavm_apbrom_horizontal_romentry468_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY468 CAVM_APBROM_HORIZONTAL_ROMENTRY468_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY468_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY468_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000750ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY468", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY468 cavm_apbrom_horizontal_romentry468_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY468 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY468 "APBROM_HORIZONTAL_ROMENTRY468"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY468 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY468 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry469
 *
 * APBROM Horizontal Romentry469 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry469
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry469_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry469_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry469 cavm_apbrom_horizontal_romentry469_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY469 CAVM_APBROM_HORIZONTAL_ROMENTRY469_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY469_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY469_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000754ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY469", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY469 cavm_apbrom_horizontal_romentry469_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY469 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY469 "APBROM_HORIZONTAL_ROMENTRY469"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY469 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY469 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry47
 *
 * APBROM Horizontal Romentry47 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry47
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry47_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry47_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry47 cavm_apbrom_horizontal_romentry47_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY47 CAVM_APBROM_HORIZONTAL_ROMENTRY47_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY47_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY47_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460000bcll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY47", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY47 cavm_apbrom_horizontal_romentry47_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY47 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY47 "APBROM_HORIZONTAL_ROMENTRY47"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY47 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY47 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry470
 *
 * APBROM Horizontal Romentry470 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry470
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry470_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry470_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry470 cavm_apbrom_horizontal_romentry470_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY470 CAVM_APBROM_HORIZONTAL_ROMENTRY470_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY470_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY470_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000758ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY470", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY470 cavm_apbrom_horizontal_romentry470_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY470 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY470 "APBROM_HORIZONTAL_ROMENTRY470"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY470 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY470 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry471
 *
 * APBROM Horizontal Romentry471 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry471
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry471_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry471_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry471 cavm_apbrom_horizontal_romentry471_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY471 CAVM_APBROM_HORIZONTAL_ROMENTRY471_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY471_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY471_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600075cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY471", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY471 cavm_apbrom_horizontal_romentry471_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY471 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY471 "APBROM_HORIZONTAL_ROMENTRY471"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY471 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY471 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry472
 *
 * APBROM Horizontal Romentry472 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry472
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry472_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry472_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry472 cavm_apbrom_horizontal_romentry472_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY472 CAVM_APBROM_HORIZONTAL_ROMENTRY472_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY472_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY472_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000760ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY472", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY472 cavm_apbrom_horizontal_romentry472_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY472 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY472 "APBROM_HORIZONTAL_ROMENTRY472"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY472 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY472 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry473
 *
 * APBROM Horizontal Romentry473 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry473
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry473_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry473_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry473 cavm_apbrom_horizontal_romentry473_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY473 CAVM_APBROM_HORIZONTAL_ROMENTRY473_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY473_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY473_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000764ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY473", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY473 cavm_apbrom_horizontal_romentry473_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY473 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY473 "APBROM_HORIZONTAL_ROMENTRY473"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY473 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY473 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry474
 *
 * APBROM Horizontal Romentry474 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry474
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry474_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry474_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry474 cavm_apbrom_horizontal_romentry474_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY474 CAVM_APBROM_HORIZONTAL_ROMENTRY474_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY474_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY474_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000768ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY474", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY474 cavm_apbrom_horizontal_romentry474_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY474 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY474 "APBROM_HORIZONTAL_ROMENTRY474"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY474 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY474 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry475
 *
 * APBROM Horizontal Romentry475 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry475
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry475_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry475_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry475 cavm_apbrom_horizontal_romentry475_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY475 CAVM_APBROM_HORIZONTAL_ROMENTRY475_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY475_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY475_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600076cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY475", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY475 cavm_apbrom_horizontal_romentry475_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY475 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY475 "APBROM_HORIZONTAL_ROMENTRY475"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY475 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY475 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry476
 *
 * APBROM Horizontal Romentry476 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry476
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry476_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry476_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry476 cavm_apbrom_horizontal_romentry476_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY476 CAVM_APBROM_HORIZONTAL_ROMENTRY476_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY476_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY476_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000770ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY476", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY476 cavm_apbrom_horizontal_romentry476_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY476 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY476 "APBROM_HORIZONTAL_ROMENTRY476"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY476 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY476 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry477
 *
 * APBROM Horizontal Romentry477 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry477
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry477_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry477_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry477 cavm_apbrom_horizontal_romentry477_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY477 CAVM_APBROM_HORIZONTAL_ROMENTRY477_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY477_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY477_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000774ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY477", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY477 cavm_apbrom_horizontal_romentry477_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY477 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY477 "APBROM_HORIZONTAL_ROMENTRY477"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY477 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY477 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry478
 *
 * APBROM Horizontal Romentry478 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry478
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry478_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry478_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry478 cavm_apbrom_horizontal_romentry478_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY478 CAVM_APBROM_HORIZONTAL_ROMENTRY478_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY478_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY478_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000778ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY478", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY478 cavm_apbrom_horizontal_romentry478_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY478 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY478 "APBROM_HORIZONTAL_ROMENTRY478"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY478 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY478 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry479
 *
 * APBROM Horizontal Romentry479 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry479
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry479_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry479_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry479 cavm_apbrom_horizontal_romentry479_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY479 CAVM_APBROM_HORIZONTAL_ROMENTRY479_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY479_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY479_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600077cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY479", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY479 cavm_apbrom_horizontal_romentry479_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY479 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY479 "APBROM_HORIZONTAL_ROMENTRY479"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY479 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY479 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry48
 *
 * APBROM Horizontal Romentry48 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry48
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry48_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry48_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry48 cavm_apbrom_horizontal_romentry48_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY48 CAVM_APBROM_HORIZONTAL_ROMENTRY48_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY48_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY48_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460000c0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY48", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY48 cavm_apbrom_horizontal_romentry48_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY48 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY48 "APBROM_HORIZONTAL_ROMENTRY48"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY48 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY48 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry480
 *
 * APBROM Horizontal Romentry480 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry480
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry480_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry480_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry480 cavm_apbrom_horizontal_romentry480_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY480 CAVM_APBROM_HORIZONTAL_ROMENTRY480_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY480_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY480_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000780ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY480", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY480 cavm_apbrom_horizontal_romentry480_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY480 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY480 "APBROM_HORIZONTAL_ROMENTRY480"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY480 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY480 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry481
 *
 * APBROM Horizontal Romentry481 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry481
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry481_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry481_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry481 cavm_apbrom_horizontal_romentry481_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY481 CAVM_APBROM_HORIZONTAL_ROMENTRY481_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY481_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY481_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000784ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY481", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY481 cavm_apbrom_horizontal_romentry481_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY481 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY481 "APBROM_HORIZONTAL_ROMENTRY481"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY481 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY481 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry482
 *
 * APBROM Horizontal Romentry482 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry482
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry482_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry482_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry482 cavm_apbrom_horizontal_romentry482_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY482 CAVM_APBROM_HORIZONTAL_ROMENTRY482_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY482_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY482_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000788ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY482", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY482 cavm_apbrom_horizontal_romentry482_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY482 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY482 "APBROM_HORIZONTAL_ROMENTRY482"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY482 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY482 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry483
 *
 * APBROM Horizontal Romentry483 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry483
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry483_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry483_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry483 cavm_apbrom_horizontal_romentry483_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY483 CAVM_APBROM_HORIZONTAL_ROMENTRY483_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY483_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY483_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600078cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY483", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY483 cavm_apbrom_horizontal_romentry483_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY483 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY483 "APBROM_HORIZONTAL_ROMENTRY483"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY483 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY483 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry484
 *
 * APBROM Horizontal Romentry484 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry484
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry484_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry484_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry484 cavm_apbrom_horizontal_romentry484_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY484 CAVM_APBROM_HORIZONTAL_ROMENTRY484_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY484_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY484_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000790ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY484", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY484 cavm_apbrom_horizontal_romentry484_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY484 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY484 "APBROM_HORIZONTAL_ROMENTRY484"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY484 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY484 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry485
 *
 * APBROM Horizontal Romentry485 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry485
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry485_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry485_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry485 cavm_apbrom_horizontal_romentry485_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY485 CAVM_APBROM_HORIZONTAL_ROMENTRY485_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY485_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY485_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000794ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY485", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY485 cavm_apbrom_horizontal_romentry485_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY485 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY485 "APBROM_HORIZONTAL_ROMENTRY485"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY485 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY485 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry486
 *
 * APBROM Horizontal Romentry486 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry486
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry486_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry486_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry486 cavm_apbrom_horizontal_romentry486_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY486 CAVM_APBROM_HORIZONTAL_ROMENTRY486_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY486_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY486_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000798ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY486", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY486 cavm_apbrom_horizontal_romentry486_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY486 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY486 "APBROM_HORIZONTAL_ROMENTRY486"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY486 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY486 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry487
 *
 * APBROM Horizontal Romentry487 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry487
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry487_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry487_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry487 cavm_apbrom_horizontal_romentry487_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY487 CAVM_APBROM_HORIZONTAL_ROMENTRY487_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY487_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY487_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600079cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY487", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY487 cavm_apbrom_horizontal_romentry487_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY487 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY487 "APBROM_HORIZONTAL_ROMENTRY487"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY487 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY487 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry488
 *
 * APBROM Horizontal Romentry488 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry488
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry488_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry488_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry488 cavm_apbrom_horizontal_romentry488_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY488 CAVM_APBROM_HORIZONTAL_ROMENTRY488_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY488_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY488_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460007a0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY488", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY488 cavm_apbrom_horizontal_romentry488_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY488 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY488 "APBROM_HORIZONTAL_ROMENTRY488"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY488 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY488 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry489
 *
 * APBROM Horizontal Romentry489 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry489
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry489_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry489_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry489 cavm_apbrom_horizontal_romentry489_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY489 CAVM_APBROM_HORIZONTAL_ROMENTRY489_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY489_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY489_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460007a4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY489", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY489 cavm_apbrom_horizontal_romentry489_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY489 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY489 "APBROM_HORIZONTAL_ROMENTRY489"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY489 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY489 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry49
 *
 * APBROM Horizontal Romentry49 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry49
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry49_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry49_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry49 cavm_apbrom_horizontal_romentry49_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY49 CAVM_APBROM_HORIZONTAL_ROMENTRY49_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY49_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY49_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460000c4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY49", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY49 cavm_apbrom_horizontal_romentry49_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY49 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY49 "APBROM_HORIZONTAL_ROMENTRY49"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY49 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY49 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry490
 *
 * APBROM Horizontal Romentry490 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry490
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry490_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry490_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry490 cavm_apbrom_horizontal_romentry490_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY490 CAVM_APBROM_HORIZONTAL_ROMENTRY490_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY490_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY490_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460007a8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY490", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY490 cavm_apbrom_horizontal_romentry490_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY490 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY490 "APBROM_HORIZONTAL_ROMENTRY490"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY490 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY490 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry491
 *
 * APBROM Horizontal Romentry491 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry491
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry491_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry491_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry491 cavm_apbrom_horizontal_romentry491_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY491 CAVM_APBROM_HORIZONTAL_ROMENTRY491_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY491_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY491_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460007acll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY491", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY491 cavm_apbrom_horizontal_romentry491_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY491 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY491 "APBROM_HORIZONTAL_ROMENTRY491"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY491 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY491 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry492
 *
 * APBROM Horizontal Romentry492 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry492
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry492_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry492_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry492 cavm_apbrom_horizontal_romentry492_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY492 CAVM_APBROM_HORIZONTAL_ROMENTRY492_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY492_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY492_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460007b0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY492", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY492 cavm_apbrom_horizontal_romentry492_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY492 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY492 "APBROM_HORIZONTAL_ROMENTRY492"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY492 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY492 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry493
 *
 * APBROM Horizontal Romentry493 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry493
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry493_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry493_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry493 cavm_apbrom_horizontal_romentry493_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY493 CAVM_APBROM_HORIZONTAL_ROMENTRY493_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY493_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY493_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460007b4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY493", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY493 cavm_apbrom_horizontal_romentry493_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY493 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY493 "APBROM_HORIZONTAL_ROMENTRY493"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY493 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY493 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry494
 *
 * APBROM Horizontal Romentry494 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry494
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry494_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry494_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry494 cavm_apbrom_horizontal_romentry494_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY494 CAVM_APBROM_HORIZONTAL_ROMENTRY494_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY494_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY494_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460007b8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY494", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY494 cavm_apbrom_horizontal_romentry494_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY494 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY494 "APBROM_HORIZONTAL_ROMENTRY494"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY494 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY494 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry495
 *
 * APBROM Horizontal Romentry495 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry495
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry495_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry495_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry495 cavm_apbrom_horizontal_romentry495_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY495 CAVM_APBROM_HORIZONTAL_ROMENTRY495_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY495_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY495_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460007bcll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY495", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY495 cavm_apbrom_horizontal_romentry495_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY495 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY495 "APBROM_HORIZONTAL_ROMENTRY495"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY495 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY495 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry496
 *
 * APBROM Horizontal Romentry496 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry496
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry496_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry496_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry496 cavm_apbrom_horizontal_romentry496_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY496 CAVM_APBROM_HORIZONTAL_ROMENTRY496_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY496_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY496_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460007c0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY496", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY496 cavm_apbrom_horizontal_romentry496_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY496 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY496 "APBROM_HORIZONTAL_ROMENTRY496"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY496 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY496 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry497
 *
 * APBROM Horizontal Romentry497 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry497
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry497_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry497_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry497 cavm_apbrom_horizontal_romentry497_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY497 CAVM_APBROM_HORIZONTAL_ROMENTRY497_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY497_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY497_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460007c4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY497", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY497 cavm_apbrom_horizontal_romentry497_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY497 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY497 "APBROM_HORIZONTAL_ROMENTRY497"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY497 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY497 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry498
 *
 * APBROM Horizontal Romentry498 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry498
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry498_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry498_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry498 cavm_apbrom_horizontal_romentry498_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY498 CAVM_APBROM_HORIZONTAL_ROMENTRY498_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY498_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY498_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460007c8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY498", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY498 cavm_apbrom_horizontal_romentry498_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY498 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY498 "APBROM_HORIZONTAL_ROMENTRY498"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY498 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY498 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry499
 *
 * APBROM Horizontal Romentry499 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry499
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry499_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry499_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry499 cavm_apbrom_horizontal_romentry499_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY499 CAVM_APBROM_HORIZONTAL_ROMENTRY499_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY499_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY499_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460007ccll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY499", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY499 cavm_apbrom_horizontal_romentry499_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY499 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY499 "APBROM_HORIZONTAL_ROMENTRY499"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY499 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY499 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry5
 *
 * APBROM Horizontal Romentry5 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry5
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry5_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry5 cavm_apbrom_horizontal_romentry5_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY5 CAVM_APBROM_HORIZONTAL_ROMENTRY5_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY5_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY5_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000014ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY5", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY5 cavm_apbrom_horizontal_romentry5_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY5 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY5 "APBROM_HORIZONTAL_ROMENTRY5"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY5 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY5 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry50
 *
 * APBROM Horizontal Romentry50 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry50
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry50_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry50_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry50 cavm_apbrom_horizontal_romentry50_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY50 CAVM_APBROM_HORIZONTAL_ROMENTRY50_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY50_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY50_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460000c8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY50", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY50 cavm_apbrom_horizontal_romentry50_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY50 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY50 "APBROM_HORIZONTAL_ROMENTRY50"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY50 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY50 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry500
 *
 * APBROM Horizontal Romentry500 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry500
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry500_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry500_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry500 cavm_apbrom_horizontal_romentry500_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY500 CAVM_APBROM_HORIZONTAL_ROMENTRY500_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY500_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY500_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460007d0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY500", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY500 cavm_apbrom_horizontal_romentry500_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY500 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY500 "APBROM_HORIZONTAL_ROMENTRY500"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY500 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY500 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry501
 *
 * APBROM Horizontal Romentry501 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry501
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry501_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry501_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry501 cavm_apbrom_horizontal_romentry501_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY501 CAVM_APBROM_HORIZONTAL_ROMENTRY501_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY501_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY501_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460007d4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY501", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY501 cavm_apbrom_horizontal_romentry501_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY501 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY501 "APBROM_HORIZONTAL_ROMENTRY501"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY501 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY501 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry502
 *
 * APBROM Horizontal Romentry502 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry502
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry502_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry502_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry502 cavm_apbrom_horizontal_romentry502_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY502 CAVM_APBROM_HORIZONTAL_ROMENTRY502_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY502_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY502_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460007d8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY502", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY502 cavm_apbrom_horizontal_romentry502_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY502 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY502 "APBROM_HORIZONTAL_ROMENTRY502"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY502 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY502 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry503
 *
 * APBROM Horizontal Romentry503 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry503
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry503_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry503_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry503 cavm_apbrom_horizontal_romentry503_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY503 CAVM_APBROM_HORIZONTAL_ROMENTRY503_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY503_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY503_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460007dcll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY503", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY503 cavm_apbrom_horizontal_romentry503_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY503 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY503 "APBROM_HORIZONTAL_ROMENTRY503"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY503 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY503 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry504
 *
 * APBROM Horizontal Romentry504 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry504
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry504_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry504_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry504 cavm_apbrom_horizontal_romentry504_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY504 CAVM_APBROM_HORIZONTAL_ROMENTRY504_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY504_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY504_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460007e0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY504", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY504 cavm_apbrom_horizontal_romentry504_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY504 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY504 "APBROM_HORIZONTAL_ROMENTRY504"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY504 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY504 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry505
 *
 * APBROM Horizontal Romentry505 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry505
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry505_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry505_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry505 cavm_apbrom_horizontal_romentry505_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY505 CAVM_APBROM_HORIZONTAL_ROMENTRY505_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY505_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY505_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460007e4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY505", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY505 cavm_apbrom_horizontal_romentry505_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY505 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY505 "APBROM_HORIZONTAL_ROMENTRY505"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY505 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY505 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry506
 *
 * APBROM Horizontal Romentry506 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry506
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry506_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry506_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry506 cavm_apbrom_horizontal_romentry506_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY506 CAVM_APBROM_HORIZONTAL_ROMENTRY506_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY506_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY506_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460007e8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY506", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY506 cavm_apbrom_horizontal_romentry506_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY506 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY506 "APBROM_HORIZONTAL_ROMENTRY506"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY506 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY506 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry507
 *
 * APBROM Horizontal Romentry507 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry507
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry507_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry507_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry507 cavm_apbrom_horizontal_romentry507_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY507 CAVM_APBROM_HORIZONTAL_ROMENTRY507_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY507_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY507_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460007ecll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY507", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY507 cavm_apbrom_horizontal_romentry507_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY507 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY507 "APBROM_HORIZONTAL_ROMENTRY507"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY507 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY507 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry508
 *
 * APBROM Horizontal Romentry508 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry508
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry508_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry508_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry508 cavm_apbrom_horizontal_romentry508_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY508 CAVM_APBROM_HORIZONTAL_ROMENTRY508_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY508_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY508_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460007f0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY508", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY508 cavm_apbrom_horizontal_romentry508_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY508 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY508 "APBROM_HORIZONTAL_ROMENTRY508"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY508 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY508 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry509
 *
 * APBROM Horizontal Romentry509 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry509
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry509_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry509_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry509 cavm_apbrom_horizontal_romentry509_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY509 CAVM_APBROM_HORIZONTAL_ROMENTRY509_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY509_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY509_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460007f4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY509", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY509 cavm_apbrom_horizontal_romentry509_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY509 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY509 "APBROM_HORIZONTAL_ROMENTRY509"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY509 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY509 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry51
 *
 * APBROM Horizontal Romentry51 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry51
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry51_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry51_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry51 cavm_apbrom_horizontal_romentry51_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY51 CAVM_APBROM_HORIZONTAL_ROMENTRY51_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY51_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY51_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460000ccll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY51", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY51 cavm_apbrom_horizontal_romentry51_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY51 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY51 "APBROM_HORIZONTAL_ROMENTRY51"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY51 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY51 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry510
 *
 * APBROM Horizontal Romentry510 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry510
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry510_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry510_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry510 cavm_apbrom_horizontal_romentry510_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY510 CAVM_APBROM_HORIZONTAL_ROMENTRY510_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY510_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY510_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460007f8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY510", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY510 cavm_apbrom_horizontal_romentry510_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY510 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY510 "APBROM_HORIZONTAL_ROMENTRY510"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY510 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY510 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry511
 *
 * APBROM Horizontal Romentry511 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry511
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry511_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry511_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry511 cavm_apbrom_horizontal_romentry511_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY511 CAVM_APBROM_HORIZONTAL_ROMENTRY511_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY511_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY511_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460007fcll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY511", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY511 cavm_apbrom_horizontal_romentry511_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY511 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY511 "APBROM_HORIZONTAL_ROMENTRY511"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY511 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY511 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry52
 *
 * APBROM Horizontal Romentry52 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry52
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry52_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry52_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry52 cavm_apbrom_horizontal_romentry52_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY52 CAVM_APBROM_HORIZONTAL_ROMENTRY52_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY52_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY52_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460000d0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY52", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY52 cavm_apbrom_horizontal_romentry52_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY52 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY52 "APBROM_HORIZONTAL_ROMENTRY52"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY52 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY52 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry53
 *
 * APBROM Horizontal Romentry53 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry53
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry53_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry53_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry53 cavm_apbrom_horizontal_romentry53_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY53 CAVM_APBROM_HORIZONTAL_ROMENTRY53_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY53_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY53_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460000d4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY53", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY53 cavm_apbrom_horizontal_romentry53_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY53 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY53 "APBROM_HORIZONTAL_ROMENTRY53"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY53 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY53 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry54
 *
 * APBROM Horizontal Romentry54 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry54
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry54_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry54_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry54 cavm_apbrom_horizontal_romentry54_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY54 CAVM_APBROM_HORIZONTAL_ROMENTRY54_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY54_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY54_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460000d8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY54", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY54 cavm_apbrom_horizontal_romentry54_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY54 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY54 "APBROM_HORIZONTAL_ROMENTRY54"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY54 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY54 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry55
 *
 * APBROM Horizontal Romentry55 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry55
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry55_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry55_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry55 cavm_apbrom_horizontal_romentry55_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY55 CAVM_APBROM_HORIZONTAL_ROMENTRY55_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY55_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY55_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460000dcll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY55", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY55 cavm_apbrom_horizontal_romentry55_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY55 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY55 "APBROM_HORIZONTAL_ROMENTRY55"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY55 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY55 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry56
 *
 * APBROM Horizontal Romentry56 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry56
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry56_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry56_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry56 cavm_apbrom_horizontal_romentry56_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY56 CAVM_APBROM_HORIZONTAL_ROMENTRY56_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY56_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY56_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460000e0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY56", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY56 cavm_apbrom_horizontal_romentry56_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY56 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY56 "APBROM_HORIZONTAL_ROMENTRY56"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY56 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY56 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry57
 *
 * APBROM Horizontal Romentry57 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry57
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry57_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry57_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry57 cavm_apbrom_horizontal_romentry57_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY57 CAVM_APBROM_HORIZONTAL_ROMENTRY57_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY57_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY57_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460000e4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY57", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY57 cavm_apbrom_horizontal_romentry57_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY57 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY57 "APBROM_HORIZONTAL_ROMENTRY57"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY57 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY57 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry58
 *
 * APBROM Horizontal Romentry58 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry58
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry58_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry58_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry58 cavm_apbrom_horizontal_romentry58_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY58 CAVM_APBROM_HORIZONTAL_ROMENTRY58_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY58_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY58_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460000e8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY58", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY58 cavm_apbrom_horizontal_romentry58_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY58 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY58 "APBROM_HORIZONTAL_ROMENTRY58"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY58 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY58 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry59
 *
 * APBROM Horizontal Romentry59 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry59
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry59_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry59_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry59 cavm_apbrom_horizontal_romentry59_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY59 CAVM_APBROM_HORIZONTAL_ROMENTRY59_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY59_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY59_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460000ecll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY59", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY59 cavm_apbrom_horizontal_romentry59_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY59 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY59 "APBROM_HORIZONTAL_ROMENTRY59"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY59 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY59 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry6
 *
 * APBROM Horizontal Romentry6 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry6
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry6_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry6 cavm_apbrom_horizontal_romentry6_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY6 CAVM_APBROM_HORIZONTAL_ROMENTRY6_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY6_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY6_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000018ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY6", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY6 cavm_apbrom_horizontal_romentry6_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY6 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY6 "APBROM_HORIZONTAL_ROMENTRY6"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY6 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY6 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry60
 *
 * APBROM Horizontal Romentry60 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry60
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry60_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry60_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry60 cavm_apbrom_horizontal_romentry60_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY60 CAVM_APBROM_HORIZONTAL_ROMENTRY60_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY60_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY60_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460000f0ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY60", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY60 cavm_apbrom_horizontal_romentry60_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY60 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY60 "APBROM_HORIZONTAL_ROMENTRY60"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY60 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY60 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry61
 *
 * APBROM Horizontal Romentry61 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry61
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry61_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry61_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry61 cavm_apbrom_horizontal_romentry61_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY61 CAVM_APBROM_HORIZONTAL_ROMENTRY61_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY61_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY61_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460000f4ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY61", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY61 cavm_apbrom_horizontal_romentry61_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY61 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY61 "APBROM_HORIZONTAL_ROMENTRY61"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY61 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY61 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry62
 *
 * APBROM Horizontal Romentry62 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry62
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry62_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry62_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry62 cavm_apbrom_horizontal_romentry62_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY62 CAVM_APBROM_HORIZONTAL_ROMENTRY62_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY62_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY62_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460000f8ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY62", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY62 cavm_apbrom_horizontal_romentry62_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY62 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY62 "APBROM_HORIZONTAL_ROMENTRY62"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY62 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY62 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry63
 *
 * APBROM Horizontal Romentry63 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry63
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry63_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry63_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry63 cavm_apbrom_horizontal_romentry63_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY63 CAVM_APBROM_HORIZONTAL_ROMENTRY63_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY63_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY63_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e0460000fcll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY63", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY63 cavm_apbrom_horizontal_romentry63_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY63 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY63 "APBROM_HORIZONTAL_ROMENTRY63"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY63 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY63 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry64
 *
 * APBROM Horizontal Romentry64 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry64
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry64_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry64_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry64 cavm_apbrom_horizontal_romentry64_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY64 CAVM_APBROM_HORIZONTAL_ROMENTRY64_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY64_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY64_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000100ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY64", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY64 cavm_apbrom_horizontal_romentry64_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY64 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY64 "APBROM_HORIZONTAL_ROMENTRY64"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY64 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY64 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry65
 *
 * APBROM Horizontal Romentry65 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry65
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry65_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry65_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry65 cavm_apbrom_horizontal_romentry65_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY65 CAVM_APBROM_HORIZONTAL_ROMENTRY65_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY65_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY65_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000104ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY65", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY65 cavm_apbrom_horizontal_romentry65_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY65 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY65 "APBROM_HORIZONTAL_ROMENTRY65"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY65 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY65 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry66
 *
 * APBROM Horizontal Romentry66 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry66
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry66_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry66_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry66 cavm_apbrom_horizontal_romentry66_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY66 CAVM_APBROM_HORIZONTAL_ROMENTRY66_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY66_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY66_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000108ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY66", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY66 cavm_apbrom_horizontal_romentry66_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY66 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY66 "APBROM_HORIZONTAL_ROMENTRY66"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY66 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY66 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry67
 *
 * APBROM Horizontal Romentry67 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry67
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry67_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry67_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry67 cavm_apbrom_horizontal_romentry67_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY67 CAVM_APBROM_HORIZONTAL_ROMENTRY67_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY67_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY67_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600010cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY67", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY67 cavm_apbrom_horizontal_romentry67_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY67 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY67 "APBROM_HORIZONTAL_ROMENTRY67"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY67 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY67 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry68
 *
 * APBROM Horizontal Romentry68 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry68
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry68_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry68_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry68 cavm_apbrom_horizontal_romentry68_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY68 CAVM_APBROM_HORIZONTAL_ROMENTRY68_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY68_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY68_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000110ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY68", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY68 cavm_apbrom_horizontal_romentry68_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY68 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY68 "APBROM_HORIZONTAL_ROMENTRY68"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY68 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY68 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry69
 *
 * APBROM Horizontal Romentry69 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry69
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry69_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry69_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry69 cavm_apbrom_horizontal_romentry69_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY69 CAVM_APBROM_HORIZONTAL_ROMENTRY69_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY69_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY69_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000114ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY69", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY69 cavm_apbrom_horizontal_romentry69_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY69 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY69 "APBROM_HORIZONTAL_ROMENTRY69"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY69 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY69 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry7
 *
 * APBROM Horizontal Romentry7 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry7
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry7_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry7_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry7 cavm_apbrom_horizontal_romentry7_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY7 CAVM_APBROM_HORIZONTAL_ROMENTRY7_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY7_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY7_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600001cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY7", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY7 cavm_apbrom_horizontal_romentry7_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY7 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY7 "APBROM_HORIZONTAL_ROMENTRY7"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY7 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY7 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry70
 *
 * APBROM Horizontal Romentry70 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry70
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry70_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry70_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry70 cavm_apbrom_horizontal_romentry70_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY70 CAVM_APBROM_HORIZONTAL_ROMENTRY70_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY70_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY70_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000118ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY70", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY70 cavm_apbrom_horizontal_romentry70_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY70 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY70 "APBROM_HORIZONTAL_ROMENTRY70"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY70 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY70 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry71
 *
 * APBROM Horizontal Romentry71 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry71
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry71_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry71_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry71 cavm_apbrom_horizontal_romentry71_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY71 CAVM_APBROM_HORIZONTAL_ROMENTRY71_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY71_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY71_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600011cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY71", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY71 cavm_apbrom_horizontal_romentry71_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY71 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY71 "APBROM_HORIZONTAL_ROMENTRY71"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY71 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY71 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry72
 *
 * APBROM Horizontal Romentry72 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry72
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry72_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry72_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry72 cavm_apbrom_horizontal_romentry72_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY72 CAVM_APBROM_HORIZONTAL_ROMENTRY72_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY72_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY72_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000120ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY72", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY72 cavm_apbrom_horizontal_romentry72_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY72 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY72 "APBROM_HORIZONTAL_ROMENTRY72"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY72 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY72 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry73
 *
 * APBROM Horizontal Romentry73 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry73
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry73_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry73_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry73 cavm_apbrom_horizontal_romentry73_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY73 CAVM_APBROM_HORIZONTAL_ROMENTRY73_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY73_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY73_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000124ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY73", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY73 cavm_apbrom_horizontal_romentry73_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY73 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY73 "APBROM_HORIZONTAL_ROMENTRY73"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY73 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY73 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry74
 *
 * APBROM Horizontal Romentry74 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry74
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry74_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry74_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry74 cavm_apbrom_horizontal_romentry74_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY74 CAVM_APBROM_HORIZONTAL_ROMENTRY74_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY74_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY74_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000128ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY74", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY74 cavm_apbrom_horizontal_romentry74_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY74 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY74 "APBROM_HORIZONTAL_ROMENTRY74"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY74 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY74 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry75
 *
 * APBROM Horizontal Romentry75 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry75
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry75_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry75_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry75 cavm_apbrom_horizontal_romentry75_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY75 CAVM_APBROM_HORIZONTAL_ROMENTRY75_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY75_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY75_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600012cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY75", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY75 cavm_apbrom_horizontal_romentry75_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY75 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY75 "APBROM_HORIZONTAL_ROMENTRY75"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY75 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY75 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry76
 *
 * APBROM Horizontal Romentry76 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry76
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry76_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry76_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry76 cavm_apbrom_horizontal_romentry76_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY76 CAVM_APBROM_HORIZONTAL_ROMENTRY76_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY76_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY76_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000130ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY76", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY76 cavm_apbrom_horizontal_romentry76_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY76 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY76 "APBROM_HORIZONTAL_ROMENTRY76"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY76 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY76 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry77
 *
 * APBROM Horizontal Romentry77 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry77
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry77_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry77_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry77 cavm_apbrom_horizontal_romentry77_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY77 CAVM_APBROM_HORIZONTAL_ROMENTRY77_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY77_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY77_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000134ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY77", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY77 cavm_apbrom_horizontal_romentry77_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY77 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY77 "APBROM_HORIZONTAL_ROMENTRY77"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY77 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY77 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry78
 *
 * APBROM Horizontal Romentry78 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry78
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry78_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry78_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry78 cavm_apbrom_horizontal_romentry78_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY78 CAVM_APBROM_HORIZONTAL_ROMENTRY78_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY78_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY78_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000138ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY78", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY78 cavm_apbrom_horizontal_romentry78_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY78 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY78 "APBROM_HORIZONTAL_ROMENTRY78"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY78 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY78 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry79
 *
 * APBROM Horizontal Romentry79 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry79
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry79_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry79_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry79 cavm_apbrom_horizontal_romentry79_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY79 CAVM_APBROM_HORIZONTAL_ROMENTRY79_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY79_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY79_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600013cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY79", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY79 cavm_apbrom_horizontal_romentry79_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY79 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY79 "APBROM_HORIZONTAL_ROMENTRY79"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY79 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY79 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry8
 *
 * APBROM Horizontal Romentry8 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry8
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry8_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry8_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry8 cavm_apbrom_horizontal_romentry8_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY8 CAVM_APBROM_HORIZONTAL_ROMENTRY8_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY8_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY8_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000020ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY8", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY8 cavm_apbrom_horizontal_romentry8_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY8 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY8 "APBROM_HORIZONTAL_ROMENTRY8"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY8 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY8 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry80
 *
 * APBROM Horizontal Romentry80 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry80
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry80_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry80_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry80 cavm_apbrom_horizontal_romentry80_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY80 CAVM_APBROM_HORIZONTAL_ROMENTRY80_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY80_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY80_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000140ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY80", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY80 cavm_apbrom_horizontal_romentry80_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY80 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY80 "APBROM_HORIZONTAL_ROMENTRY80"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY80 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY80 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry81
 *
 * APBROM Horizontal Romentry81 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry81
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry81_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry81_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry81 cavm_apbrom_horizontal_romentry81_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY81 CAVM_APBROM_HORIZONTAL_ROMENTRY81_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY81_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY81_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000144ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY81", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY81 cavm_apbrom_horizontal_romentry81_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY81 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY81 "APBROM_HORIZONTAL_ROMENTRY81"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY81 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY81 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry82
 *
 * APBROM Horizontal Romentry82 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry82
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry82_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry82_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry82 cavm_apbrom_horizontal_romentry82_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY82 CAVM_APBROM_HORIZONTAL_ROMENTRY82_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY82_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY82_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000148ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY82", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY82 cavm_apbrom_horizontal_romentry82_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY82 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY82 "APBROM_HORIZONTAL_ROMENTRY82"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY82 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY82 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry83
 *
 * APBROM Horizontal Romentry83 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry83
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry83_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry83_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry83 cavm_apbrom_horizontal_romentry83_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY83 CAVM_APBROM_HORIZONTAL_ROMENTRY83_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY83_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY83_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600014cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY83", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY83 cavm_apbrom_horizontal_romentry83_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY83 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY83 "APBROM_HORIZONTAL_ROMENTRY83"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY83 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY83 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry84
 *
 * APBROM Horizontal Romentry84 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry84
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry84_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry84_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry84 cavm_apbrom_horizontal_romentry84_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY84 CAVM_APBROM_HORIZONTAL_ROMENTRY84_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY84_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY84_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000150ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY84", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY84 cavm_apbrom_horizontal_romentry84_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY84 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY84 "APBROM_HORIZONTAL_ROMENTRY84"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY84 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY84 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry85
 *
 * APBROM Horizontal Romentry85 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry85
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry85_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry85_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry85 cavm_apbrom_horizontal_romentry85_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY85 CAVM_APBROM_HORIZONTAL_ROMENTRY85_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY85_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY85_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000154ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY85", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY85 cavm_apbrom_horizontal_romentry85_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY85 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY85 "APBROM_HORIZONTAL_ROMENTRY85"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY85 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY85 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry86
 *
 * APBROM Horizontal Romentry86 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry86
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry86_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry86_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry86 cavm_apbrom_horizontal_romentry86_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY86 CAVM_APBROM_HORIZONTAL_ROMENTRY86_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY86_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY86_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000158ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY86", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY86 cavm_apbrom_horizontal_romentry86_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY86 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY86 "APBROM_HORIZONTAL_ROMENTRY86"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY86 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY86 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry87
 *
 * APBROM Horizontal Romentry87 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry87
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry87_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry87_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry87 cavm_apbrom_horizontal_romentry87_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY87 CAVM_APBROM_HORIZONTAL_ROMENTRY87_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY87_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY87_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600015cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY87", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY87 cavm_apbrom_horizontal_romentry87_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY87 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY87 "APBROM_HORIZONTAL_ROMENTRY87"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY87 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY87 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry88
 *
 * APBROM Horizontal Romentry88 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry88
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry88_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry88_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry88 cavm_apbrom_horizontal_romentry88_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY88 CAVM_APBROM_HORIZONTAL_ROMENTRY88_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY88_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY88_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000160ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY88", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY88 cavm_apbrom_horizontal_romentry88_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY88 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY88 "APBROM_HORIZONTAL_ROMENTRY88"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY88 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY88 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry89
 *
 * APBROM Horizontal Romentry89 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry89
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry89_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry89_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry89 cavm_apbrom_horizontal_romentry89_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY89 CAVM_APBROM_HORIZONTAL_ROMENTRY89_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY89_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY89_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000164ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY89", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY89 cavm_apbrom_horizontal_romentry89_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY89 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY89 "APBROM_HORIZONTAL_ROMENTRY89"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY89 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY89 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry9
 *
 * APBROM Horizontal Romentry9 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry9
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry9_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry9_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry9 cavm_apbrom_horizontal_romentry9_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY9 CAVM_APBROM_HORIZONTAL_ROMENTRY9_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY9_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY9_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000024ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY9", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY9 cavm_apbrom_horizontal_romentry9_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY9 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY9 "APBROM_HORIZONTAL_ROMENTRY9"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY9 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY9 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry90
 *
 * APBROM Horizontal Romentry90 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry90
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry90_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry90_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry90 cavm_apbrom_horizontal_romentry90_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY90 CAVM_APBROM_HORIZONTAL_ROMENTRY90_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY90_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY90_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000168ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY90", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY90 cavm_apbrom_horizontal_romentry90_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY90 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY90 "APBROM_HORIZONTAL_ROMENTRY90"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY90 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY90 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry91
 *
 * APBROM Horizontal Romentry91 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry91
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry91_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry91_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry91 cavm_apbrom_horizontal_romentry91_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY91 CAVM_APBROM_HORIZONTAL_ROMENTRY91_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY91_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY91_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600016cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY91", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY91 cavm_apbrom_horizontal_romentry91_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY91 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY91 "APBROM_HORIZONTAL_ROMENTRY91"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY91 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY91 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry92
 *
 * APBROM Horizontal Romentry92 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry92
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry92_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry92_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry92 cavm_apbrom_horizontal_romentry92_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY92 CAVM_APBROM_HORIZONTAL_ROMENTRY92_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY92_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY92_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000170ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY92", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY92 cavm_apbrom_horizontal_romentry92_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY92 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY92 "APBROM_HORIZONTAL_ROMENTRY92"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY92 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY92 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry93
 *
 * APBROM Horizontal Romentry93 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry93
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry93_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry93_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry93 cavm_apbrom_horizontal_romentry93_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY93 CAVM_APBROM_HORIZONTAL_ROMENTRY93_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY93_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY93_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000174ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY93", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY93 cavm_apbrom_horizontal_romentry93_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY93 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY93 "APBROM_HORIZONTAL_ROMENTRY93"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY93 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY93 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry94
 *
 * APBROM Horizontal Romentry94 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry94
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry94_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry94_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry94 cavm_apbrom_horizontal_romentry94_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY94 CAVM_APBROM_HORIZONTAL_ROMENTRY94_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY94_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY94_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000178ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY94", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY94 cavm_apbrom_horizontal_romentry94_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY94 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY94 "APBROM_HORIZONTAL_ROMENTRY94"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY94 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY94 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry95
 *
 * APBROM Horizontal Romentry95 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry95
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry95_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry95_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry95 cavm_apbrom_horizontal_romentry95_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY95 CAVM_APBROM_HORIZONTAL_ROMENTRY95_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY95_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY95_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600017cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY95", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY95 cavm_apbrom_horizontal_romentry95_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY95 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY95 "APBROM_HORIZONTAL_ROMENTRY95"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY95 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY95 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry96
 *
 * APBROM Horizontal Romentry96 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry96
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry96_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry96_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry96 cavm_apbrom_horizontal_romentry96_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY96 CAVM_APBROM_HORIZONTAL_ROMENTRY96_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY96_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY96_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000180ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY96", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY96 cavm_apbrom_horizontal_romentry96_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY96 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY96 "APBROM_HORIZONTAL_ROMENTRY96"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY96 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY96 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry97
 *
 * APBROM Horizontal Romentry97 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry97
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry97_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry97_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry97 cavm_apbrom_horizontal_romentry97_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY97 CAVM_APBROM_HORIZONTAL_ROMENTRY97_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY97_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY97_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000184ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY97", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY97 cavm_apbrom_horizontal_romentry97_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY97 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY97 "APBROM_HORIZONTAL_ROMENTRY97"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY97 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY97 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry98
 *
 * APBROM Horizontal Romentry98 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry98
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry98_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry98_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry98 cavm_apbrom_horizontal_romentry98_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY98 CAVM_APBROM_HORIZONTAL_ROMENTRY98_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY98_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY98_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e046000188ll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY98", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY98 cavm_apbrom_horizontal_romentry98_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY98 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY98 "APBROM_HORIZONTAL_ROMENTRY98"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY98 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY98 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry99
 *
 * APBROM Horizontal Romentry99 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union cavm_apbrom_horizontal_romentry99
{
    uint32_t u;
    struct cavm_apbrom_horizontal_romentry99_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_apbrom_horizontal_romentry99_s cn; */
};
typedef union cavm_apbrom_horizontal_romentry99 cavm_apbrom_horizontal_romentry99_t;

#define CAVM_APBROM_HORIZONTAL_ROMENTRY99 CAVM_APBROM_HORIZONTAL_ROMENTRY99_FUNC()
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY99_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_APBROM_HORIZONTAL_ROMENTRY99_FUNC(void)
{
    if (cavm_is_model(OCTEONTX_LOKI))
        return 0x87e04600018cll;
    __cavm_csr_fatal("APBROM_HORIZONTAL_ROMENTRY99", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_APBROM_HORIZONTAL_ROMENTRY99 cavm_apbrom_horizontal_romentry99_t
#define bustype_CAVM_APBROM_HORIZONTAL_ROMENTRY99 CSR_TYPE_RSL32b
#define basename_CAVM_APBROM_HORIZONTAL_ROMENTRY99 "APBROM_HORIZONTAL_ROMENTRY99"
#define busnum_CAVM_APBROM_HORIZONTAL_ROMENTRY99 0
#define arguments_CAVM_APBROM_HORIZONTAL_ROMENTRY99 -1,-1,-1,-1

#endif /* __CAVM_CSRS_APBROM_HORIZONTAL_H__ */
